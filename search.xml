<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[文字循环无缝滚动特效代码]]></title>
      <url>https://fantasticzhang.github.io/2016/12/29/%E6%96%87%E5%AD%97%E5%BE%AA%E7%8E%AF%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8%E7%89%B9%E6%95%88%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今天突然被问到了这个问题，现把我的解决方案记下来以便日后查看。下面是一个简单的小例子：</p>
<pre><code>&lt;div  id=&quot;textScroll&quot; style=&quot;overflow:hidden;height:200px;width:300px;font-size:14px;line-height:22px;text-align:left;padding:10px&quot;&gt;
&lt;div id=&quot;textScroll1&quot;&gt;
  文字实循环无缝滚动
  &lt;/div&gt;
&lt;div id=&quot;textScroll2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

//原理：设置好固定的宽高，内容的实际高度比这个高得多。控制滚动条，在滚到一定位置后减小滚动条高度，重复此过程。

var textScroll = document.getElementById(&quot;textScroll&quot;);
var textScroll1 = document.getElementById(&quot;textScroll1&quot;);
var textScroll2 = document.getElementById(&quot;textScroll2&quot;);
var speed=50;    //滚动速度值，值越大速度越慢

//复制文本,使文本总高度大于父元素高度，这样才能无缝滚动
var nnn=200/textScroll1.offsetHeight;
for(i=0;i&lt;nnn;i++){textScroll1.innerHTML+=&quot;&lt;br /&gt;&quot;+ textScroll1.innerHTML}
textScroll2.innerHTML = textScroll1.innerHTML;

function Marquee(){
if(textScroll2.offsetTop-textScroll.scrollTop&lt;=0)    //当滚动至textScroll2时
{
    textScroll.scrollTop-=textScroll1.offsetHeight;    //textScroll跳到最顶端,从头开始滚动

}
else{
    textScroll.scrollTop++;     //持续滚动
}
}

var MyMar = setInterval(Marquee,speed);        //设置定时器
textScroll.onmouseover = function(){clearInterval(MyMar)}    //鼠标经过时清除定时器达到滚动停止的目的
textScroll.onmouseout = function(){MyMar = setInterval(Marquee,speed)};    //鼠标移开时重设定时器
&lt;/script&gt;
</code></pre><p>例子很简单，可根据实际情况进行修改以满足实际需要。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序开发（一）]]></title>
      <url>https://fantasticzhang.github.io/2016/12/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>前段时间，微信小程序突然火了，朋友圈被刷屏了。但由于某些原因，博主一直没有了解它，终于在昨天，抽了些时间了解了下小程序，主要是阅读了官方文档，之后博主觉得，小程序还是蛮有意思的，于是决定将自己的学习过程记录下来，也希望能够和同样对微信小程序感兴趣的朋友们多多交流。</p>
<p>以下内容主要来自于<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1481249514" title="小程序官方文档" target="_blank" rel="external">官方文档</a>。</p>
<h1 id="微信小程序简介"><a href="#微信小程序简介" class="headerlink" title="微信小程序简介"></a>微信小程序简介</h1><p>下面是官方给出的关于微信小程序的介绍：</p>
<p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。小程序、订阅号、服务号、企业号是并行的体系。</p>
<p>由官方的表述来看，通俗一点的说，微信小程序其实就是微信提高了自身对HTML5特性的支持能力，开放了更多的系统调用。因此，微信里的HTML5产品将有更好的用户体验，更快的加载速度以及更多的功能。</p>
<h1 id="小程序注册"><a href="#小程序注册" class="headerlink" title="小程序注册"></a>小程序注册</h1><p>目前，微信小程序只开放了对企业、政府、媒体以及其他组织的注册，并没有开放对个人开发者的注册，那么个人如何注册小程序并进行学习呢？博主主要是参考了网上的一个方法，亲测可用。<a href="https://www.zhihu.com/question/52268924" target="_blank" rel="external">参考链接</a></p>
<h1 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h1><p>下面是官方文档给出的一个简易教程，这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。</p>
<p>注：以下教程默认注册账号、开发者、体验者都是使用管理员微信号。</p>
<h2 id="获取微信小程序的AppID"><a href="#获取微信小程序的AppID" class="headerlink" title="获取微信小程序的AppID"></a>获取微信小程序的AppID</h2><p>注册微信小程序并登录后，就可以在网站的“设置”-“开发者设置”中，查看到微信小程序的AppID了。</p>
<p><img src="/images/2016-12-9/1.png" alt=""></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们需要通过<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html?t=20161122" target="_blank" rel="external">开发者工具</a>，来完成小程序创建和代码编辑。</p>
<p>开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“firstProject”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。</p>
<p>为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。</p>
<p>项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。默认demo运行结果如下：</p>
<p><img src="/images/2016-12-9/2.PNG" alt=""></p>
<h2 id="项目结构简介"><a href="#项目结构简介" class="headerlink" title="项目结构简介"></a>项目结构简介</h2><p>点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p>
<p>下面简单介绍下这三个文件的功能。</p>
<ul>
<li><p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
<pre><code>//app.js
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync(&apos;logs&apos;) || []
    logs.unshift(Date.now())
    wx.setStorageSync(&apos;logs&apos;, logs)
  },
  getUserInfo:function(cb){
    var that = this
    if(this.globalData.userInfo){
      typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo
              typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)
            }
          })
        }
      })
    }
  },
  globalData:{
    userInfo:null
  }
})
</code></pre></li>
<li><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p>
<pre><code>{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;
  },
  &quot;tabBar&quot;: {
    &quot;position&quot;: &quot;bottom&quot;,
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre></li>
<li><p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p>
<pre><code>/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
} 
</code></pre></li>
</ul>
<p>在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成：</p>
<ul>
<li><p>.js后缀的文件是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
</li>
<li><p>.json后缀的文件是页面的配置文件，它是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p>
</li>
<li><p>.wxss后缀的是页面的样式表文件，它也是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
</li>
<li><p>.wxml后缀的文件是页面结构文件，用来搭建页面结构，绑定数据和交互处理函数。</p>
</li>
</ul>
<p>以上就是页面结构的简单介绍，在小程序开发框架一节中还会对这部分内容进行详细介绍。</p>
<h2 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h2><p>开发者工具左侧菜单栏选择”项目”，点击”预览”，扫码后即可在微信客户端中体验。</p>
<p><img src="/images/2016-12-9/3.PNG" alt=""></p>
<h1 id="小程序开发框架"><a href="#小程序开发框架" class="headerlink" title="小程序开发框架"></a>小程序开发框架</h1><p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p>
<p>框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p>
<p>下面将从目录结构、配置、逻辑层和视图层四个方面对小程序开发框架进行介绍。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。在上一节中我们已经对目录结构进行了简单的了解。</p>
<ul>
<li><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，分别是：app.js、app.json、app.wxss 。其中，app.js是小程序的脚本代码，用来控制小程序的逻辑，它是必要的；app.json是对整个小程序的全局配置，它也是必要的；app.wxss是整个小程序的公共样式表，它是非必要的。</p>
</li>
<li><p>一个小程序页面由四个文件组成，分别是：.js、.json、.wxss、.wxml四个文件。其中.js后缀的文件是页面脚本文件，用来控制页面逻辑；.json后缀的文件是页面配置文件；.wxss后缀的是页面样式表文件；.wxml后缀的文件是页面结构文件。.js文件和.wxml文件是必要的，另外两个文件是非必要的。</p>
</li>
</ul>
<p>注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p>app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>
<p>以下是一个包含了所有配置选项的简单配置app.json ：</p>
<pre><code>{
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/index&quot;
  ],
  &quot;window&quot;: {
    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
  },
  &quot;tabBar&quot;: {
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre><p>app.json 配置项列表</p>
<p><img src="/images/2016-12-9/4.PNG" alt=""></p>
<p>下面对这些配置项进行简单介绍。</p>
<h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h4><p>接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。</p>
<p>文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<p><img src="/images/2016-12-9/5.PNG" alt=""></p>
<h4 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h4><p>如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p>tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。</p>
<p>属性如下：</p>
<p><img src="/images/2016-12-9/6.PNG" alt=""></p>
<p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p>
<p><img src="/images/2016-12-9/7.PNG" alt=""></p>
<h4 id="networkTimeout"><a href="#networkTimeout" class="headerlink" title="networkTimeout"></a>networkTimeout</h4><p>可以设置各种网络请求的超时时间。</p>
<p>属性值如下：</p>
<p><img src="/images/2016-12-9/8.PNG" alt=""></p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发。可以帮助开发者快速定位一些常见的问题。</p>
<h3 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a>page.json</h3><p>每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。由于页面的配置只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，下面是一个简单的例子：</p>
<pre><code>{
  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,
  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,
  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,
  &quot;backgroundTextStyle&quot;: &quot;light&quot;
}
</code></pre><h2 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h2><p>小程序开发框架的逻辑层是由JavaScript编写，为了方便地开发小程序，在JavaScript的基础上做了一些修改，主要如下：</p>
<ul>
<li>增加App和Page方法，进行程序和页面注册；</li>
<li>增加getApp和getCurrentPages方法，分别用来获取App实例和当前页面栈；</li>
<li>由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等;</li>
<li>每个页面有独立的作用域，并提供模块化能力;</li>
<li>提供丰富的 API;</li>
<li>开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</li>
</ul>
<h3 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h3><p>App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/9.PNG" alt=""></p>
<p>注： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p>
<h3 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h3><p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/10.PNG" alt=""></p>
<h4 id="Page-prototype-setData"><a href="#Page-prototype-setData" class="headerlink" title="Page.prototype.setData()"></a>Page.prototype.setData()</h4><p>setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。</p>
<p>注意：</p>
<ol>
<li>直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。</li>
<li>单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</li>
</ol>
<p>setData 函数接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。</p>
<p>其中 key 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。</p>
<p>例子：</p>
<pre><code>&lt;!--index.wxml--&gt;
&lt;view&gt;{{text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt;
&lt;view&gt;{{array[0].text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInArray&quot;&gt; Change Array data &lt;/button&gt;
&lt;view&gt;{{object.text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInObject&quot;&gt; Change Object data &lt;/button&gt;
&lt;view&gt;{{newField.text}}&lt;/view&gt;
&lt;button bindtap=&quot;addNewField&quot;&gt; Add new data &lt;/button&gt;
//index.js
Page({
  data: {
    text: &apos;init data&apos;,
    array: [{text: &apos;init data&apos;}],
    object: {
      text: &apos;init data&apos;
    }
  },
  changeText: function() {
    // this.data.text = &apos;changed data&apos;  // bad, it can not work
    this.setData({
      text: &apos;changed data&apos;
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      &apos;array[0].text&apos;:&apos;changed data&apos;
    })
  },
  changeItemInObject: function(){
    this.setData({
      &apos;object.text&apos;: &apos;changed data&apos;
    });
  },
  addNewField: function() {
    this.setData({
      &apos;newField.text&apos;: &apos;new data&apos;
    })
  }
})
</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。</p>
<p>我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。</p>
<p>注：</p>
<ul>
<li>exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐使用 module.exports；</li>
<li>小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候可以拷贝出相关的代码到小程序的目录中。</li>
</ul>
<p>例子：</p>
<pre><code>// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
</code></pre><p>​在需要使用这些模块的文件中，使用 require(path) 将公共代码引入:</p>
<pre><code>var common = require(&apos;common.js&apos;)
Page({
  helloMINA: function() {
    common.sayHello(&apos;MINA&apos;)
  },
  goodbyeMINA: function() {
    common.sayGoodbye(&apos;MINA&apos;)
  }
})
</code></pre><h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。其中，WXML(WeiXin Markup language)用于描述页面的结构；WXSS(WeiXin Style Sheet)用于描述页面的样式；组件(Component)是视图的基本组成单元。</p>
<h3 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h3><p>WXML具有数据绑定、列表渲染、条件渲染、模板、事件和引用的功能。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>WXML 中的动态数据均来自对应 Page 的 data。</p>
<p>数据绑定使用Mustache语法（双大括号）将变量包起来，可以作用于：内容、组件属性、控制属性和关键字，其中后三者需要在双引号之内。</p>
<p>作用于关键字的例子：</p>
<pre><code>&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;    
</code></pre><ul>
<li><p>true：boolean 类型的 true，代表真值。</p>
</li>
<li><p>false： boolean 类型的 false，代表假值。</p>
</li>
</ul>
<p>注：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<p>还可在双大括号内进行简单的运算，支持的运算有：三元运算、算数运算、逻辑判断、字符串运算、数据路径运算等。</p>
<p>也可在双大括号内直接进行组合，构成新的对象或者数组。</p>
<p>具体的使用方法可参考官方文档给出的例子。</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>在框架中，我们用<code>wx:if</code>来判断是否需要渲染该代码块：</p>
<pre><code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;
</code></pre><p>也可以用<code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p>
<pre><code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre><p>因为<code>wx:if</code>是一个控制属性，需要将它添加到一个标签上。但是如果我们想一次性判断多个组件标签，我们可以使用一个<code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<pre><code>&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>注意：<code>&lt;block/&gt;</code>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>在组件上使用<code>wx:for</code>控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，使用<code>wx:for-index</code> 可以指定数组当前下标的变量名。</p>
<p>例子：</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}}: {{itemName.message}}
&lt;/view&gt;
</code></pre><p>类似block wx:if，也可以将wx:for用在<block>标签上，以渲染一个包含多节点的结构块。</block></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如<code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<p><code>wx:key</code> 的值以两种形式提供：</p>
<ul>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li>
</ul>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>如不提供 <code>wx:key</code>，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p>
<p>示例代码：</p>
<pre><code>&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; style=&quot;display: block;&quot;&gt; {{item.id}} &lt;/switch&gt;
&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;
&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;

&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; style=&quot;display: block;&quot;&gt; {{item}} &lt;/switch&gt;
&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add to the front &lt;/button&gt;

Page({
  data: {
    objectArray: [
      {id: 5, unique: &apos;unique_5&apos;},
      {id: 4, unique: &apos;unique_4&apos;},
      {id: 3, unique: &apos;unique_3&apos;},
      {id: 2, unique: &apos;unique_2&apos;},
      {id: 1, unique: &apos;unique_1&apos;},
      {id: 0, unique: &apos;unique_0&apos;},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i &lt; length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: &apos;unique_&apos; + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
</code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。模板拥有自己的作用域，只能使用data传入的数据。</p>
<p>例子：</p>
<pre><code>//定义模板
&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;

//使用模板
&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt;
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h5><p>事件分为冒泡事件和非冒泡事件：</p>
<ul>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ul>
<p>冒泡事件包括：</p>
<ul>
<li>touchstart：手指触摸动作开始；</li>
<li>touchmove：手指触摸后移动；</li>
<li>touchcancel：手指触摸动作被打断，如来电提醒，弹窗；</li>
<li>touchend：手指触摸动作结束；</li>
<li>tap：手指触摸后马上离开；</li>
<li>longtap：手指触摸后，超过350ms再离开。</li>
</ul>
<p>除以上之外的其他组件自定义事件如无特殊申明都是非冒泡事件。</p>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<ul>
<li>key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart；</li>
<li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li>
</ul>
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p>
<p><img src="/images/2016-12-9/11.PNG" alt=""></p>
<ul>
<li>type：事件的类型；</li>
<li>timeStamp：页面打开到触发事件所经过的毫秒数；</li>
<li><p>target：触发事件的源组件，包括：</p>
<ul>
<li>id：String，事件源组件的id；</li>
<li>tagName：String，当前组件的类型；</li>
<li>dataset：Object，事件源组件上由data-开头的自定义属性组成的集合。</li>
</ul>
</li>
<li><p>currentTarget：事件绑定的当前组件，属性同target；</p>
</li>
<li><p>touches：是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p>
<ul>
<li><p>Touch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>pageX, pageY：Number，距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴；</li>
<li>clientX, clientY：Number，距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
<li><p>CanvasTouch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>x, y：Number，距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
</ul>
</li>
<li><p>changedTouches：数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p>
</li>
<li><p>detail：自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息等，具体参见官方文档。</p>
</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>WXML 提供两种文件引用方式import和include。</p>
<ul>
<li>import：可以在该文件中使用目标文件定义的template。import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</li>
<li>include：include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置。</li>
</ul>
<h3 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h3><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。与 CSS 相比，WXSS扩展的特性有：尺寸单位，样式导入。</p>
<h4 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h4><ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li>
<li>rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。</li>
</ul>
<h4 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h4><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用;表示语句结束。</p>
<p>例子：</p>
<pre><code>/** common.wxss **/
.small-p {
  padding:5px;
}
/** app.wxss **/
@import &quot;common.wxss&quot;;
.middle-p {
  padding:15px;
}
</code></pre><p>WXSS目前支持的选择器有：<code>.class</code>、<code>#id</code>、<code>element</code>、<code>element, element</code>、<code>::after</code>、<code>::before</code>。</p>
<h2 id="组件和API"><a href="#组件和API" class="headerlink" title="组件和API"></a>组件和API</h2><p>框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<p>关于组件和API的详细内容参见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161122" target="_blank" rel="external">官方文档</a>.</p>
<p>官方文档阅读完后，就可以进行实际的开发了。对于一个新手来说，自己开发一个微信小程序可能有些难，不过网上有很多微信小程序的开发案例，可以在照着开发案例开发完一个微信小程序后，自己再独立的开发一个属性自己的微信小程序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[同一台电脑关联两个或多个Github账号]]></title>
      <url>https://fantasticzhang.github.io/2016/12/07/%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%85%B3%E8%81%94%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAGithub%E8%B4%A6%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>今天遇到了一个问题，我自己有一个github账号，项目组有一个github账号，然后我需要在我的电脑上同时管理这两个github账号的仓库，这时候该怎么办呢？在查阅了一些资料后，成功解决了这个问题，现将解决方案记录下来，以便日后查看。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>管理两个SSH key。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p><code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code></p>
<p>使用上面的命令在本地生成SSH key。由于需要管理两个github账号，因此在保存所生成的SSH key时需要注意两个key的文件名要有区别，比如我第一个账号生成的文件名为<code>id_rsa</code>，第二个账号生成的文件名为<code>id_rsa.gtensor</code>，这样就可以加以区分。</p>
<h3 id="将SSH-key添加到github"><a href="#将SSH-key添加到github" class="headerlink" title="将SSH key添加到github"></a>将SSH key添加到github</h3><p>将上一步所生成的两个SSH key分别添加到对应的github账户中。</p>
<h3 id="创建config文件"><a href="#创建config文件" class="headerlink" title="创建config文件"></a>创建config文件</h3><p><code>$touch config</code></p>
<p>在.ssh目录下，使用以上命令新建一个config文件，并在文件中添加如下内容：</p>
<pre><code>#default github
Host github.com
  HostName github.com
  IdentityFile ~/.ssh/id_rsa    
#gtensor github
Host github_gtensor
  HostName github.com  
  IdentityFile ~/.ssh/id_rsa.gtensor
</code></pre><p>其中，Host后面就是github账号的别名，这里就是为第二个github账号新增了一个别名<code>github_gtensor</code>，这样就将不同的账号区分开了。config文件的内容，需要根据自己的实际情况进行相应修改。</p>
<h3 id="将SSH-key添加到ssh-agent上"><a href="#将SSH-key添加到ssh-agent上" class="headerlink" title="将SSH key添加到ssh-agent上"></a>将SSH key添加到ssh-agent上</h3><p><code>$ ssh-add ~/.ssh/id_rsa.gtensor</code></p>
<p>在.ssh目录下，使用上面的命令将第二个账号的key添加到agent上。在执行以上命令时可能会出现错误提示： <code>Could not open a connection to your authentication agent</code>，此时需要执行以下命令开启ssh-agent服务：</p>
<p><code>$ eval $(ssh-agent)</code></p>
<h3 id="测试github连接是否成功"><a href="#测试github连接是否成功" class="headerlink" title="测试github连接是否成功"></a>测试github连接是否成功</h3><p><code>$ ssh –T git@github_gtensor</code></p>
<p>使用以上命令测试是否能连接github账户，其中<code>github_gtensor</code>即为我所设置的第二个github账号的别名，需要根据实际情况进行修改。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过以上配置，我们就可以通过使用github.com的别名github_gtensor来明确说明我们要使用id_rsa.gtensor的SSH key来连接github，即使用项目组的github账号进行操作。</p>
<p>例如，要克隆第二个github账号的远程仓库到本地，则原来的写法：</p>
<pre><code>$ git clone git@github.com: 第二个github账号的用户名/***.git
</code></pre><p>则现在的写法改为：</p>
<pre><code>$ git clone git@github_gtensor: 第二个github账号的用户名/***.git
</code></pre><p>我的环境是：win10 + git bash，测试成功，如有任何疑问，可给我留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Node的子进程调用脚本和系统命令]]></title>
      <url>https://fantasticzhang.github.io/2016/12/04/%E5%88%A9%E7%94%A8Node%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>child_process模块使得Node可以随意创建子进程。它提供了4个方法用于创建子进程。</p>
<ul>
<li>spawn(): 启动一个子进程来执行命令。</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile(): 启动一个子进程来执行可执行文件。</li>
<li>fork(): 与spawn()类似，不同点在于它创建Node的子进程只需要指定要执行的JavaScript文件模块即可。</li>
</ul>
<h2 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h2><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn()"></a>spawn()</h3><p><code>child_process.spawn(command[, args][, options])</code></p>
<p>spawn方法返回一个对象流，适合于输出大量数据然后需要读取的应用场合。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
free = shellProcess.spawn(&apos;free&apos;, [&apos;-m&apos;]);

// 捕获标准输出并将其打印到控制台
free.stdout.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard output:\n&apos; + data);
});

// 捕获标准错误输出并将其打印到控制台
free.stderr.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard error output:\n&apos; + data);
});

// 注册子进程关闭事件
free.on(&apos;exit&apos;, function (code) {
    console.log(&apos;child process exit ,exit:&apos; + code);
});
</code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><code>child_process.exec(command[, options][, callback])</code></p>
<p>exec方法会启动一个子进程来执行系统命令，并缓冲产生的数据，当子进程完成后回调函数就会被调用，可带有：</p>
<ul>
<li>当命令成功执行，缓冲的数据；</li>
<li>当命令执行失败，错误信息。</li>
</ul>
<p>exec方法并没有args参数选项，这是因为它允许我们执行多个命令，当使用exec方法时，如果需要传输参数到命令行，则参数应该作为整个命令字符串的一部分。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;chmod -R a+rwx start.sh&apos;, function(err,stdout,stderr){  //设置start.sh脚本的权限
       if(err) {
          return console.log(&apos;error:&apos;+stderr);
        }
   });
</code></pre><h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile()"></a>execFile()</h3><p><code>child_process.execFile(file[, args][, options][, callback])</code></p>
<p>当外部可执行文件存在时，该可执行文件将携带参数args被执行，当可执行文件退出时，回调函数被调用，回调函数带有子进程的标准输入输出，来自外部可执行文件的标准输出将被内部缓冲保存。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.execFile(&apos;./stop.sh&apos;, function(err, stdout, stderr){
     if(err) return console.error(err);
     console.log(&apos;stdout: &apos;+stdout);
});
</code></pre><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><code>fork(modulePath[,args][,options])</code></p>
<p>其中modulePath是一个字符串，用来指定JavaScript文件路径。</p>
<p>由于该方法还没有实际使用过，所以目前对它还不太了解，在日后充分了解后再进行补充。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>spawn()与exec()、execFile()的区别：</p>
<ul>
<li>exec()、execFile()都有一个回调函数获知子进程的状况；</li>
<li>exec()、execFile()创建时可指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</li>
</ul>
</li>
<li><p>exec()与execFile()的区别：exec()适合执行已有的命令，execFile()适合执行文件。</p>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="使用exec-方法执行sudo命令"><a href="#使用exec-方法执行sudo命令" class="headerlink" title="使用exec()方法执行sudo命令"></a>使用exec()方法执行sudo命令</h3><p>由于sudo命令需要输入密码，所以执行sudo命令与执行普通命令有所区别，下面是两种比较简单的解决方法：</p>
<h5 id="方法一：-S选项"><a href="#方法一：-S选项" class="headerlink" title="方法一： -S选项"></a>方法一： -S选项</h5><p>sudo命令有个-S选项，用于在需要输入密码的时候，读取密码。</p>
<p>假设密码为password，且假设要使用sudo命令执行脚本文件 tee_to_monitor.sh ，并向其传递参数 status ，那么，完整命令如下</p>
<p><code>echo &quot;password&quot; | sudo -S ./tee_to_monitor.sh status</code></p>
<p>相应的，node代码可以这样</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;echo &quot;zjl&quot; | sudo -S ./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>该方法比较简单，只需要使用<code>sudo npm start</code>启动应用即可，假设同样是上面的例子，此时node代码如下：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><p>也就是说，如果使用sudo命令启动应用，则该应用中就不需要再用sudo了。</p>
<h3 id="使用exec-方法实时获取输出"><a href="#使用exec-方法实时获取输出" class="headerlink" title="使用exec()方法实时获取输出"></a>使用exec()方法实时获取输出</h3><p>如果按照前面例子中的方法使用exec()，则子进程完成后回调函数才会被调用，如果想要实时获取输出，则可按照下面的例子使用exec()。</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
var child = shellProcess.exec(&apos;./start.sh&apos;);
// 捕获标准输出并使用socket通信传递数据
child.stdout.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 捕获标准错误输出并使用socket通信传递数据
child.stderr.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 注册子进程关闭事件
child.on(&apos;close&apos;,function(code){
  console.log(&apos;closing code: &apos;+code);
});
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的overflow属性和white-space属性]]></title>
      <url>https://fantasticzhang.github.io/2016/11/22/CSS%E7%9A%84overflow%E5%B1%9E%E6%80%A7%E5%92%8Cwhite-space%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>今天在写网页的时候用到了这两个属性，对于它们分别可能的取值及其含义一开始不是很确定，在查阅了网上的一些资料以及自己动手测试后，对它们每个可能取值的含义现已明确，因此记录下来方便之后查阅。</p>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p>overflow属性规定当内容溢出元素框时发生的事情。</p>
<h4 id="可能的取值"><a href="#可能的取值" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>visible：默认值。内容不会被修剪，会呈现在元素框之外。</li>
<li>hidden：内容会被修剪，并且其余内容是不可见的。</li>
<li>scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</li>
<li>auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</li>
<li>inherit：从父元素继承overflow属性的值。</li>
</ul>
<h4 id="scroll和auto的区别"><a href="#scroll和auto的区别" class="headerlink" title="scroll和auto的区别"></a>scroll和auto的区别</h4><ul>
<li>scroll：内容自动撑开容器的宽度不包括滚动条，相当于滚动条是一个和内容并列显示的组件。</li>
<li><p>auto：内容撑开容器的宽度包括滚动条。即 使用<code>white-space:nowrape;</code>撑开容器至正好显示所有内容时，如果有滚动条，则滚动条会覆盖在内容上方，导致内容宽度被再次缩小，然后出现省略号。由此推断渲染顺序：</p>
<p>  自适应宽度-&gt;根据高度显示滚动条-&gt;重新计算内部元素宽度。 </p>
</li>
</ul>
<p>综上，如果宽度是由内容自适应撑开的，则<code>overflow:auto;</code>带来的滚动条会占用内容的一部分宽度，导致内容显示不全。</p>
<h3 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h3><p>该属性声明建立布局过程中如何处理元素中的空白符。</p>
<h4 id="可能的取值-1"><a href="#可能的取值-1" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>normal：默认值。连续的空白符会被合并，换行符会被当做空白符来处理。填充line盒子时，必要的话会换行。</li>
<li>pre: 连续的空白符会被保留。在遇到换行符或者\<br\>元素时才会换行。</br\></li>
<li>nowrap: 连续的空白符会被合并，文本不会换行，会在同一行上继续，直到遇到\<br\>标签为止。</br\></li>
<li>pre-wrap：连续的空白符会被保留，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>pre-line：连续的空白符会被合并，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>inherit：从父元素继承white-space属性的值。</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="external">参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的定位技术]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>CSS使用top、left、right、bottom设置元素的二维（x轴和y轴）偏移量。使用z-index设置元素垂直于屏幕的方向，也就是“z轴”的偏移量。</p>
<p>CSS使用position选项来定义元素的定位属性，该选项有五个可选值：static、relative、absolute、fixed、inherit，默认值是static。inherit属性表示继承父元素的定位属性，因此只需掌握static、relative、absolute、fixed这四种定位属性的特性即可。</p>
<h3 id="相对定位技术"><a href="#相对定位技术" class="headerlink" title="相对定位技术"></a>相对定位技术</h3><p>相对定位即相对于文档流中的其他已定义的元素位置进行定位。relative和static都是相对于文档其他元素进行定位，都属于相对定位的范畴，区别在于一个可以控制位移，一个不能。</p>
<h4 id="static（默认值）"><a href="#static（默认值）" class="headerlink" title="static（默认值）"></a>static（默认值）</h4><p>如果使用默认值，在CSS中为元素定义top、left、right、 bottom、z-index都不会生效。也就是说，如果想设置元素的偏移量和z-index，必须为元素定义position属性（static除外）。</p>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p>relative的表现和默认值一样，只不过可以通过设置偏移量和z-index来控制相对于其正常位置进行的偏移。</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位的元素有以下几个特点：</p>
<ul>
<li>块级元素的宽度在未定义时不再为100%，而是根据内容自动调整。</li>
<li>在不定义z-index的情况下，absolute元素会覆盖在其他元素之上。</li>
<li>它会脱离正常的文档流，不再占据空间，类似于浮动后的效果。</li>
</ul>
<p>absolute和fixed都属于绝对定位的范畴，都遵循以上3个特点。</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p>absolute是相对上一个不为static的父元素进行绝对定位。也就是说，如果不指定父元素的position，absolute将相对于整个html文档进行绝对定位。</p>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>fixed是相对于浏览器窗口进行定位。也就是说，不论网页如何滚动，该元素始终停留在屏幕的某个位置上。例如：我们希望侧边控制栏始终对用户可见，就可以使用<code>position:fixed</code>来进行定位。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的优先级]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>如何确定CSS的优先级？首先要引入一个机制，分别用4个数字（a, b, c, d）表示优先级组合，它们的意思分别是：    </p>
<ul>
<li>第一个数字（a）表示style属性，优先级最高。由于一般都是class样式，所以该值一般都是0。  </li>
<li>第二个数字（b）是该CSS选择器上的id数量的总和，一般都是1个。</li>
<li>第三个数字（c）是用在该CSS选择器上的其他属性CSS选择器以及伪类的总和。这里包括class（比如 .btn）和属性选择器（比如 li[id=red]）。</li>
<li>第四个数字（d）计算元素（比如 table、p、div等）和伪元素（比如 first-child）。</li>
</ul>
<p>注：</p>
<ul>
<li>通用CSS选择器（*）是0优先级。</li>
<li>如果两个CSS选择器有同样的优先级，则在样式表中后面的那个起作用。</li>
</ul>
<p>几个例子：</p>
<ul>
<li>选择器：<code>#menu h2</code>， 优先级：0,1,0,1。   </li>
<li>选择器： <code>#leftbar li:first-child</code>，优先级： 0,1,0,2。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[又长大一岁啦]]></title>
      <url>https://fantasticzhang.github.io/2016/11/14/%E5%8F%88%E9%95%BF%E5%A4%A7%E4%B8%80%E5%B2%81%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>今天我又长大一岁啦~一大早就收到了爸爸妈妈的祝福和红包，以及好朋友的祝福，真的好开心~因此，想要简单记录一下这开心的一天。但由于博主经验不足图片格式还不太会调，可能看起来不太美观，以后会改正。</p>
<h3 id="美好的一天"><a href="#美好的一天" class="headerlink" title="美好的一天"></a>美好的一天</h3><p><img src="/images/2016-11-14/1.jpg" alt=""></p>
<p>闺蜜送的生日礼物，真的好喜欢，每一年的生日都给我好大的惊喜，也希望之后的每个生日都有你的陪伴。</p>
<p><img src="/images/2016-11-14/2.jpg" alt=""></p>
<p>早晨来到实验室就收到了学弟送的书，真的好感动~而且特意为我选了悬疑推理类的书，很符合我的口味，嘿嘿。真的很开心今年能认识你啦~</p>
<p><img src="/images/2016-11-14/3.jpg" alt=""></p>
<p>有个姐姐就是好，带我来吃海底捞啦，哈哈。一直听说海底捞的服务特别好，今天算是见识到了，店员知道今天我过生日，特意为我唱了生日快乐歌，而且还送了我礼物，真的好棒！对了，还可以免费做美甲，所以吃完饭后就做了一个，好开心。</p>
<p><img src="/images/2016-11-14/4.jpg" alt=""></p>
<p>店员知道今天我过生日，特意为我做了长寿面~</p>
<p><img src="/images/2016-11-14/5.jpg" alt=""></p>
<p>店家送给我的生日礼物，服务真的好周到。</p>
<p><img src="/images/2016-11-14/6.jpg" alt=""></p>
<p>最后，许下一个生日愿望，希望能实现~</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>今天一路上还收到了好多陌生人的祝福，真的好开心。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>https://fantasticzhang.github.io/2016/11/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>终于有自己的博客啦~</p>
<p>其实一直想要建一个属于自己的博客，用来记录自己日常生活中的点点滴滴、学习过程中整理的笔记以及一些技术感悟，记录自己读过的一些论文等，但由于自己的拖延症，一直没有弄:-P。终于，今天我也有了属于自己的博客啦，也希望自己之后能克服懒惰，经常更新。日积月累，总会有收获的。</p>
]]></content>
    </entry>
    
  
  
</search>
