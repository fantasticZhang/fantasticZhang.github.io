<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[OpenVPN的安装及使用]]></title>
      <url>https://fantasticzhang.github.io/2017/03/13/OpenVPN%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h2><ul>
<li>开发语言：C/C++</li>
<li>操作系统：跨平台，支持Linux、Windows、MacOS X等</li>
<li><a href="https://github.com/OpenVPN/openvpn" target="_blank" rel="external">github</a></li>
</ul>
<h2 id="编译、运行、安装过程"><a href="#编译、运行、安装过程" class="headerlink" title="编译、运行、安装过程"></a>编译、运行、安装过程</h2><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p> 源码安装</p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><ol>
<li><p>安装c编译器及OpenVPN所需的插件</p>
<p>gcc、g++、openssl、pam、lzo</p>
<p>安装命令为：</p>
<ul>
<li>sudo apt-get install gcc</li>
<li>sudo apt-get install g++</li>
<li>sudo apt-get install openssl</li>
<li>sudo apt-get install libssl-dev</li>
<li>sudo apt-get install libpam0g-dev  </li>
<li>sudo apt-get install liblzo2-dev  </li>
</ul>
</li>
<li><p>从<a href="https://openvpn.net/index.php/download/community-downloads.html" target="_blank" rel="external">官网</a>下载源码</p>
</li>
<li><p>编译、安装</p>
<ul>
<li>tar -zxf openvpn-2.3.14.tar.gz</li>
<li>cd openvpn-openvpn-2.3.14</li>
<li>./configure</li>
<li>make</li>
<li>make install</li>
</ul>
</li>
</ol>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ol>
<li><p>搭建CA，并为OpenVPN server端和client端产生证书和密钥</p>
<p>使用<a href="https://github.com/OpenVPN/easy-rsa" target="_blank" rel="external">easy-rsa</a>来搭建CA。命令如下：</p>
<ul>
<li>CA：<ul>
<li>./easyrsa init-pki</li>
<li>./easyrsa build-ca</li>
</ul>
</li>
<li>server:<ul>
<li>./easyrsa gen-req server</li>
<li>./easyrsa sign-req server server</li>
</ul>
</li>
<li>client:<ul>
<li>./easyrsa gen-req client1</li>
<li>./easyrsa sign-req client client1</li>
</ul>
</li>
<li>DH params:<ul>
<li>./easyrsa gen-dh</li>
</ul>
</li>
</ul>
</li>
<li><p>OpenVPN server端配置</p>
<p>在上一步中产生了所需要的文件，其中server端需要用到的有ca.crt、ca.key、dh.pem、server.crt、server.key</p>
<p>在OpenVPN server端建立config文件夹，将以上文件拷贝到该文件夹下，此外 server端还需要配置文件server.conf，OpenVPN已经在安装包的sample/sample-config-files子目录中为我们提供了相关的示例文件server.conf，并且配置文件中的每个配置选项均有详细的英文说明。将server.conf文件拷贝到config目录中，然后再对其进行修改。</p>
<p>server.conf文件中指定了监听的本机IP、端口号、CA证书的文件路径、server端的证书文件路径及私钥文件路径等，我们只需按照实际情况进行修改。</p>
<p>OpenVPN自身的配置到此结束，但在使用前还必须开启Linux系统的路由转发功能：</p>
<ul>
<li>vi /etc/sysctl.conf</li>
</ul>
<p>找到 “#net.ipv4.ip_forward=1” 这一行，删除那个 “#” 号，然后保存退出。接下来使转发生效：</p>
<ul>
<li>sysctl -p  </li>
</ul>
<p>如果一切正常，你将只会看到以下结果：</p>
<ul>
<li>net.ipv4.ip_forward=1</li>
</ul>
<p>然后设置iptables规则，通过配置NAT将VPN网段IP转发到eth0网卡：</p>
<ul>
<li>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j SNAT –to 10.108.112.6 （适用于固定IP的VPS）  </li>
</ul>
<p>或者:</p>
<ul>
<li>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE （通用方法，自动获取eth0网卡的IP地址）  </li>
</ul>
<p>设置OpenVPN端口通过：</p>
<ul>
<li>iptables -A INPUT -p TCP –dport 1194 -j ACCEPT  </li>
<li>iptables -A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT  </li>
</ul>
<p>最后，在服务端启动OpenVPN：</p>
<ul>
<li>openvpn 配置文件（server.conf）路径</li>
</ul>
</li>
<li><p>OpenVPN client端配置</p>
<p>client端可以有多个，在本次实验中只有一个client端：client1。客户端client1需要用到的文件有：ca.crt、client1.crt、client1.key。</p>
<p>在OpenVPN client端建立config文件夹，将以上文件拷贝到该文件夹下，此外 client端还需要配置文件client.conf，OpenVPN已经在安装包的sample/sample-config-files子目录中为我们提供了相关的示例文件client.conf，并且配置文件中的每个配置选项均有详细的英文说明。将client.conf文件拷贝到config目录中，然后再对其进行修改。</p>
<p>client.conf文件中指定了连接的远程服务器的实际IP地址和端口号、CA证书的文件路径、当前客户端的证书文件路径和私钥文件路径等，我们只需按照实际情况进行修改。</p>
<p>在客户端启动OpenVPN：</p>
<ul>
<li>openvpn 配置文件（client.conf）路径</li>
</ul>
<p>接下来，在client端ping服务端的虚拟地址：</p>
<ul>
<li>ping 10.8.0.1</li>
</ul>
<p>如果能ping通，则说明客户端已经和OpenVPN服务端连接成功。</p>
</li>
</ol>
<h3 id="证书导入接口"><a href="#证书导入接口" class="headerlink" title="证书导入接口"></a>证书导入接口</h3><p>  由上一节的实际操作过程可知，server端的证书导入接口在配置文件 server.conf 中；client端的证书导入接口在配置文件 client.conf 中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实例demo之FidoBowling小游戏]]></title>
      <url>https://fantasticzhang.github.io/2017/03/12/%E5%AE%9E%E4%BE%8Bdemo%E4%B9%8BFidoBowling%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<link type="text/css" href="/css/FidoBowling.css" rel="stylesheet">

<div id="info">
    <h2>Fido Bowling</h2>
    <p>基于Canvas开发的一个小游戏——太空保龄球。</p>

    <h2>游戏规则</h2>
    <p>太空保龄球游戏在窗口的上部包含一个圆形平台，一群静止的小行星分布在圆形平台上，另一个稍大些的小行星放在离圆形平台较远的位置，作为玩家投掷时使用的圆球。</p>
    <ul>
      <li>用鼠标向下拖动玩家小行星将其弹向圆形平台，使其尽可能多地撞开位于圆形平台上的小行星。</li>
      <li>当圆形平台上所有的小行星都被撞离平台时，你就获胜了！</li>
      <li>游戏的分数是根据你撞开所有小行星所用的撞击次数来计算的。好了，开始游戏吧！</li>
    </ul>
</div>

<div id="game">
    <div id="gameUI">
        <div id="gameIntro">
            <h1>太空保龄球</h1>
            <p>一个很有趣的小游戏</p>
            <p><a id="gamePlay" class="button" href="">开始游戏</a></p>
        </div>
        <div id="gameStats">
            <p>小行星数量：<span id="gameRemaining"></span></p>
            <p>撞击次数：<span class="gameScore"></span></p>
            <p><a class="gameReset" href="">重置</a></p>
        </div>
        <div id="gameComplete">
            <h1>你赢了！</h1>
            <p>恭喜你，你撞击了<span class="gameScore"></span>次就完成了游戏。</p>
            <p><a class="gameReset button" href="">再玩一次</a></p>
        </div>
    </div>
    <canvas id="gameCanvas" width="350" height="600">
        <!--游戏界面-->
    </canvas>
</div>

<script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="/js/FidoBowling.js"></script>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[坐标旋转公式]]></title>
      <url>https://fantasticzhang.github.io/2017/03/10/%E5%9D%90%E6%A0%87%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>该公式用于计算某个点绕另外一个点旋转一定角度后的坐标，推到过程如下。</p>
<p><img src="/images/2017-03-10/坐标旋转示意图.jpg" alt=""></p>
<p>A<code>(x，y)</code>绕B<code>(a，b)</code>旋转<code>β</code>度后的位置为C<code>(c，d)</code>，则<code>x</code>，<code>y</code>，<code>a</code>，<code>b</code>，<code>β</code>，<code>c</code>，d有如下关系式：</p>
<ul>
<li><p>设A点旋转前的角度为<code>δ</code>，则旋转(逆时针)到C点后角度为<code>δ+β</code></p>
</li>
<li><p>求A，B两点的距离：<code>dist1=|AB|=y/sin(δ)=x/cos(δ)</code></p>
</li>
<li><p>求C，B两点的距离：<code>dist2=|CB|=d/sin(δ+β)=c/cos(δ+β)</code></p>
</li>
<li><p>显然dist1=dist2，设dist1=r所以：</p>
</li>
</ul>
<p>　　<code>r=x/cos(δ)=y/sin(δ)=d/sin(δ+β)=c/cos(δ+β)</code></p>
<ul>
<li><p>由三角函数两角和差公式知：</p>
<pre><code>sin(δ+β)=sin(δ)cos(β)+cos(δ)sin(β)
cos(δ+β)=cos(δ)cos(β)-sin(δ)sin(β)
</code></pre><p>  所以得出：</p>
<pre><code>c=r*cos(δ+β)=r*cos(δ)cos(β)-r*sin(δ)sin(β)=xcos(β)-ysin(β)
d=r*sin(δ+β)=r*sin(δ)cos(β)+r*cos(δ)sin(β)=ycos(β)+xsin(β)
</code></pre></li>
</ul>
<p>即旋转后的坐标<code>(c,d)</code>只与旋转前的坐标<code>(x,y)</code>及旋转的角度β有关</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实例demo之Canvas小动画]]></title>
      <url>https://fantasticzhang.github.io/2017/03/10/%E5%AE%9E%E4%BE%8Bdemo%E4%B9%8BCanvas%E5%B0%8F%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>使用Canvas实现的一个动画效果：一个简单的太空场景，在太空深处有一个动态的小行星群，这里每个小行星的颜色是随机的。点击<code>Start</code>按钮，行星开始运动，点击<code>Stop</code>按钮，行星将会静止。</p>
<link type="text/css" href="/css/asteroids.css" rel="stylesheet">

<canvas id="myCanvas" height="500" width="850">

<p></p></canvas><p></p>
<div id="myButtons"><br>    <button id="start">Start</button><br>    <button id="stop">Stop</button><br></div>

<script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="/js/asteroids.js"></script>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Canvas学习（三）]]></title>
      <url>https://fantasticzhang.github.io/2017/03/09/Canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>接下来是Canvas学习的最后部分——动画。</p>
<h2 id="动画循环"><a href="#动画循环" class="headerlink" title="动画循环"></a>动画循环</h2><p>动画循环是创建动画效果的基础，动画循环的三要素：更新需要绘制的对象（如移动对象的位置）、清除画布、在画布上重新绘制对象。如下图所示：</p>
<p><img src="/images/2017-03-09/画布中的典型循环.PNG" alt=""></p>
<h3 id="创建循环"><a href="#创建循环" class="headerlink" title="创建循环"></a>创建循环</h3><p>下面是一段简单的循环代码：</p>
<pre><code>//HTML
&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:1px solid #000000; display: block; &quot;&gt;

&lt;/canvas&gt;
&lt;button id=&quot;start&quot;&gt;Start&lt;/button&gt;
&lt;button id=&quot;stop&quot;&gt;Stop&lt;/button&gt;

//js
var canvas = $(&quot;#myCanvas&quot;);
var cxt = canvas.get(0).getContext(&quot;2d&quot;);
var canvasWidth = canvas.width();
var canvasHeight = canvas.height();

var startButton = $(&quot;#start&quot;);
var stopButton = $(&quot;#stop&quot;);
var ifPlay = true;

startButton.hide();
startButton.click(function(){
    $(this).hide();
    stopButton.show();
    ifPlay = true;
    animate();
});
stopButton.click(function(){
    $(this).hide();
    startButton.show();
    ifPlay = false;
});

function animate(){

    if(ifPlay){
        setTimeout(animate,33);
    }
}
animate();
</code></pre><p>以上代码中最重要的是<code>animate</code>函数，该函数使用<code>setTimeout</code>方法设置了一个定时器，每隔33毫秒调用一次<code>animate</code>函数，这样就创建了一个无限循环，可用来实现动画效果。<code>Start</code>、<code>Stop</code>按钮用来控制动画的启动和停止。</p>
<p>使用33毫秒作为动画循环时间间隔的原因：动画在每秒钟需要的帧数通常介于25到30帧之间，1秒=1000毫秒，1000除以30得33毫秒。</p>
<p>现在我们已经建立了基本的动画循环，接下来就需要在动画循环里添加三要素，即更新、清除和绘制过程了。</p>
<h3 id="更新、清除、绘制"><a href="#更新、清除、绘制" class="headerlink" title="更新、清除、绘制"></a>更新、清除、绘制</h3><p>下面是一个简单的动画，使一个正方形每帧右移1像素。</p>
<pre><code>var x = 0;
function animate(){

   x++;                                              //更新
   cxt.clearRect(0,0,canvasWidth,canvasHeight);     //清除
   cxt.fillRect(x,250,20,20);                      //绘制

   if(ifPlay){
       setTimeout(animate,33);
   }
}
animate();
</code></pre><p>效果如下：</p>
<p><img src="/images/2017-03-09/简单动画.PNG" alt=""></p>
<h2 id="记忆要绘制的形状"><a href="#记忆要绘制的形状" class="headerlink" title="记忆要绘制的形状"></a>记忆要绘制的形状</h2><p>动画循环三要素中，清除和绘制都很简单，难点在更新，即：如何准确记忆要绘制的对象的内容及位置。</p>
<p>如果动画中的形状很少可以使用上一小节中的方法——简单变量来记忆，<br>但通常的动画中形状非常多，此时这种方法就非常笨拙了——需要复制大量代码，修改起来也非常复杂。其实需要解决的问题有两个：第一，不管形状的数量有多少，首先考虑如何存储每个形状的位置值；第二，在不复制代码的情况下如何绘制每个形状。针对这两个问题，可以考虑用对象和数组来实现。首先可以将每个形状视为一个对象，对象的属性即保存了形状的位置<code>(x,y)</code>、内容等信息；之后用数组来存储对象，就可通过循环来绘制每个形状。</p>
<p>示例代码：</p>
<pre><code>//用对象来定义形状
var Shape = function (x,y,width,height) {
   this.x = x;
   this.y = y;
   this.width = width;
   this.height = height;
};
//用数组保存要绘制的所有形状
var shapes = new Array();
for(var i=0;i&lt;10;i++){
   var x = Math.random()*250;
   var y = Math.random()*250;
   var width = height = Math.random()*50;
   shapes.push(new Shape(x,y,width,height));
}

function animate(){
   cxt.clearRect(0,0,canvasWidth,canvasHeight);  //清除
   //循环每个形状
   var shapesLength = shapes.length;
   for (var i = 0; i &lt; shapesLength; i++) {
       var tmpShape = shapes[i];
       tmpShape.x++;   //更新
       cxt.fillRect(tmpShape.x, tmpShape.y, tmpShape.width, tmpShape.height);  //绘制
   };
   if(ifPlay){
       setTimeout(animate,33);
   }
}
animate();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-09/保存形状.PNG" alt=""></p>
<h2 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h2><p>有时候需要实现沿着圆周运动的动画效果，例如，沿着圆形轨道运行，如下图所示。</p>
<p><img src="/images/2017-03-09/圆形轨道运行.PNG" alt=""></p>
<p>其实原理很简单：将一个形状放在圆周的边缘处（即周长上），以圆周的任意位置作为起点，在每次动画循环中，只需增加位于圆周上的形状的角度，就可以使形状沿着圆周运动。为简单起见，假设形状的起点位置总是周长上角度为0弧度的位置。我们可以使用三角函数来解决该问题，示意图如下：</p>
<p><img src="/images/2017-03-09/三角函数.PNG" alt=""></p>
<p>假设圆点坐标为<code>(0,0)</code>，圆的半径为<code>r</code>，形状相对起点位置移动的角度为<code>a</code>。则，根据三角函数:<code>x=r*Math.cos(a)</code>，<code>y=r*Math.sin(a)</code>。这里的<code>a</code>是角度值，由于JavaScript中使用的单位是弧度，因此在实际计算时还需要进行转换。</p>
<p>综上，如果想要对一个形状实现圆周运动，就需要保存圆的半径<code>r</code>、形状当前运动位置的角度值。又圆周运动的圆的坐标不一定是<code>(0,0)</code>，因此还需要保存圆点坐标<code>(x,y)</code>。用对象描述如下：</p>
<pre><code>var Shape = function (x,y,width,height) {
   this.x = x;
   this.y = y;
   this.width = width;
   this.height = height;

   this.radius = Math.random()*30;
   this.angle = 0;
};
</code></pre><p>其中，<code>(x,y)</code>表示的是形状做圆周运动时圆心的坐标，而不是形状的当前位置；<code>radius</code>表示半径；<code>angle</code>表示形状当前的角度值。</p>
<p>代码：</p>
<pre><code>//用对象来定义形状
var Shape = function (x,y,width,height) {
   this.x = x;
   this.y = y;
   this.width = width;
   this.height = height;

   this.radius = Math.random()*30;
   this.angle = 0;
};
//用数组保存要绘制的所有形状
var shapes = new Array();
for(var i=0;i&lt;10;i++){
   var x = Math.random()*250;
   var y = Math.random()*250;
   var width = height = Math.random()*50;
   shapes.push(new Shape(x,y,width,height));
}

function animate(){
   cxt.clearRect(0,0,canvasWidth,canvasHeight);  //清除
   //循环每个形状
   var shapesLength = shapes.length;
   for (var i = 0; i &lt; shapesLength; i++) {
       var tmpShape = shapes[i];
       //更新
       var x = tmpShape.x+(tmpShape.radius*Math.cos(tmpShape.angle*(Math.PI/180)));
       var y = tmpShape.y+(tmpShape.radius*Math.sin(tmpShape.angle*(Math.PI/180)));
       tmpShape.angle += 5;
       cxt.fillRect(x, y, tmpShape.width, tmpShape.height);  //绘制
   };
   if(ifPlay){
       setTimeout(animate,33);
   }
}
animate();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-09/圆周运动.PNG" alt=""></p>
<h2 id="反弹"><a href="#反弹" class="headerlink" title="反弹"></a>反弹</h2><p>在之前的实现中，都没有考虑画布边界的问题，因此如果形状位置超出了画布边界，就会消失在视野中。我们理想的情景是：当形状位置达到边界时，会反弹回来，即向反方向运动，这样形状就会在画布中来回运动了。实现起来也很简单，只需在每次更新形状时检查形状是否超过了画布的边界，如果已经到达边界处，则反向改变形状运动的方向，这样它就会反弹回来。</p>
<p>代码：</p>
<pre><code>//反弹
var Shape = function (x,y,width,height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.reverseX = true;
    this.reverseY = false;
};
//用数组保存要绘制的所有形状
var shapes = new Array();
for(var i=0;i&lt;10;i++){
    var x = Math.random()*250;
    var y = Math.random()*250;
    var width = height = Math.random()*50;
    shapes.push(new Shape(x,y,width,height));
}

function animate(){
    cxt.clearRect(0,0,canvasWidth,canvasHeight);
    //循环每个形状
    var shapesLength = shapes.length;
    for (var i = 0; i &lt; shapesLength; i++) {
        var tmpShape = shapes[i];
        //更新
        //检查
        if(!tmpShape.reverseX){
            tmpShape.x += 2;
        }else{
            tmpShape.x -= 2;
        }
        if(!tmpShape.reverseY){
            tmpShape.y += 2;
        }else{
            tmpShape.y -= 2;
        }
        cxt.fillRect(tmpShape.x, tmpShape.y, tmpShape.width, tmpShape.height);  //绘制
        //检查是否超出边界
        if(tmpShape.x&lt;0){
            tmpShape.reverseX = false;
        }else if(tmpShape.x+tmpShape.width&gt;canvasWidth){
            tmpShape.reverseX = true;
        }
        if(tmpShape.y&lt;0){
            tmpShape.reverseY = false;
        }else if(tmpShape.y+tmpShape.height&gt;canvasWidth){
            tmpShape.reverseY = true;
        }
    };
    if(ifPlay){
        setTimeout(animate,33);
    }
}
animate();
</code></pre><p>对象中增加了两个属性<code>reverseX</code>、<code>reverseY</code>分别用来表示是否需要反弹，<code>true</code>表示需要，则在更新形状时让其向反方向运动；<code>false</code>表示不需要，则在更新形状时正方向运动即可。在每次绘制完后，还需要根据当前形状的位置来检查是否到达画布的边界，并更新<code>reverseX</code>、<code>reverseY</code>的值。这样就实现了一个简单的反弹动画效果。</p>
<h2 id="实现高级动画"><a href="#实现高级动画" class="headerlink" title="实现高级动画"></a>实现高级动画</h2><p>我们可以通过物理知识把动画效果进一步提高，创建更加逼真和具有动态效果的动画。无论是使用速度、加速度这些简单概念，还是构建一个包含不同方向作用力的完善系统，通过学习物理学，我们才能真实而全面地展现动画效果。下面先介绍一些基本的物理概念。</p>
<ul>
<li>力： 力是作用于物体的推力或拉力，它是改变物体运动状态的原因。力是矢量，单位是牛顿（N）。</li>
<li>矢量：矢量是具有大小和方向的量。</li>
<li>质量：质量是一种阻碍物体在力的作用下加速的物理量，也用来衡量惯性。当力作用于物体时，质量将直接影响加速度的大小。质量的单位是千克。</li>
<li>重力：物体的质量受另一个物体引力的作用而产生的力称为重力。重力是物体存在重量的原因。</li>
<li>摩擦力：摩擦力是一种阻止一个物体沿着另一个物体表面运动的力。</li>
<li>速度：速度是指物体运动的方向和速率。它是一个矢量。</li>
<li>速率：指物体运动速度的大小，表示物体在一段时间内通过的距离。标量。</li>
<li>加速度：加速度是指物体的速度随时间变化的比值，矢量。</li>
</ul>
<p>当我们创建自然流畅的动画时，了解力对物体运动状态的影响非常有用，因此还需要了解一下牛顿运动定律。</p>
<ul>
<li>牛顿第一定律：任何一个物体在不受外力或受平衡力的作用时，总是保持静止状态或匀速直线运动状态，直到有作用在它上面的外力迫使它改变这种状态为止。</li>
<li>牛顿第二定律：物体的加速度跟物体所受的合外力成正比，跟物体的质量成反比，加速度的方向跟合外力的方向相同。<code>F=ma</code></li>
<li>牛顿第三定律：两个物体之间的作用力和反作用力，在同一直线上，大小相等，方向相反。</li>
</ul>
<p>以上就是一些基本的物理知识，下面将利用这些物理知识实现一个简单的动画效果：一个简单的太空场景，在太空深处有一个动态的小行星群，这里每个小行星的颜色是随机的。点击<code>Start</code>按钮，行星开始运动，点击<code>Stop</code>按钮，行星将会静止。</p>
<p>demo地址：<a href="/2017/03/10/实例demo之Canvas小动画/" title="实例demo之Canvas小动画">实例demo之Canvas小动画</a></p>
<p>关键代码：</p>
<pre><code>//定义形状
var Asteroid = function(x, y,radius,mass,vX,vY,aX,aY,red,green,blue){
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.mass = mass;

    this.vX = vX;
    this.vY = vY;
    this.aX = aX;
    this.aY = aY;

    //每个小球都有自己的颜色
    this.red = red;
    this.green = green;
    this.blue = blue;
};

//保存所有形状
var asteroids = new Array();
for(var i = 0;i&lt;20;i++){
    //圆点坐标
   var x = 20+(Math.random()*(canvasWidth-40));
   var y = 20+(Math.random()*(canvasHeight-40));
    var radius = 5+Math.random()*10; //半径
    var mass = radius/2;   //质量
   //速度
    var vX = Math.random()*4-2;
    var vY = Math.random()*4-2;
    var aX = 0;
    var aY = 0;
    //颜色
    var red = Math.floor(Math.random()*255);
    var green = Math.floor(Math.random()*255);
    var blue = Math.floor(Math.random()*255);
    asteroids.push(new Asteroid(x,y,radius,mass,vX,vY,aX,aY,red,green,blue));
}

function animate(){
    //清除
    cxt.clearRect(0,0,canvasWidth,canvasHeight);
    var red = Math.floor(Math.random()*255);
    //cxt.fillStyle = &quot;rgb(255,255,255)&quot;;
    //更新
    var asteroidsLength = asteroids.length;
    for(var i = 0; i &lt; asteroidsLength; i++){
        var tmpAsteroid = asteroids[i];
        cxt.fillStyle = &quot;rgb(&quot;+tmpAsteroid.red+&quot;,&quot;+tmpAsteroid.green+&quot;,&quot;+tmpAsteroid.blue+&quot;)&quot;;
       //检测是否和其他形状碰撞
        for(var j = i+1; j &lt; asteroidsLength; j++){
            var tmpAsteroidB = asteroids[j];
            var dX = tmpAsteroidB.x - tmpAsteroid.x;
            var dY = tmpAsteroidB.y - tmpAsteroid.y;
            var distance = Math.sqrt((dX*dX)+(dY*dY));
            if(distance &lt; tmpAsteroid.radius + tmpAsteroidB.radius){
                //将小球的碰撞转换为理想碰撞，并利用坐标旋转公式计算转换后的坐标和速度
                var angle = Math.atan2(dY, dX);    //旋转角度
                var sine = Math.sin(angle);
                var cosine = Math.cos(angle);
                var x = 0;
                var y = 0;
                var vX = tmpAsteroid.vX * cosine + tmpAsteroid.vY * sine;
                var vY = tmpAsteroid.vY * cosine - tmpAsteroid.vX * sine;

                var xB = dX * cosine + dY * sine;
                var yB = dY * cosine - dX * sine;
                var vXb = tmpAsteroidB.vX * cosine + tmpAsteroidB.vY * sine;
                var vYb = tmpAsteroidB.vY * cosine - tmpAsteroidB.vX * sine;

                //理想碰撞后改变速度和坐标
                //vX *= -1;
                //vXb *= -1;
                //能量守恒和动量守恒定律求解碰撞后的速度
                var vTotal = vX - vXb;
                vX = ((tmpAsteroid.mass - tmpAsteroidB.mass) * vX + 2 * tmpAsteroidB.mass * vXb) / (tmpAsteroid.mass + tmpAsteroidB.mass);
                vXb = vTotal + vX;
                xB = x + (tmpAsteroid.radius + tmpAsteroidB.radius);

                //在旋转回之前的位置
                tmpAsteroid.x = tmpAsteroid.x + (x * cosine - y * sine);
                tmpAsteroid.y = tmpAsteroid.y + (y * cosine + x * sine);
                tmpAsteroid.vX = vX * cosine - vY * sine;
                tmpAsteroid.vY = vY * cosine + vX * sine;

                tmpAsteroidB.x = tmpAsteroid.x + (xB * cosine - yB * sine);
                tmpAsteroidB.y = tmpAsteroid.y + (yB * cosine + xB * sine);
                tmpAsteroidB.vX = vXb * cosine - vYb * sine;
                tmpAsteroidB.vY = vYb * cosine + vXb * sine;
            }
        }
        //更新位置
        tmpAsteroid.x += tmpAsteroid.vX;
        tmpAsteroid.y += tmpAsteroid.vY;
        //根据加速度更新速度
        if (Math.abs(tmpAsteroid.vX) &lt; 10) {
          tmpAsteroid.vX += tmpAsteroid.aX;
        }
        if (Math.abs(tmpAsteroid.vY) &lt; 10) {
          tmpAsteroid.vY += tmpAsteroid.aY;
        }

        //检查是否到边界
       if (tmpAsteroid.x-tmpAsteroid.radius &lt; 0) {
          tmpAsteroid.x = tmpAsteroid.radius; // Move away from the edge
          tmpAsteroid.vX *= -1;
          tmpAsteroid.aX *= -1;
      } else if (tmpAsteroid.x+tmpAsteroid.radius &gt; canvasWidth) {
        tmpAsteroid.x = canvasWidth-tmpAsteroid.radius; // Move away from the edge
        tmpAsteroid.vX *= -1;
        tmpAsteroid.aX *= -1;
      };

      if (tmpAsteroid.y-tmpAsteroid.radius &lt; 0) {
        tmpAsteroid.y = tmpAsteroid.radius; // Move away from the edge
        tmpAsteroid.vY *= -1;
        tmpAsteroid.aY *= -1;
      } else if (tmpAsteroid.y+tmpAsteroid.radius &gt; canvasHeight) {
        tmpAsteroid.y = canvasHeight-tmpAsteroid.radius; // Move away from the edge
        tmpAsteroid.vY *= -1;
        tmpAsteroid.aY *= -1;
      };
        //绘制
        cxt.beginPath();
        cxt.arc(tmpAsteroid.x, tmpAsteroid.y, tmpAsteroid.radius, 0, Math.PI*2);
        cxt.closePath();
        cxt.fill();
    }

    if(ifPlay){
        setTimeout(animate,33);
    }
}
animate();
</code></pre><p><code>Asteroid</code>对象有11个属性：<code>(x,y)</code>是小行星的位置，<code>radius</code>是半径，<code>mass</code>是质量，<code>(vX,vY)</code>是速度，<code>(aX,aY)</code>是加速度，<code>(red,green,blue)</code>是颜色。在创建一个小行星时，这些参数的值是随机的，因此每个小行星都在不同的位置，有不同的大小、颜色、质量和速度。</p>
<p>其实该动画效果的难点在于小行星之间的碰撞检测。碰撞检测的两个关键步骤：第一，计算两颗小行星是否发生重叠；第二，在发生重叠时（即碰撞）以什么方式相互分离才显得更加逼真。检测重叠的方法很简单：检查两个圆心之间的距离是否小于这两个圆的半径之和。因此，难点在于怎样分离，即怎样弹开物体。</p>
<p>理想碰撞：两个圆发生碰撞时正好完全位于一条直线上，并且它们的中心点之间没有任何角度，此时只要反向改变速度的方向即可。如下图所示：</p>
<p><img src="/images/2017-03-10/正面碰撞.PNG" alt=""></p>
<p>但通常情况下，两个圆都会以一定角度发生碰撞，此时仅仅反向改变速度是行不通的，两个圆应该以正确的角度互相弹开。如下图所示：</p>
<p><img src="/images/2017-03-10/实际碰撞.PNG" alt=""></p>
<p>此时需要计算出两个圆之间的角度，并依次把每个圆的速度进行旋转，这样它们发生的碰撞就类似与上面提到的理想碰撞了，速度的状态转变如下图所示，这样圆的碰撞问题就转化成了一种简单的反向改变速度的问题。</p>
<p><img src="/images/2017-03-10/两圆角度.PNG" alt=""><br><img src="/images/2017-03-10/旋转两个圆.PNG" alt=""></p>
<p>对应的代码如下：</p>
<pre><code>var angle = Math.atan2(dY, dX);    //旋转角度
var sine = Math.sin(angle);
var cosine = Math.cos(angle);
var x = 0;
var y = 0;
var vX = tmpAsteroid.vX * cosine + tmpAsteroid.vY * sine;
var vY = tmpAsteroid.vY * cosine - tmpAsteroid.vX * sine;

var xB = dX * cosine + dY * sine;
var yB = dY * cosine - dX * sine;
var vXb = tmpAsteroidB.vX * cosine + tmpAsteroidB.vY * sine;
var vYb = tmpAsteroidB.vY * cosine - tmpAsteroidB.vX * sine;
</code></pre><p>这里用到了<a href="/2017/03/10/坐标旋转公式/" title="坐标旋转公式">坐标旋转公式</a></p>
<p>假设两个小行星发生的是完全弹性碰撞，则根据动量守恒和能量守恒公式可推导出碰撞后第一颗小行星的新速度为:</p>
<pre><code>vX = ((tmpAsteroid.mass - tmpAsteroidB.mass) * vX + 2 * tmpAsteroidB.mass * vXb) / (tmpAsteroid.mass + tmpAsteroidB.mass);
</code></pre><p>推到过程如下图所示：</p>
<p><img src="/images/2017-03-10/公式推导.PNG" alt=""></p>
<p>这样，碰撞后的速度和位置改变为：</p>
<pre><code>//能量守恒和动量守恒定律求解碰撞后的速度
var vTotal = vX - vXb;
vX = ((tmpAsteroid.mass - tmpAsteroidB.mass) * vX + 2 * tmpAsteroidB.mass * vXb) / (tmpAsteroid.mass + tmpAsteroidB.mass);
vXb = vTotal + vX;
xB = x + (tmpAsteroid.radius + tmpAsteroidB.radius);
</code></pre><p>最后需要把这些小行星旋转到它们原来所在的位置，并使用新的速度。代码与上面旋转小行星的代码基本相反：</p>
<pre><code>//在旋转回之前的位置
tmpAsteroid.x = tmpAsteroid.x + (x * cosine - y * sine);
tmpAsteroid.y = tmpAsteroid.y + (y * cosine + x * sine);
tmpAsteroid.vX = vX * cosine - vY * sine;
tmpAsteroid.vY = vY * cosine + vX * sine;

tmpAsteroidB.x = tmpAsteroid.x + (xB * cosine - yB * sine);
tmpAsteroidB.y = tmpAsteroid.y + (yB * cosine + xB * sine);
tmpAsteroidB.vX = vXb * cosine - vYb * sine;
tmpAsteroidB.vY = vYb * cosine + vXb * sine;
</code></pre><p>通过以上过程，解决了碰撞检测问题。这样，这个小动画就比较完美地实现了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Canvas学习（二）]]></title>
      <url>https://fantasticzhang.github.io/2017/03/08/Canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="处理图像"><a href="#处理图像" class="headerlink" title="处理图像"></a>处理图像</h2><h3 id="加载图像"><a href="#加载图像" class="headerlink" title="加载图像"></a>加载图像</h3><p><code>drawImage(image,x,y)</code>。参数<code>image</code>可以是HTML<code>img</code>元素、HTML5<code>canvas</code>元素或HTML5<code>video</code>元素。例：</p>
<pre><code>var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
  cxt.drawImage(img,0,0);
};
</code></pre><p>在使用以上方法图像到画布时，会将完整尺寸的图像绘制到画布上，但超过画布边界的部分会被裁减掉。</p>
<h3 id="调整和裁剪图像"><a href="#调整和裁剪图像" class="headerlink" title="调整和裁剪图像"></a>调整和裁剪图像</h3><p><code>drawImage</code>方法还有两种调用方式：第一种调用可以调整图像大小，第二种调用可以同时调整和裁剪图像。<code>drawImage</code>的所有调用方式的唯一区别是所使用参数的个数和类型不同。</p>
<h4 id="调整图像"><a href="#调整图像" class="headerlink" title="调整图像"></a>调整图像</h4><p><code>drawImage(image,x,y,width,height)</code>,其中<code>width</code>和<code>height</code>表示希望绘制的图像宽度和高度。我们可以根据画布的宽高来等比例计算图像的宽高。</p>
<h4 id="裁剪图像"><a href="#裁剪图像" class="headerlink" title="裁剪图像"></a>裁剪图像</h4><p><code>drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)</code>，共9个参数：源图像、源图像的裁剪区原点坐标<code>(x,y)</code>、源图像的裁剪区宽和高、在画布上绘制图像的原点坐标<code>(x,y)</code>、在画布上绘制图像的宽和高。示意图如下：</p>
<p><img src="/images/2017-03-08/裁剪图像.PNG" alt=""></p>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>代码：</p>
<pre><code>cxt.shadowBlur = 30;
cxt.shadowColor = &quot;rgb(0,0,0)&quot;;
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
     cxt.drawImage(img,100,100,375,500);
};
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/图像阴影.PNG" alt=""></p>
<h3 id="图像变形"><a href="#图像变形" class="headerlink" title="图像变形"></a>图像变形</h3><p>在画布中绘制图像后，就可以对它执行所有的2D渲染上下文方法。因此可以使用<code>translate</code>、<code>rotate</code>、<code>scale</code>等方法对图像进行旋转、平移、缩放与翻转等。注，如果<code>scale</code>方法使用负数缩放因子，就会使图像反转。</p>
<p>实例：</p>
<pre><code>cxt.shadowBlur = 30;
cxt.shadowColor = &quot;rgb(0,0,0)&quot;;
cxt.rotate(Math.PI/4);
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
    cxt.drawImage(img,100,100,375,500);
};
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/img-rotate.PNG" alt=""></p>
<h3 id="访问像素值"><a href="#访问像素值" class="headerlink" title="访问像素值"></a>访问像素值</h3><p><code>getImageData(x,y,width,height)</code>方法，该方法有4个参数：要访问的像素区域原点坐标<code>(x,y)</code>、像素区域的宽度和高度。调用该方法会返回一个2D渲染上下文<code>ImageData</code>对象，该对象包含3个属性：<code>width</code>表示所访问像素区域的宽度、<code>height</code>表示像素区域的高度、<code>data</code>是一个包含所访问区域中全部像素信息的<code>CanvasPixelArray</code>。</p>
<p><code>data</code>属性存储的是一个<code>CanvasPixelArray</code>，它是一个JavaScript一维数组。每一个像素用4个整数值表示，范围从0至255，分别表示红(r)、绿(g)、蓝(b)和阿尔法值(a)。因此，，数组的前4项（0~3）是第一个像素的颜色值，接下来4项(4~7)是第二个像素的颜色值，以此类推。因此，该数组的长度是所访问区域的像素个数乘以4。<code>CanvasPixelArray</code>中的像素排列顺序：左上角像素位于数组开头，右下角像素位于数组末尾。即在所访问的区域中，每一行像素时从左到右访问的，直至行尾，然后再同样从左到右访问下一行。</p>
<p>访问<code>(x,y)</code>坐标位置为<code>(2,2)</code>的中心像素：</p>
<pre><code>var imgData = cxt.getImageData(0, 0, 3, 3); // 3x3 grid
var width = imgData.width;
var pixelRed = (y-1)*(width*4)+((x-1)*4);
var pixelGreen = pixelRed+1;
var pixelBlue = pixelRed+2;
var pixelAlpha= pixelRed+3;
</code></pre><p>使用如上公式可准确地计算出你需要从<code>CanvasPixelArray</code>中访问的像素。</p>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>代码：</p>
<pre><code>var imageData = cxt.createImageData(width,height)(创建一个200,200);
var pixels = imageData.data;
var numPixels = imageData.width * imageData.height;
for(var i = 0; i&lt; numPixels; i++){
    pixels[i*4] = 0;   //红
    pixels[i*4+1] = 0; //绿
    pixels[i*4+2] = 255; //蓝
    pixels[i*4+3] = 255;//透明度
}
cxt.putImageData(imageData,0,0);
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/创建和绘制像素.PNG" alt=""></p>
<p>其中，<code>createImageData(width,height)</code>方法返回一个包含所有常规属性的<code>ImageData</code>对象；<code>putImageData</code>方法可将<code>ImageData</code>对象画到画布上，该方法可接受3个或7个参数：<code>ImageData</code>对象、绘制像素数据的原点坐标<code>(x,y)</code>、脏矩阵的原点坐标<code>(x,y)</code>、脏矩阵的宽和高。</p>
<h4 id="随机绘制像素"><a href="#随机绘制像素" class="headerlink" title="随机绘制像素"></a>随机绘制像素</h4><p>代码片段：</p>
<pre><code>pixels[i*4] = Math.floor(Math.random()*255);   //红
pixels[i*4+1] = Math.floor(Math.random()*255); ; //绿
pixels[i*4+2] = Math.floor(Math.random()*255); ; //蓝
pixels[i*4+3] = 255;//透明度
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/随机像素.PNG" alt=""></p>
<h4 id="创建马赛克效果"><a href="#创建马赛克效果" class="headerlink" title="创建马赛克效果"></a>创建马赛克效果</h4><p>原理：将像素区域分割到一个栅格中，并为栅格中的每个块儿（马赛克块）随机设置一种颜色。</p>
<p>代码：</p>
<pre><code>//马赛克
var imageData = cxt.createImageData(canvas.width(),canvas.height());
var pixels = imageData.data;
//马赛克块的个数
var numTileRows = 20;
var numTileCols = 20;
//每个块的尺寸
var tileWidth = imageData.width/numTileCols;
var tileHeight = imageData.height/numTileRows;
for(var r = 0; r&lt; numTileRows; r++){
    for(var c = 0;c&lt;numTileCols;c++){
        var red = Math.floor(Math.random()*255);   //红
        var green = Math.floor(Math.random()*255); //绿
        var blue = Math.floor(Math.random()*255);  //蓝
        for(var tr = 0;tr&lt;tileWidth;tr++){
            for(var tc = 0;tc&lt;tileHeight;tc++){
                var trueX = (c*tileWidth)+tc;
                var trueY = (r*tileHeight)+tr;
                var pos = (trueY*(imageData.width*4))+(trueX*4);
                pixels[pos] = red; //绿
                pixels[pos+1] = green; //绿
                pixels[pos+2] = blue; //蓝
                pixels[pos+3] = 255;//透明度
            }
        }
   }
}
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/马赛克.PNG" alt=""></p>
<h3 id="基本图像效果"><a href="#基本图像效果" class="headerlink" title="基本图像效果"></a>基本图像效果</h3><h4 id="反转图像"><a href="#反转图像" class="headerlink" title="反转图像"></a>反转图像</h4><p>即用255减去像素现在的颜色值。</p>
<p>代码：</p>
<pre><code>//反转颜色
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
   cxt.drawImage(img,0,0,1080,1440,0,0,canvas.width(),canvas.height());
   var imgData = cxt.getImageData(0,0,canvas.width(),canvas.height());
   var pixels = imgData.data;
   var numPixels = imgData.width * imgData.height;
   cxt.clearRect(0,0,canvas.width(),canvas.height());
   for(var i = 0; i&lt; numPixels; i++){
       pixels[i*4] = 255 - pixels[i*4];   //红
       pixels[i*4+1] = 255 - pixels[i*4+1]; //绿
       pixels[i*4+2] = 255 - pixels[i*4+2]; //蓝
   }
   cxt.putImageData(imgData,0,0);
};
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/反转颜色.PNG" alt=""></p>
<h4 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h4><p>方法：计算每个像素现有颜色值的平均值，并将该平均颜色作为相应像素三种颜色（红、绿和蓝）的值。</p>
<p>代码：</p>
<pre><code>for(var i = 0; i&lt; numPixels; i++){
    var avg = (pixels[i*4]+pixels[i*4+1]+pixels[i*4+2])/3;
    pixels[i*4] = avg;   //红
    pixels[i*4+1] = avg; //绿
    pixels[i*4+2] = avg; //蓝
}
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/灰度.PNG" alt=""></p>
<h4 id="像素化"><a href="#像素化" class="headerlink" title="像素化"></a>像素化</h4><p>和上面马赛克的励志类似，就是将图像按栅格分割，或者对每块儿的颜色取平均值，或者选取每块儿的颜色。</p>
<p>例：</p>
<pre><code>//像素
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
    cxt.drawImage(img,0,0,1080,1440,0,0,500,500);
    var imgData = cxt.getImageData(0,0,canvas.width(),canvas.height());
    var pixels = imgData.data;
    cxt.clearRect(0,0,canvas.width(),canvas.height());
    //马赛克块数
    var numTileRows = 50;
    var numTileCols = 50;
    //每个块的尺寸
    var tileWidth = imgData.width/numTileCols;
    var tileHeight = imgData.height/numTileRows;
    for(var r = 0; r&lt; numTileRows; r++){
        for(var c = 0;c&lt;numTileCols;c++){
            //每块中心点
            var x = (c*tileWidth)+(tileWidth/2);
            var y = (r*tileHeight)+(tileHeight/2);
            var pos = (Math.floor(y)*(imgData.width*4))+(Math.floor(x)*4);
            var red = pixels[pos];   //红
            var green = pixels[pos+1]; //绿
            var blue = pixels[pos+2];  //蓝
            cxt.fillStyle = &quot;rgb(&quot;+red+&quot;, &quot;+green+&quot;, &quot;+blue+&quot;)&quot;;
            cxt.fillRect(x-(tileWidth/2),y-(tileHeight/2),tileWidth,tileHeight);
        }

    }
    };
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/像素化.PNG" alt=""></p>
<p>圆形马赛克：</p>
<pre><code>cxt.beginPath();
cxt.arc(x,y,tileWidth/2,0,Math.PI*2,false);
cxt.closePath();
cxt.fill();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/像素化2.PNG" alt=""></p>
<h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><p><code>drawImage</code>方法可以接受一个HTML5<code>video</code>元素作为输入，在画布中的视频处理与图像处理几乎完全一样。</p>
<p>实例：</p>
<pre><code>//html代码
&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;281&quot;&gt;
    &lt;video id=&quot;myVideo&quot; src=&quot;Crooked.mp4&quot; controls  width=&quot;500&quot; height=&quot;281&quot;&gt;&lt;/video&gt;
&lt;/canvas&gt;
&lt;div&gt;
    &lt;button id=&quot;play&quot;&gt;Play&lt;/button&gt;
    &lt;button id=&quot;stop&quot;&gt;Stop&lt;/button&gt;
&lt;/div&gt;

//js代码：
var canvas = $(&quot;#myCanvas&quot;);
var cxt = canvas.get(0).getContext(&quot;2d&quot;);
var video = $(&quot;#myVideo&quot;);
// Trigger for video play button
$(&quot;#play&quot;).click(function() {
 video.get(0).play();
});

// Trigger for video stop button
$(&quot;#stop&quot;).click(function() {
 video.get(0).pause();
});

video.bind(&apos;play&apos;, function () {
 dravCanvas();
});

function  dravCanvas(){
  if(video.get(0).paused || video.get(0).ended) return;
  cxt.drawImage(video.get(0),0,0,500,281);
  var imgData = cxt.getImageData(0,0,canvas.width(),canvas.height());
    var pixels = imgData.data;
    cxt.clearRect(0,0,canvas.width(),canvas.height());
    //马赛克块数
    var numTileRows = 36;
    var numTileCols = 64;
    //每个块的尺寸
    var tileWidth = imgData.width/numTileCols;
    var tileHeight = imgData.height/numTileRows;
    for(var r = 0; r&lt; numTileRows; r++){
        for(var c = 0;c&lt;numTileCols;c++){
            //每块中心点
            var x = (c*tileWidth)+(tileWidth/2);
            var y = (r*tileHeight)+(tileHeight/2);
            var pos = (Math.floor(y)*(imgData.width*4))+(Math.floor(x)*4);
            var red = pixels[pos];   //红
            var green = pixels[pos+1]; //绿
            var blue = pixels[pos+2];  //蓝
            cxt.fillStyle = &quot;rgb(&quot;+red+&quot;, &quot;+green+&quot;, &quot;+blue+&quot;)&quot;;
            cxt.fillRect(x-(tileWidth/2),y-(tileHeight/2),tileWidth,tileHeight);
        }
    }
 setTimeout(dravCanvas,30);
}
</code></pre><p>效果截图：</p>
<p><img src="/images/2017-03-08/像素化video.PNG" alt=""></p>
<p>其中，<code>play</code>和<code>pause</code>方法都属于<code>video</code>DOM对象，用于开始和停止视频。</p>
<p>我们通过<code>bind</code>方法创建了一个回调函数，通过监听<code>play</code>事件实现在视频开始播放时运行回调函数，回调函数将调用自定义函数<code>dravCanvas</code>，该函数包含所有创建像素化效果和绘制画布内容的功能。通过在<code>dravCanvas</code>函数末尾添加一个<code>setTimeout</code>调用，与视频的帧播放速度同步重复调用这个方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Canvas学习（一）]]></title>
      <url>https://fantasticzhang.github.io/2017/03/08/Canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>HTML5 <code>&lt;canvas&gt;</code>元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成。<code>&lt;canvas&gt;</code>标签只是图形容器，必须使用脚本来绘制图形。</p>
<h3 id="创建一个画布（canvas）"><a href="#创建一个画布（canvas）" class="headerlink" title="创建一个画布（canvas）"></a>创建一个画布（canvas）</h3><p>一个画布在网页中是一个矩形框，通过 <code>&lt;canvas&gt;</code> 元素来绘制。</p>
<pre><code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;
style=&quot;border:1px solid #000000;&quot;&gt;
&lt;/canvas&gt;
</code></pre><p>  如果不设置canvas元素的尺寸，那么2D渲染上下文会被设置为使用默认宽度和高度，分别是300和150像素。</p>
<h3 id="使用JavaScript来绘制图像"><a href="#使用JavaScript来绘制图像" class="headerlink" title="使用JavaScript来绘制图像"></a>使用JavaScript来绘制图像</h3><p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：</p>
<pre><code>&lt;script&gt;
    var canvas = document.getElementById(&apos;myCanvas&apos;);
    if(canvas &amp;&amp; canvas.getContext){
        var cxt = canvas.getContext(&apos;2d&apos;);
      //线性渐变
        var grd = cxt.createLinearGradient(0,0,200,0);
        grd.addColorStop(0,&quot;blue&quot;);
        grd.addColorStop(1,&quot;pink&quot;);
        //矩形
         cxt.fillStyle = grd;
        cxt.fillRect(0,0,150,75);

    }
&lt;/script&gt;
</code></pre><p><code>getContext(&quot;2d&quot;)</code>返回的对象是浏览器内建的<code>CanvasRenderingContext2D</code>对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。绘图功能是通过该对象实现的。</p>
<p>因此，canvas元素并非Canvas中最强大的部分，真正的关键部分是2D渲染上下文，这是我们真正绘制图形的地方。canvas元素的用途只是作为2D渲染上下文的包装器，它包含绘图和图形操作所需要的全部方法和丰富功能。坐标系统的1个单位通常相当于屏幕的1个像素。</p>
<h3 id="Canvas坐标"><a href="#Canvas坐标" class="headerlink" title="Canvas坐标"></a>Canvas坐标</h3><p>canvas元素是一张画布，这张画布的原点在元素的左上角，水平的是x轴，竖直的是y轴。沿原点向右、向下是正值，向左、向上是负值。</p>
<h3 id="绘制基本图形和线条"><a href="#绘制基本图形和线条" class="headerlink" title="绘制基本图形和线条"></a>绘制基本图形和线条</h3><h4 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h4><pre><code>var canvas = document.getElementById(&apos;myCanvas&apos;);
var cxt = canvas.getContext(&apos;2d&apos;);
cxt.beginPath(); //开始路径
cxt.moveTo(40.40); //设置路径原点
cxt.lineTo(340,40); //设置路径终点
cxt.closePath(); //结束路径
cxt.stroke(); //绘出路径轮廓
</code></pre><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><pre><code>//fillRect(x, y, width, height)
cxt.fillStyle = &quot;#FF0000&quot;; //设置颜色
cxt.fillRect(40, 40, 100, 100); // 绘制一个矩形并给它填充颜色
cxt.strokeRect(200, 300, 200, 100); // 绘制一个矩形并给它绘制边框
</code></pre><p><code>fillRect(x, y, width, height)</code>中，<code>x</code>、<code>y</code>用来指定矩形左上角顶点的坐标；<code>width</code>指定矩形的宽；<code>height</code>指定矩形的高。</p>
<h4 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h4><pre><code>context.beginPath(); // 开始路径
context.arc(230, 90, 50, 0, Math.PI*2, false); // 绘制一个圆形
context.closePath(); // 结束路径
context.fill(); // 填充路径
</code></pre><p><code>arc(x, y, r, startAngle, endAngle, anticlockwise)</code>中，<code>x</code>、<code>y</code>指定圆点坐标；<code>r</code>指定半径；<code>startAngle</code>、 <code>endAngle</code>指定开始角度和结束角度；<code>anticlockwise</code>指定弧线的绘制方向，该参数可选，但是如果不传入这个参数Firefox会抛出一个错误，因此最好保留这个参数。</p>
<p>在Canvas中，一条弧线是由一条曲线定义的，它从与原点<code>(x,y)</code>距离为一个半径且角度为开始角度的位置开始，这条路径最后停在离原点<code>(x,y)</code>一个半径且角度为结束角度的位置上。此外，Canvas中的角度是以弧度而不是角度为单位的。简单地说，360度（一个完整的圆）是2π（<code>PI</code>的2倍）弧度。</p>
<p><img src="/images/2017-03-08/绘制圆弧.PNG" alt=""></p>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><pre><code>cxt.fillStyle = &quot;#FF0000&quot;; //指定填充颜色
cxt.strokeStyle = &quot;rgb(255, 0, 0)&quot;; //指定描边颜色
cxt.lineWidth = 5; // 指定线宽
</code></pre><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><pre><code>var text = &quot;Hello, World!&quot;; // 要绘制的文字
cxt.font = &quot;italic 30px serif&quot;;// 修改字号和字体 并设置为斜体
cxt.fillText(text, 40, 40); // 绘制文字
cxt.strokeText(text, 80, 80); // 绘制描边文字
</code></pre><p><code>strokeText(text, x, y)</code>中，<code>text</code>是准备绘制的文字，<code>(x,y)</code>是文本原点（左下角）的坐标值。</p>
<p>由于Canvas中的文本是以图形形式绘制的，因此它无法像HTML文档中的普通文字那样用鼠标指针选取——它实际上不是文本，只是像文本而已。</p>
<h3 id="擦除Canvas"><a href="#擦除Canvas" class="headerlink" title="擦除Canvas"></a>擦除Canvas</h3><h4 id="clearReact方法"><a href="#clearReact方法" class="headerlink" title="clearReact方法"></a>clearReact方法</h4><p><code>clearReact(x,y,width,height)</code>中<code>x</code>、<code>y</code>用来指定矩形左上角顶点的坐标；<code>width</code>指定矩形的宽；<code>height</code>指定矩形的高。该矩形区域就是要擦除的区域。使用该方法只会清除指定区域，并不会完全重置Canvas上的所有内容（例如：样式、颜色等会保留）。</p>
<h4 id="宽度-高度技巧"><a href="#宽度-高度技巧" class="headerlink" title="宽度/高度技巧"></a>宽度/高度技巧</h4><p>每当重新设置一个canvas元素的width和height属性时，Canvas都会自动清除内容并返回其原始状态。</p>
<pre><code>var canvas = $(&quot;#myCanvas&quot;);
var context = canvas.get(0).getContext(&quot;2d&quot;);
context.fillStyle = &quot;rgb(255, 0, 0)&quot;;
context.fillRect(40, 40, 100, 100);

context.beginPath();
context.arc(230, 90, 50, 0, Math.PI*2, false);
context.closePath();
context.fill();

canvas.attr(&quot;width&quot;, canvas.width());
canvas.attr(&quot;height&quot;, canvas.height());

context.fillRect(40, 40, 100, 100);
</code></pre><p>该技巧的缺点是，它会完全重置Canvas上的所有内容，包括样式和颜色。所以，只有准备完全重置Canvas时才能使用该方法。</p>
<h3 id="使Canvas填满浏览器窗口"><a href="#使Canvas填满浏览器窗口" class="headerlink" title="使Canvas填满浏览器窗口"></a>使Canvas填满浏览器窗口</h3><p>代码如下：</p>
<pre><code>//HTML
&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;
    &lt;!-- Insert fallback content here --&gt;
&lt;/canvas&gt;

//js
$(document).ready(function() {
    var canvas = $(&quot;#myCanvas&quot;);
    var context = canvas.get(0).getContext(&quot;2d&quot;);

    $(window).resize(resizeCanvas);

    function resizeCanvas() {
        canvas.attr(&quot;width&quot;, $(window).get(0).innerWidth);
        canvas.attr(&quot;height&quot;, $(window).get(0).innerHeight);
        context.fillRect(0, 0, canvas.width(), canvas.height());
    };

    resizeCanvas();
});

//css
* { margin: 0; padding: 0; }
html, body { height: 100%; width: 100%; }
canvas { display: block; }
</code></pre><h2 id="Canvas高级功能"><a href="#Canvas高级功能" class="headerlink" title="Canvas高级功能"></a>Canvas高级功能</h2><h3 id="保存和恢复画布状态"><a href="#保存和恢复画布状态" class="headerlink" title="保存和恢复画布状态"></a>保存和恢复画布状态</h3><p>在画布中，绘图状态指的是描述某一时刻2D渲染上下文外观的整套属性。用于描述画布绘图状态的全部属性为：变换矩阵、裁剪区域（cliping region）、globalAlpha、globalCompositeOperation、strokeStyle、fillStyle、lineWidth、lineCap、lineJoin、miterLimit、shadowOffsetX、shadowOffsetY、shadowBlur、shadowColor、font、textAlign、textBaseline。</p>
<p>注：画布上的当前路径和当前位图（正在显示的内容）并不属于状态。</p>
<p>保存绘图状态：<code>save</code>方法。</p>
<pre><code>var cxt = canvas.getContext(&apos;2d&apos;);
cxt.fillRect(0,0,150,150);
cxt.save();
</code></pre><p>恢复绘图状态：<code>restore</code>方法。</p>
<pre><code>var cxt = canvas.getContext(&apos;2d&apos;);
cxt.fillRect(0,0,150,150);
cxt.save();
cxt.fillStyle=&quot;blue&quot;;
cxt.fillRect(100,100,100,100);
cxt.restore();
cxt.fillRect(150,150,150,150);
</code></pre><p>2D渲染上下文会保存一个绘图状态栈，默认栈是空的。每调用一次<code>save</code>方法，就会有一个新状态添加到这个栈；每调用一次<code>restore</code>方法，就会取出最后添加到栈中的绘图状态，并将它应用于2D渲染上下文，用所保存的状态覆盖全部现有的样式。</p>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>即将2D渲染上下文的原点从一个位置移动到另一个位置。使用<code>translate</code>方法。<code>(x,y)</code>参数是移动后2D渲染上下文的坐标原点。</p>
<pre><code>cxt.translate(150.150);
</code></pre><p>注：该方法实际移动的是2D渲染上下文的坐标原点，而不是所绘制的对象，也不是<code>canvas</code>元素。移动后，再绘制新的对象时都会相对于新的2D渲染上下文的坐标原点，但移动之前所绘制的对象保持不变。</p>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>即调整2D渲染上下文的尺寸，使用<code>scale</code>方法。<code>(x,y)</code>参数是缩放倍数。</p>
<pre><code>cxt.scale(2,2);
</code></pre><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>使用<code>rotate</code>方法，参数为以弧度为单位的2D渲染上下文旋转角度值。</p>
<p>cxt.rotate(Math.PI/4); // 旋转45度</p>
<p><code>rotate</code>方法是把2D渲染上下文绕其原点进行旋转的。</p>
<h4 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h4><p>变换矩阵是一组数字。它们各自描述一个特定变形类型。矩阵分成多个列和行，在画布中使用的是一个3*3矩阵，如下图所示。</p>
<p><img src="/images/2017-03-08/2D渲染上下文的变化矩阵.PNG" alt=""></p>
<p>重要的是前两行，其中包含的数字值对应画布中使用的<code>a</code>至<code>f</code>。一个新的2D渲染上下文将包含一个全新的变换矩阵，即单位矩阵：</p>
<p><img src="/images/2017-03-08/单位矩阵.PNG" alt=""></p>
<p>操作变换矩阵的方法是<code>transform</code>和<code>setTransform</code>。<code>transform</code>方法有6个参数，分别对应变换矩阵中的每一个值，第一个表示<code>a</code>,最后一个表示<code>f</code>；<code>setTransform</code>方法的作用是将矩阵重置为单位矩阵。</p>
<pre><code>cxt.setTransform(1, 0, 0, 1, 0, 0); // Identity matrix
var xScale = Math.cos(0.7854);
var ySkew = -Math.sin(0.7854);
var xSkew = Math.sin(0.7854);
var yScale = Math.cos(0.7854);
var xTrans = 200;
var yTrans = 200;
cxt.transform(xScale, ySkew, xSkew, yScale, xTrans, yTrans);
cxt.fillRect(-50, -50, 100, 100);
</code></pre><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>在画布上绘制的所有东西是已经合成的，这意味着绘制的所有内容都会与已经绘制的现有元素合并在一起。这实际上都是基本合成，只是将一些内容叠加到另一些内容之上。下面是两个全局合成属性，因为是全局的，所以在修改这两个属性会影响到修改之后所绘制的全部内容。</p>
<h4 id="globalAlpha"><a href="#globalAlpha" class="headerlink" title="globalAlpha"></a>globalAlpha</h4><p>该属性的取值在<code>0.0</code>(全透明)与<code>1.0</code>(不透明)之间，默认值是1.0。即<code>globalAlpha</code>属性会影响到将要绘制的对象的透明度。</p>
<pre><code>cxt.fillStyle = &quot;rgb(63, 169, 245)&quot;;
cxt.fillRect(50, 50, 100, 100);
cxt.globalAlpha = 0.5;
cxt.fillStyle = &quot;rgb(255, 123, 172)&quot;;
cxt.fillRect(100, 100, 100, 100);
</code></pre><h4 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h4><p>该属性定义了对2D渲染上下文上所有绘制图形执行的合成类型，所谓合成，即一个图形叠加到另一个图形之上。<code>globalCompositeOperation</code>的默认值是<code>source-over</code>(源覆盖于目标之上)，源是绘制的新图形，而目标则是可能已经绘制了图形的2D渲染上下文。</p>
<p><code>globalCompositeOperation</code>支持11种选择：</p>
<ul>
<li><code>source-over</code>：源覆盖于目标之上</li>
<li><code>destination-over</code>：目标覆盖于源之上</li>
<li><code>source-atop</code>：源覆盖于目标之上，重叠区域二者都不透明，重叠区域之外的目标不透明，源透明</li>
<li><code>destination-atop</code>：目标覆盖于源之上，重叠区域二者都不透明，重叠区域之外的源不透明，目标透明</li>
<li><code>source-in</code>：在源与目标重叠的区域只绘制源，而不重叠的部分都变成透明的</li>
<li><code>destination-in</code>：在源与目标重叠的区域只绘制目标，而不重叠的部分都变成透明的</li>
<li><code>source-out</code>：在源与目标不重叠的区域只绘制源，其他部分都变成透明的</li>
<li><code>destination-out</code>：在源与目标不重叠的区域只绘制目标，其他部分都变成透明的</li>
<li><code>lighter</code>：源与目标的重叠区域两者的颜色值相加</li>
<li><code>copy</code>：只绘制源，覆盖掉目标</li>
<li><p><code>xor</code>：只绘制不重叠的源与目标区域，重叠的部分变成透明</p>
<p>  cxt.fillStyle = “rgb(63,169,245)”;<br>  cxt.fillRect(50,50,100,100);<br>  cxt.globalCompositeOperation = “xor”;<br>  cxt.fillStyle = “rgb(255,123,172)”;<br>  cxt.fillRect(100,100,100,100);</p>
</li>
</ul>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>通过4个全局属性进行控制：<code>shadowBlur</code>、<code>shadowColor</code>、<code>shadowOffsetX</code>、<code>shadowOffsetY</code></p>
<pre><code>cxt.shadowBlur = 0;
cxt.shadowOffsetX = 10;
cxt.shadowOffsetY = 10;
cxt.shadowColor = &quot;rgba(100,100,100,0.5)&quot;;
cxt.fillRect(50,50,100,100);
</code></pre><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p><code>fillStyle</code>和<code>strokeStyle</code>都可以接受以<code>CanvasGradient</code>对象表示的渐变颜色的值。画布支持两种类型的渐变：线性渐变(<code>createLinearGradient</code>)和放射渐变（<code>createRadialGradient</code>）。这两种方法都返回一个<code>CanvasGradient</code>对象，可以使用该对象本身的<code>addColorStop</code>方法对它进行进一步处理。</p>
<p>线性渐变：</p>
<pre><code>var gradient = cxt.createLinearGradient(0, 0, 0, canvas.height);
gradient.addColorStop(0, &quot;rgb(0, 0, 0)&quot;);
gradient.addColorStop(1, &quot;rgb(255, 255, 255)&quot;);
cxt.fillStyle = gradient;
cxt.fillRect(0, 0, canvas.width, canvas.height);
</code></pre><p><code>createRadialGradient</code>方法有4个参数：渐变起点的<code>(x,y)</code>坐标和渐变终点的<code>(x,y)</code>坐标。</p>
<p>放射渐变：</p>
<pre><code>var gradient = cxt.createRadialGradient(300,300,10,100,100,50);
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(150,150,150&quot;);
cxt.fillStyle = gradient;
cxt.fillRect(0,0,canvas.width,canvas.height);
</code></pre><p><code>createRadialGradient</code>方法有6个参数：前3个参数描述一个圆（开始圆），后3个参数描述另一个圆（结束圆）。这两个圆本身不仅描述了方向及渐变的起止位置，而且还描述了渐变的形状。实际的渐变效果是连接两个圆的椎体，其中开始圆之前的椎体部分显示偏移值为0的颜色，而结束圆之后的椎体部分则显示偏移值为1的颜色，如下图所示：</p>
<p><img src="/images/2017-03-08/放射渐变工作原理.PNG" alt=""></p>
<p>因此，如果将开始圆和结束圆放置在同一个位置，就可以得到我们想要的放射渐变效果。</p>
<h3 id="复杂路径"><a href="#复杂路径" class="headerlink" title="复杂路径"></a>复杂路径</h3><pre><code>cxt.beginPath();
cxt.moveTo(100, 50);
cxt.lineTo(150, 150);
cxt.lineTo(50, 150);
cxt.closePath();
cxt.stroke();
cxt.fill();
</code></pre><p>以上代码可以绘制一个三角形，效果如下：</p>
<p><img src="/images/2017-03-08/绘制三角形.PNG" alt=""></p>
<p>其中，<code>moveTo</code>方法会创建一条全新的子路径；<code>lineTo</code>方法只是沿着一条已有的子路径继续画线,每次调用都是从子路径的最后一个坐标开始画线；<code>closePath</code>方法会画一条线连接子路径的最后一个点和第一个点——封闭路径。</p>
<h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>两个方法：<code>quadraticCurveTo(cpx,cpy,x,y)</code>(二次贝塞尔曲线)和<code>bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x,y)</code>(三次贝塞尔曲线)，构造如下：</p>
<p><img src="/images/2017-03-08/贝塞尔曲线.PNG" alt=""></p>
<p>实例1：</p>
<pre><code>cxt.lineWidth = 5;
cxt.beginPath();
cxt.moveTo(50,250);
cxt.quadraticCurveTo(250,100,450,250);
cxt.stroke();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/quadraticCurveTo.PNG" alt=""></p>
<p>实例2：</p>
<pre><code>cxt.lineWidth = 5;
cxt.beginPath();
cxt.moveTo(50,250);
cxt.bezierCurveTo(150,50,350,450,450,250);
cxt.stroke();
cxt.bezierCurveTo(150,50,350,450,450,250);
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/bezierCurveTo.PNG" alt=""></p>
<h3 id="将画布导出为图像"><a href="#将画布导出为图像" class="headerlink" title="将画布导出为图像"></a>将画布导出为图像</h3><p>画布有一个<code>toDataURL</code>方法，可以将画布绘图转换为一个数据URL，我们可以通过它在浏览器上显示一个图像。</p>
<pre><code>cxt.save();
cxt.fillRect(50,50,100,100);
cxt.fillStyle = &quot;rgb(255,0,0)&quot;;
cxt.fillRect(100,100,100,100);
cxt.restore();
cxt.fillRect(150,150,100,100);
var dataURL = canvas.toDataURL();
console.log(dataURL);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[纯CSS绘制各种角度的三角形]]></title>
      <url>https://fantasticzhang.github.io/2017/02/23/%E7%BA%AFCSS%E7%BB%98%E5%88%B6%E5%90%84%E7%A7%8D%E8%A7%92%E5%BA%A6%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      <content type="html"><![CDATA[<p>以下是纯CSS绘制各种角度的三角形的方法。</p>
<h2 id="Triangle-Up"><a href="#Triangle-Up" class="headerlink" title="Triangle Up"></a>Triangle Up</h2><p>代码：</p>
<pre><code>#triangle-up{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-left:40px solid transparent;
    border-right:40px solid transparent;
}

&lt;h3&gt;Triangle Up&lt;/h3&gt;
&lt;div id=&quot;triangle-up&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-up.PNG" alt=""></p>
<h2 id="Triangle-Down"><a href="#Triangle-Down" class="headerlink" title="Triangle Down"></a>Triangle Down</h2><p>代码：</p>
<pre><code>#triangle-bottom{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-left:40px solid transparent;
    border-right:40px solid transparent;
}

&lt;h3&gt;Triangle Down&lt;/h3&gt;
&lt;div id=&quot;triangle-bottom&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottom.PNG" alt=""></p>
<h2 id="Triangle-Left"><a href="#Triangle-Left" class="headerlink" title="Triangle Left"></a>Triangle Left</h2><p>代码：</p>
<pre><code>#triangle-left{
    width:0;
    height:0;
    border-right: 80px solid #00ffff;
    border-top:40px solid transparent;
    border-bottom:40px solid transparent;
}
&lt;h3&gt;Triangle Left&lt;/h3&gt;
&lt;div id=&quot;triangle-left&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-left.PNG" alt=""></p>
<h2 id="Triangle-Right"><a href="#Triangle-Right" class="headerlink" title="Triangle Right"></a>Triangle Right</h2><p>代码：</p>
<pre><code>#triangle-right{
    width:0;
    height:0;
    border-left: 80px solid #00ffff;
    border-top:40px solid transparent;
    border-bottom:40px solid transparent;
}
&lt;h3&gt;Triangle Right&lt;/h3&gt;
&lt;div id=&quot;triangle-right&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-right.PNG" alt=""></p>
<h2 id="Triangle-Top-Left"><a href="#Triangle-Top-Left" class="headerlink" title="Triangle Top Left"></a>Triangle Top Left</h2><p>代码：</p>
<pre><code>#triangle-topleft{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-right:80px solid transparent;
}
&lt;h3&gt;Triangle Top Left&lt;/h3&gt;
&lt;div id=&quot;triangle-topleft&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-topleft.PNG" alt=""></p>
<h2 id="Triangle-Top-Right"><a href="#Triangle-Top-Right" class="headerlink" title="Triangle Top Right"></a>Triangle Top Right</h2><p>代码：</p>
<pre><code>#triangle-topright{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-left:80px solid transparent;
}
&lt;h3&gt;Triangle Top Right&lt;/h3&gt;
&lt;div id=&quot;triangle-topright&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-topright.PNG" alt=""></p>
<h2 id="Triangle-Bottom-Left"><a href="#Triangle-Bottom-Left" class="headerlink" title="Triangle Bottom Left"></a>Triangle Bottom Left</h2><p>代码：</p>
<pre><code>#triangle-bottomleft{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-right:80px solid transparent;
}
&lt;h3&gt;Triangle Bottom Left&lt;/h3&gt;
&lt;div id=&quot;triangle-bottomleft&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottomleft.PNG" alt=""></p>
<h2 id="Triangle-Bottom-Right"><a href="#Triangle-Bottom-Right" class="headerlink" title="Triangle Bottom Right"></a>Triangle Bottom Right</h2><p>代码：</p>
<pre><code>#triangle-bottomright{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-left:80px solid transparent;
}
&lt;h3&gt;Triangle Bottom Right&lt;/h3&gt;
&lt;div id=&quot;triangle-bottomright&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottomright.PNG" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo主题中加入相册功能]]></title>
      <url>https://fantasticzhang.github.io/2017/02/21/hexo%E4%B8%BB%E9%A2%98%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>前段时间一个朋友问我：怎么给自己的博客加入相册功能？我还真被问住了，因为搭建博客的初衷是写一些文字性的东西，并没有考虑过“相册”这回事。但被朋友问到后，仔细想了想，给博客加入相册功能还是挺不错的，可以和大家分享一些自己喜欢的图片。于是参考了网上的相关资料，最终实现了一个简单的相册功能。现把实现过程记录下来，以供大家参考。</p>
<p>主要是参考了<a href="http://www.cnblogs.com/xljzlw/p/5137622.html" target="_blank" rel="external">这篇文章</a>,但这篇文章的作者使用的是<code>yilia</code>主题，该主题已实现了相册功能。而我使用的是<a href="https://github.com/hsihohuang/kiddochan" target="_blank" rel="external">kiddochan</a>主题，这个主题并没有实现相册功能。因此，我的实现过程和我参考的那篇文章也略有不同，但整体流程还是类似的。</p>
<h2 id="新建相册页面"><a href="#新建相册页面" class="headerlink" title="新建相册页面"></a>新建相册页面</h2><p><code>hexo new page “photos”</code></p>
<p>执行上面的命令，会在<code>source</code>文件夹中生成一个<code>photo</code>文件夹，打开<code>photo</code>文件夹中的<code>index.md</code>文件，修改内容如下：</p>
<pre><code>---
title: 相册
---

&lt;link type=&quot;text/css&quot; href=&quot;/css/photo.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;link type=&quot;text/css&quot; href=&quot;/fancybox/jquery.fancybox.css&quot; rel=&quot;stylesheet&quot;&gt;

&lt;div class=&quot;photos&quot;&gt;
  &lt;section class=&quot;archives album&quot;&gt;
    &lt;ul class=&quot;img-box-ul&quot;&gt;&lt;/ul&gt;
  &lt;/section&gt;
&lt;/div&gt;
</code></pre><p>其中，’photo.css’用来控制相册样式，由于我使用的主题并没有实现相册功能，因此需要另写一个样式来控制相册的展示。</p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>在主题的配置文件<code>_config.yml</code>的menu下添加一个相册的菜单：</p>
<pre><code>menu:
  主页: /
  归档: /archives
  关于: /about
  相册: /photos
</code></pre><h2 id="存放图片"><a href="#存放图片" class="headerlink" title="存放图片"></a>存放图片</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先图片不能放在<code>source</code>文件夹中，因为需要编译成静态文件，非常慢。那么该放到哪里好呢？</p>
<p>在使用hexo搭建博客时，我们都会在github上会建立一个名为<code>username.github.io</code>的仓库，而且仓库只存储了整个项目的一部分。所以，一般我们都会在github上另建一个仓库，用来存储整个博客项目的文件对博客进行备份，这样就能在不同的电脑上写博客了。因此，我们可以在根目录下新建一个<code>photos</code>文件夹用来存放相册需要展示的图片文件，这样图片的数量就不受限制了。</p>
<h3 id="存放图片-1"><a href="#存放图片-1" class="headerlink" title="存放图片"></a>存放图片</h3><p>在博客的根目录下新建一个<code>photos</code>的文件夹，里面存放你想要展示的图片文件。然后把整个博客项目部署到github上，才能访问到图片的线上地址。</p>
<h2 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h2><p>那么多图片的文件名该怎么获取呢？由于原生<code>js</code>不能很好的处理文件，因此不能直接在js文件中获取图片的文件名。但我们可以新建一个基于nodejs的js文件用来读取所有图片，并把所有的图片名称放在一个json文件中供相册页面的js文件使用。</p>
<p>在<code>source\photo</code>文件夹中新建一个<code>tool.js</code>文件，内容如下：</p>
<pre><code>&quot;use strict&quot;;
    const fs = require(&quot;fs&quot;);
    const path = &quot;../../photos&quot;;

    fs.readdir(path, function (err, files) {
        if (err) {
            return;
        }
        let arr = [];
        (function iterator(index) {
            if (index == files.length) {
                fs.writeFile(&quot;output.json&quot;, JSON.stringify(arr, null, &quot;\t&quot;));
                return;
            }

            fs.stat(path + &quot;/&quot; + files[index], function (err, stats) {
                if (err) {
                    return;
                }
                if (stats.isFile()) {
                    arr.push(files[index]);
                }
                iterator(index + 1);
            })
        }(0));
    });
</code></pre><p>通过<code>node tool.js</code>命令运行该文件，会在<code>source\photos</code>下生成一个<code>output.json</code>文件:</p>
<pre><code>[
    &quot;IMG_20161005_164625.jpg&quot;,
    &quot;IMG_20161005_165430.jpg&quot;,
    &quot;IMG_20161005_165817.jpg&quot;,
    &quot;IMG_20161005_172129.jpg&quot;,
    &quot;IMG_20161006_130939.jpg&quot;,
    &quot;IMG_20161006_132426.jpg&quot;,
    &quot;IMG_20161006_132836.jpg&quot;,
    &quot;IMG_20161116_141430.jpg&quot;,
    &quot;IMG_20161116_150715.jpg&quot;,
    &quot;IMG_20161116_155406.jpg&quot;,
    &quot;IMG_20161118_124950.jpg&quot;,
    &quot;mmexport1479264425744.jpg&quot;,
    &quot;mmexport1479264435676.jpg&quot;
]
</code></pre><p>之后每次添加了新的图片，都要运行<code>node tool.js</code>来更新<code>output.json</code>文件的内容。</p>
<h2 id="生成相册页的代码"><a href="#生成相册页的代码" class="headerlink" title="生成相册页的代码"></a>生成相册页的代码</h2><p>在<code>myBlog\themes\kiddochan\source\js</code>（myBlog为我的博客根目录，kiddochan为我使用的主题，替换成相应的即可）文件夹下新建一个photo.js，代码如下：</p>
<pre><code>//相册功能 2017-02-20 add
var page = 1;
var offset = 20;

function photoShow(page ,data){
  var begin = (page - 1) * offset;
  var end = page * offset;
  if (begin &gt;= data.length) return;
  var html, li = &quot;&quot;;
  for (var i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) {
      li += &apos;&lt;li&gt;&lt;div class=&quot;img-box&quot;&gt;&apos; +
          &apos;&lt;a class=&quot;img-bg&quot; rel=&quot;example_group&quot; href=&quot;https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&apos; + data[i] + &apos;?raw=true&quot;&gt;&lt;/a&gt;&apos; +
          &apos;&lt;img lazy-src=&quot;https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&apos; + data[i] + &apos;?raw=true&quot; /&gt;&apos; +
          &apos;&lt;/li&gt;&apos;;
  }

  $(&quot;.img-box-ul&quot;).append(li);
  $(&quot;.img-box-ul&quot;).lazyload();
  $(&quot;a[rel=example_group]&quot;).fancybox();
}

function photoScroll(data){
  $(window).scroll(function() {
      var windowPageYOffset = window.pageYOffset;
      var windowPageYOffsetAddHeight = windowPageYOffset + window.innerHeight;
    //  var sensitivity = 0;
      var offsetTop = $(&quot;.photos&quot;).offset().top + $(&quot;.photos&quot;).height();
      if (offsetTop &gt;= windowPageYOffset &amp;&amp; offsetTop &lt; windowPageYOffsetAddHeight) {
          photoShow(++page, data);
      }
  })
}

var photoInit = function() {
    $.getJSON(&quot;/photos/output.json&quot;, function (data) {
        photoShow(page, data);

        photoScroll(data);
    });
}
</code></pre><p>  其中，<code>https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&#39; + data[i] + &#39;?raw=true&quot;</code>是上传至github的图片链接。</p>
<p>  该文件读取json文件，将图片的线上url拼接起来渲染在相册页面上。</p>
<p>  在<code>myBlog\themes\layout\_patial\after_footer.ejs</code>文件中加入了如下代码：</p>
<pre><code>&lt;!--相冊功能--&gt;
&lt;script src=&quot;/js/jquery.lazyload.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/photo.js&quot;&gt;&lt;/script&gt;

$(document).ready(function(){
  //相册功能 2017-02-20 add
  if($(&quot;.photos&quot;).length) {
      photoInit();
   }
});
</code></pre><p>根据实际所使用的主题，添加到相应位置即可。</p>
<p>最后，运行<code>hexo g</code>、<code>hexo d</code>等相应命令，相册功能就实现了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grid布局]]></title>
      <url>https://fantasticzhang.github.io/2017/02/18/Grid%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Grid布局（又称网格布局）是指：以规则的网格阵列来指导和规范网页中的版面布局以及信息分布。</p>
<h1 id="CSS-Grid布局"><a href="#CSS-Grid布局" class="headerlink" title="CSS Grid布局"></a>CSS Grid布局</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSS Grid布局是一种二维网格布局系统，旨在彻底改变基于网格的用户界面的设计。目前，CSS Grid布局仅仅是一个W3C工作草案，因此还没有被任何浏览器默认支持。在Chrome中体验Grid布局的方法：打来浏览器并输入chrome://flags，找到”experimental web platform features”（实验性网络平台功能）,启用并重启浏览器。Opera和Firefox也支持CSS Grid布局，具体启用方法可参考相关网络资料。</p>
<h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><p>在整个Grid布局中常用到的术语如下：</p>
<ul>
<li>网格容器（Grid Container）：所有网格项的父元素；</li>
<li>网格项（Grid Item）：网格容器的直接子元素；</li>
<li>网格线（Grid Line）：组成网格的分界线；</li>
<li>网格轨道（Grid Track）：两个相邻的网格线之间为网格轨道，即网格的行或列；</li>
<li>网格单元（Grid Cell）：网格轨道相交的区域；</li>
<li>网格区域（Grid Area）：由任意数量的网格单元组成；</li>
<li>间距（Gutters）：两个网格轨道之间的区域。</li>
</ul>
<h2 id="设置在网格容器上的属性"><a href="#设置在网格容器上的属性" class="headerlink" title="设置在网格容器上的属性"></a>设置在网格容器上的属性</h2><ul>
<li>display：属性值有：grid、inline-grid、subgrid；</li>
<li>grid-template-columns：用一组值来设置列的大小；</li>
<li>grid-template-rows：用一组值来设置行的大小；</li>
<li>grid-template-areas：通过获取网格项中的grid-area属性值来定义网格模板，用’.’代表空网格单元；</li>
<li>grid-column-gap：网格单元列间距；</li>
<li>grid-row-gap：网格单元行间距；</li>
<li>grid-gap：网格单元间距，是grid-column-gap和grid-row-gap的简写；</li>
<li>justify-items：垂直于列网格线对齐，适用于网格容器中的所有网格项。属性值有：start、end、center、stretch；</li>
<li>align-items：垂直于行网格线对齐，适用于网格容器中的所有网格项。属性值同上；</li>
<li>justify-content：在总网格区域大小小于网格容器时，使用该属性设置网格的对齐方式（垂直于列网格线对齐）。属性值有：start、end、center、stretch、space-around、space-between、space-evenly；</li>
<li>align-content：在总网格区域大小小于网格容器时，使用该属性设置网格的对齐方式（垂直于行网格线对齐）。属性值同上；</li>
<li>grid-auto-columns：设置隐式网格轨道（列）的大小，当定位网格项超出网格容器范围时，将自动创建隐式网格轨道；</li>
<li>grid-auto-rows：设置隐式网格轨道（行）的大小；</li>
<li>grid-auto-flow：在没有设置网格项的位置时，这个属性控制网格项的排列方式。属性值有：row、column、dense；</li>
<li>grid：一种简写形式，设置网格容器所有属性。属性值有：none，(grid-template-rows) / (grid-template-columns)，(grid-auto-flow) [(grid-auto-rows) [ /(grid-auto-columns)]]。</li>
</ul>
<h2 id="设置在网格项上的属性"><a href="#设置在网格项上的属性" class="headerlink" title="设置在网格项上的属性"></a>设置在网格项上的属性</h2><ul>
<li>grid-column-start：通过网格线来定义网格项的列开始位置；</li>
<li>grid-column-end：通过网格线来定义网格项的列结束位置；</li>
<li>grid-row-start：通过网格线来定义网格项的行开始位置；</li>
<li>grid-row-end：通过网格线来定义网格项的行结束位置；</li>
<li>grid-column：是 grid-column-start、grid-column-end的简写；</li>
<li>grid-row：是 grid-row-start、grid-row-end 的简写；</li>
<li>grid-area：定义网格项名字，以便创建模块；</li>
<li>justify-self：定义单个网格项垂直于列网格线的对齐方式；</li>
<li>align-self：定义单个网格项垂直于行网格线的对齐方式；</li>
</ul>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>代码：</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .grid_1{
            display: grid;
            grid-template-columns: 150px 20px 150px 20px 150px;
            grid-template-rows: auto 20px auto 20px auto;
        }
        .item1{
            grid-column: 1;
            grid-row: 1;
            background: blueviolet;
        }
        .item2{
            grid-column: 3;
            grid-row: 1;
            background: chocolate;
        }
        .item3{
            grid-column: 5;
            grid-row: 1;
            background: #e2e242;
        }
        .item4{
            grid-column: 1;
            grid-row: 3;
            background: #42e2b9;
        }
        .item5{
            grid-column: 3;
            grid-row: 3;
            background: #e28cc8;
        }
        .item6{
            grid-column: 5;
            grid-row: 3;
            background: #2be24c;
        }
        .item7{
            grid-column: 1;
            grid-row: 5;
            background: #c2e2da;
        }
        .item8{
            grid-column: 3;
            grid-row: 5;
            background: blueviolet;
        }
        .item9{
            grid-column: 5;
            grid-row: 5;
            background: #e2203f;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;section class=&quot;grid_1&quot;&gt;
    &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt;
    &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt;
    &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt;
    &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;
    &lt;div class=&quot;item7&quot;&gt;7&lt;/div&gt;
    &lt;div class=&quot;item8&quot;&gt;8&lt;/div&gt;
    &lt;div class=&quot;item9&quot;&gt;9&lt;/div&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>效果图：</p>
<p><img src="/images/2017-02-18/Grid.PNG" alt=""></p>
<p>以上只是对CSS Grid布局的简单介绍，比较详细的介绍可参考<a href="http://peale.cn/2016/12/08/2016_12_8_grid/#more" target="_blank" rel="external">这篇文章</a></p>
<h1 id="Bootstrap对Grid布局的实现"><a href="#Bootstrap对Grid布局的实现" class="headerlink" title="Bootstrap对Grid布局的实现"></a>Bootstrap对Grid布局的实现</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过定义容器大小，平分12份，再调整内外边距，最后再结合媒体查询，就制作出了强大的响应式的栅格系统。</p>
<p>Bootstrap为不同的屏幕尺寸提供了不同的栅格样式。Bootstrap3中通过媒体查询@media定义了四种屏幕类型：超小屏幕设备手机（<768px，xs）、小屏幕设备平板（>= 768px，sm）、中等屏幕设备桌面（&gt;=992px，md）、大屏幕设备桌面（&gt;=1200px，lg）。针对四种不同的屏幕大小分别对container样式固定了尺寸（自动、750px、970px、1170px），例如：</768px，xs）、小屏幕设备平板（></p>
<pre><code>@media (min-width:1200){
  .container{ width:1170px; }
}
</code></pre><h2 id="Bootstrap中栅格系统的主要工作原理"><a href="#Bootstrap中栅格系统的主要工作原理" class="headerlink" title="Bootstrap中栅格系统的主要工作原理"></a>Bootstrap中栅格系统的主要工作原理</h2><ul>
<li>一行数据（row）必须包含在.container中，以便为其赋予合适的对齐方式和内边距（padding）。</li>
<li>使用行（row）在水平方向创建一组列（column）。</li>
<li>具体内容应当放置于列（column）内，而且只有列（column）可以作为行（row）的直接子元素。</li>
<li>内置了许多样式，可以使用像.row和.col-xs-5这样的样式来快速创建栅格布局。</li>
<li>通过设置padding从而创建列之间的间隔。然后通过为第一列和最后一列设置负的margin从而抵消掉padding的影响。</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围的。</li>
</ul>
<h2 id="涉及的CSS特性"><a href="#涉及的CSS特性" class="headerlink" title="涉及的CSS特性"></a>涉及的CSS特性</h2><ul>
<li>列组合涉及两个CSS特性：左浮动和宽度百分比；</li>
<li>列偏移（offset）涉及一个CSS特性：margin-left；</li>
<li>列排序（pull、push）涉及三个CSS特性：左浮动、left、right。</li>
</ul>
<p>此外，可使用Bootstrap提供的clearfix样式来清除浮动。</p>
<p>例：</p>
<pre><code>&lt;div class=”row”&gt;
    &lt;div class=”col-xs-6 col-sm-3”&gt;div1：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div2：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”clearfix visible-xs”&gt; &lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div3：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div4：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;/div&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js修改url中某个指定参数的值]]></title>
      <url>https://fantasticzhang.github.io/2017/01/16/js%E4%BF%AE%E6%94%B9url%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location对象很特别，因为它既是window对象的属性，也是document对象的属性；也就是说，window.location和document.location引用的是同一个对象。location对象将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下面是location对象的所有属性。</p>
<ul>
<li>hash：返回URL中的hash（#号后跟的零或多个字符），如果URL中不包含散列，则返回空字符串；例: “#contents”</li>
<li>host：返回服务器名称和端口号（如果有）；例：”www.baidu.com:80”</li>
<li>hostname：返回不带端口号的服务器名称；例：”www.baidu.com”</li>
<li>href：返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值；例：”<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>“</li>
<li>pathname：返回URL中的目录和（或）文件名；例：”/WilleyCDA/“</li>
<li>port：返回URL中指定的端口号。如果没有则返回空串。例：”8080”</li>
<li>portocol：返回页面使用的协议，通常是http:或https:  例：”http:”</li>
<li>search：返回URL的查询字符串。这个字符串以问好开头；例：”?q=javascript”</li>
</ul>
<h2 id="js修改url中某个指定参数的值"><a href="#js修改url中某个指定参数的值" class="headerlink" title="js修改url中某个指定参数的值"></a>js修改url中某个指定参数的值</h2><p>下面是一个利用javascript修改url中某个参数的值的办法，可以直接修改当前url中的某个参数的值而不会导致这个url中同一个参数存在多个值的情况。</p>
<pre><code>/*
* url 目标url
* arg 需要替换的参数名称
* arg_val 替换后的参数的值
* return url 参数替换后的url
*/
function changeURLArg(url,arg,arg_val){
    var pattern=arg+&apos;=([^&amp;]*)&apos;;
    var replaceText=arg+&apos;=&apos;+arg_val;
    if(url.match(pattern)){
        var tmp=&apos;/(&apos;+ arg+&apos;=)([^&amp;]*)/gi&apos;;
        tmp=url.replace(eval(tmp),replaceText);
        return tmp;
    }else{
        if(url.match(&apos;[\?]&apos;)){
            return url+&apos;&amp;&apos;+replaceText;
        }else{
            return url+&apos;?&apos;+replaceText;
        }
    }
    return url+&apos;\n&apos;+arg+&apos;\n&apos;+arg_val;
}
</code></pre><p>使用方法：</p>
<pre><code>changeURLArg(&apos;http://www.daimajiayuan.com/test.php?class_id=3&amp;id=2&apos;,&apos;class_id&apos;,4);
</code></pre><p>结果：<a href="http://www.daimajiayuan.com/test.php?class_id=4&amp;id=2" target="_blank" rel="external">http://www.daimajiayuan.com/test.php?class_id=4&amp;id=2</a></p>
<p><a href="http://www.daimajiayuan.com/sitejs-17226-1.html" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转载】2016年JavaScript回顾]]></title>
      <url>https://fantasticzhang.github.io/2016/12/30/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%912016%E5%B9%B4JavaScript%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<p>2016年是值得纪念、奇怪的、有点高兴也有点可怕的一年，这一切取决于你怎么看。跟其他事件相比仅仅专注于javascript可能看起来没什么大不了，但对于每个web开发人员来说javascript都是工作生活中非常大的一部分。</p>
<p><a href="http://www.modulecounts.com/" target="_blank" rel="external">JavaScript的流行继续激增</a>。不是每个人都喜欢这种语言，但是你很少听到十年前的嘲笑意见。就个人而言，我一直喜欢JavaScript，即使在早期，那些令人沮丧的年代。只要从C++、Java或PHP方向接近它的人首先都会感到困惑：JavaScript看起来很熟悉，但又不是。克服你的假设，你会喜欢它简单的优雅，实用性和灵活性。（比如：日期处理仍然是一个噩梦！)</p>
<p>JavaScript在5月份庆祝了它21岁的生日，让我们回顾下它成熟发展的这第一年…</p>
<h2 id="ECMAScript发展"><a href="#ECMAScript发展" class="headerlink" title="ECMAScript发展"></a>ECMAScript发展</h2><p>ES6/2015是语言自诞生以来最重要的更新。规范花了七年才完成，但浏览器和运行时终于开始支持箭头函数，let、const，这带来了更多的乐趣。<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external"> ES6兼容性表正在变成一个光辉的绿色</a>。</p>
<p>如果你需要支持旧的浏览器，全面切换到ES6也许会有一点早。对于旧的浏览器，一年多前发布的项目。您可以用ES6到ES5编译器（如Babel），但是开发非常复杂，需要引入额外的构建步骤。</p>
<p>ES7/2016是更多的革命。一个令人兴奋的新功能是async，它允许异步代码以同步方式写入，而没有回调或Promises（继续困惑我）的语法复杂性。</p>
<h2 id="渐进式Web应用程序"><a href="#渐进式Web应用程序" class="headerlink" title="渐进式Web应用程序"></a>渐进式Web应用程序</h2><p>我最喜欢的基于JavaScript的2016年技术授予Progressive Web Apps。 PWA是在谷歌的<a href="https://developers.google.com/web/shows/cds/2015/progressive-web-apps-chrome-dev-summit-2015" target="_blank" rel="external">2015年Chrome开发者峰会</a>上宣布，但稳定的技术和工具终于在7月到达Chrome 52。 PWA允许离线优先功能，并取代片状AppCache方法。 Web应用程序终于可以和native应用程序竞争，并提供以下优势：</p>
<ul>
<li>主屏幕图标</li>
<li>快速启动和自定义闪屏</li>
<li>快速执行</li>
<li>离线功能，无需互联网连接</li>
<li>网址，链接和书签</li>
<li>全屏或主题界面</li>
<li>沙盒执行</li>
<li>本地或基于云的存储</li>
<li>更少的设备空间和处理资源</li>
<li>更好的安全性（HTTPS是先决条件）</li>
<li>从任何搜索引擎轻松发现</li>
<li>请在安装前尝试</li>
<li>更简单的部署：它只是一个Web应用程序</li>
<li>没有AppStore废话：你的应用程序可以包含任何裸体画并且你绝对会渴望没有人能拿走你30％的利润！</li>
</ul>
<p>最重要的是：任何网站或者应用程序可以在几小时内转换为PWA。步骤：</p>
<ol>
<li>在服务器上启用HTTPS。</li>
<li>创建一个应用程序清单 - 应用程序根目录中的JSON文件，用于定义名称，颜色，图标和显示选项。</li>
<li>创建一个Service Worker - 根目录中的JavaScript文件用于拦截网络调用,并且可以根据需要返回缓存或实时数据。</li>
</ol>
<p>初期例子很少，但是PWA提供了一个不错的机会“动员”您的Web应用程序。虽然不能保证苹果将实施这项技术，但这并不重要，你的应用程序仍然可以在Safari中工作，只是它不会从离线执行中受益。我有一种感觉一旦Android上web体验有明显提升,苹果将鼓励支持PWA。</p>
<p>有关详细信息，请参阅 <a href="https://dev.opera.com/articles/pwa-resources/" target="_blank" rel="external">Dev.Opera’s Progressive Web Apps: The definitive collection of resources</a>和<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="external">Google的PWA指南</a>。</p>
<h2 id="框架固定"><a href="#框架固定" class="headerlink" title="框架固定"></a>框架固定</h2><p>很难做出一个公正的判断，但是<a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>似乎在今年受到最多的关注。你也许不同意;因为这取决于你使用的是什么，你曾经浏览过的地方和你说过的话！</p>
<p><a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>已经普及，2.0版本于9月发布。</p>
<p><a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>可能已经失去了它在2015年获得的一些势头，但这可能会随着9月发布Angular 2而改变。新版本是一个完全重写;它不是向后兼容v1.0。</p>
<p>虽然新的框架和库是令人兴奋的，但是十年前的jQuery仍然强大。版本3.0于6月9日发布，v3.1随后于7月7日出现。该库现在以严格模式运行，支持Promise，并实现了各种修复。 （查看完整修改列表的<a href="http://jquery.com/upgrade-guide/3.0/" target="_blank" rel="external">升级指南</a>。）</p>
<p>在使用JavaScript的96.4％的网站上用了jQuery。与之相比，Angular是最常用的现代框架 - 占0.5％。 jQuery 1.x是最流行的版本，占93.5％的使用率。版本2.x占6.0％、版本3.x占0.5％。</p>
<p>我一直批评开发人员上来就直接使用jQuery。当有一个其他更合适的选择或只要一小段JavaScript就能实现需求的时候，它就会被过度使用了。然而，它提供了更浅的学习曲线，比大多数框架更灵活。其他框架或库要取代它需要很多年的时间。</p>
<h2 id="API滥用"><a href="#API滥用" class="headerlink" title="API滥用"></a>API滥用</h2><p>比如电池状态API。在我2013年写JavaScript的时候，它似乎很有用;当你的应用程序检测到用户的手机即将关机的时候，到底怎样才能更好的最小化网络请求和处理呢?</p>
<p>不幸的是，Mozilla预估大约有6％的网站用了这个API​​，但大多数是广告客户用来检测电池状态，并跟踪用户浏览了哪些网站的域名。也有可能是某些服务商知道一个用户手机快关机绝望的时候，以此来提高某些服务的价格，</p>
<p>虽然这不是JavaScript或API的问题，出于隐私方面的原因，Mozilla采取了空前的手段把电池状态API从Firefox 53中删除。这不太可能出现在ios设备中,其他具有类似原因的API也包括传感器和蓝牙。这是一个不太光彩的事情：这些API都有实际的好处，我希望隐私问题可以在未来的版本得到解决。</p>
<h2 id="Node新版本"><a href="#Node新版本" class="headerlink" title="Node新版本"></a>Node新版本</h2><p>每年Node.JS会给我们带来两次发布进度，4月的6.0版本和10月的7.0版本。</p>
<p>目前该平台呈上升趋势，尽管W3Techs报告Node.js服务器使用率仅为0.2％，而PHP为82.3％。这些数字可能有点误导，因为Node.js即使安装了，也不一定能识别。</p>
<p>因为php已经开始很久了，并且现在依然是服务端最靠谱的选择。然而，Node.js正在书写自己的历史，并被所有语言信仰的开发者广泛使用。</p>
<h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>我非常喜欢npm，并且认为它是Node.js工具火爆的主要原因之一。在npm上我从来没有遇到过太多的问题，但我不是在Facebook这样大的项目上工作。</p>
<p>Facebook的工程师在10月份发布了Yarn。它是一个新的Node.js包管理器，旨在比npm更快更稳定。它依赖于npm注册表，因此可以和npm保持完全兼容。</p>
<p>Tim Severien的<a href="https://www.sitepoint.com/yarn-vs-npm/" target="_blank" rel="external">Yarn vs npm：你需要知道的一切</a>。我同意他的结论：</p>
<p>虽然Yarn不是一个复制品，但它改善了npm几个缺陷的地方。如果npm从Yarn身上学习，并要求Facebook、谷歌和其他Yarn贡献者一起来改进npm，这样是不是很爽呢？</p>
<h2 id="厌倦疲劳"><a href="#厌倦疲劳" class="headerlink" title="厌倦疲劳"></a>厌倦疲劳</h2><p>2016年的有篇文章叫I-can’t-take-this-any-more入选了Jose Aguinaga的<a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.e4rkosi1w" target="_blank" rel="external">2016年学习JavaScript的感觉</a>。亚军：dayssincelastjavascriptframework.com。</p>
<p>这可能是种幽默的方式以表明当前JavaScript的状态，但有一点要说明的就是，就是现在要跟上最新的趋势，框架和建议变得越来越难。当面对大量的技术方案评估时，开发人员会相互争执。</p>
<p>我的建议：不要试图跟上。因为这根本做不到。你今天重点关注的任何系统,明天都将被更好的东西取代。为您的项目选择一个好的方案，并坚持使用它，除非它让工作变得很糟糕。</p>
<p>有一个是可以确定的就是JavaScript本身。首先学习语言，并继续扩展你的知识。您的经验将帮助您了解每个框架的运作方式，以便您做出明智的选择，即便这种选择可能是完全放弃所有的框架。</p>
<p>新年快乐！</p>
<p>原文链接：<a href="http://cnedwan.com/2016/12/21/%E8%AF%91-2016%E5%B9%B4Javascript%E5%9B%9E%E9%A1%BE.html" target="_blank" rel="external">【译】2016年javascript回顾</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文字循环无缝滚动特效代码]]></title>
      <url>https://fantasticzhang.github.io/2016/12/29/%E6%96%87%E5%AD%97%E5%BE%AA%E7%8E%AF%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8%E7%89%B9%E6%95%88%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今天突然被问到了这个问题，现把我的解决方案记下来以便日后查看。下面是一个简单的小例子：</p>
<pre><code>&lt;div  id=&quot;textScroll&quot; style=&quot;overflow:hidden;height:200px;width:300px;font-size:14px;line-height:22px;text-align:left;padding:10px&quot;&gt;
&lt;div id=&quot;textScroll1&quot;&gt;
  文字实循环无缝滚动
  &lt;/div&gt;
&lt;div id=&quot;textScroll2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

//原理：设置好固定的宽高，内容的实际高度比这个高得多。控制滚动条，在滚到一定位置后减小滚动条高度，重复此过程。

var textScroll = document.getElementById(&quot;textScroll&quot;);
var textScroll1 = document.getElementById(&quot;textScroll1&quot;);
var textScroll2 = document.getElementById(&quot;textScroll2&quot;);
var speed=50;    //滚动速度值，值越大速度越慢

//复制文本,使文本总高度大于父元素高度，这样才能无缝滚动
var nnn=200/textScroll1.offsetHeight;
for(i=0;i&lt;nnn;i++){textScroll1.innerHTML+=&quot;&lt;br /&gt;&quot;+ textScroll1.innerHTML}
textScroll2.innerHTML = textScroll1.innerHTML;

function Marquee(){
if(textScroll2.offsetTop-textScroll.scrollTop&lt;=0)    //当滚动至textScroll2时
{
    textScroll.scrollTop-=textScroll1.offsetHeight;    //textScroll跳到最顶端,从头开始滚动

}
else{
    textScroll.scrollTop++;     //持续滚动
}
}

var MyMar = setInterval(Marquee,speed);        //设置定时器
textScroll.onmouseover = function(){clearInterval(MyMar)}    //鼠标经过时清除定时器达到滚动停止的目的
textScroll.onmouseout = function(){MyMar = setInterval(Marquee,speed)};    //鼠标移开时重设定时器
&lt;/script&gt;
</code></pre><p>例子很简单，可根据实际情况进行修改以满足实际需要。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序开发（一）]]></title>
      <url>https://fantasticzhang.github.io/2016/12/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>前段时间，微信小程序突然火了，朋友圈被刷屏了。但由于某些原因，博主一直没有了解它，终于在昨天，抽了些时间了解了下小程序，主要是阅读了官方文档，之后博主觉得，小程序还是蛮有意思的，于是决定将自己的学习过程记录下来，也希望能够和同样对微信小程序感兴趣的朋友们多多交流。</p>
<p>以下内容主要来自于<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1481249514" title="小程序官方文档" target="_blank" rel="external">官方文档</a>。</p>
<h1 id="微信小程序简介"><a href="#微信小程序简介" class="headerlink" title="微信小程序简介"></a>微信小程序简介</h1><p>下面是官方给出的关于微信小程序的介绍：</p>
<p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。小程序、订阅号、服务号、企业号是并行的体系。</p>
<p>由官方的表述来看，通俗一点的说，微信小程序其实就是微信提高了自身对HTML5特性的支持能力，开放了更多的系统调用。因此，微信里的HTML5产品将有更好的用户体验，更快的加载速度以及更多的功能。</p>
<h1 id="小程序注册"><a href="#小程序注册" class="headerlink" title="小程序注册"></a>小程序注册</h1><p>目前，微信小程序只开放了对企业、政府、媒体以及其他组织的注册，并没有开放对个人开发者的注册，那么个人如何注册小程序并进行学习呢？博主主要是参考了网上的一个方法，亲测可用。<a href="https://www.zhihu.com/question/52268924" target="_blank" rel="external">参考链接</a></p>
<h1 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h1><p>下面是官方文档给出的一个简易教程，这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。</p>
<p>注：以下教程默认注册账号、开发者、体验者都是使用管理员微信号。</p>
<h2 id="获取微信小程序的AppID"><a href="#获取微信小程序的AppID" class="headerlink" title="获取微信小程序的AppID"></a>获取微信小程序的AppID</h2><p>注册微信小程序并登录后，就可以在网站的“设置”-“开发者设置”中，查看到微信小程序的AppID了。</p>
<p><img src="/images/2016-12-9/1.png" alt=""></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们需要通过<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html?t=20161122" target="_blank" rel="external">开发者工具</a>，来完成小程序创建和代码编辑。</p>
<p>开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“firstProject”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。</p>
<p>为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。</p>
<p>项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。默认demo运行结果如下：</p>
<p><img src="/images/2016-12-9/2.PNG" alt=""></p>
<h2 id="项目结构简介"><a href="#项目结构简介" class="headerlink" title="项目结构简介"></a>项目结构简介</h2><p>点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p>
<p>下面简单介绍下这三个文件的功能。</p>
<ul>
<li><p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
<pre><code>//app.js
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync(&apos;logs&apos;) || []
    logs.unshift(Date.now())
    wx.setStorageSync(&apos;logs&apos;, logs)
  },
  getUserInfo:function(cb){
    var that = this
    if(this.globalData.userInfo){
      typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo
              typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)
            }
          })
        }
      })
    }
  },
  globalData:{
    userInfo:null
  }
})
</code></pre></li>
<li><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p>
<pre><code>{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;
  },
  &quot;tabBar&quot;: {
    &quot;position&quot;: &quot;bottom&quot;,
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre></li>
<li><p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p>
<pre><code>/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
} 
</code></pre></li>
</ul>
<p>在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成：</p>
<ul>
<li><p>.js后缀的文件是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
</li>
<li><p>.json后缀的文件是页面的配置文件，它是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p>
</li>
<li><p>.wxss后缀的是页面的样式表文件，它也是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
</li>
<li><p>.wxml后缀的文件是页面结构文件，用来搭建页面结构，绑定数据和交互处理函数。</p>
</li>
</ul>
<p>以上就是页面结构的简单介绍，在小程序开发框架一节中还会对这部分内容进行详细介绍。</p>
<h2 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h2><p>开发者工具左侧菜单栏选择”项目”，点击”预览”，扫码后即可在微信客户端中体验。</p>
<p><img src="/images/2016-12-9/3.PNG" alt=""></p>
<h1 id="小程序开发框架"><a href="#小程序开发框架" class="headerlink" title="小程序开发框架"></a>小程序开发框架</h1><p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p>
<p>框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p>
<p>下面将从目录结构、配置、逻辑层和视图层四个方面对小程序开发框架进行介绍。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。在上一节中我们已经对目录结构进行了简单的了解。</p>
<ul>
<li><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，分别是：app.js、app.json、app.wxss 。其中，app.js是小程序的脚本代码，用来控制小程序的逻辑，它是必要的；app.json是对整个小程序的全局配置，它也是必要的；app.wxss是整个小程序的公共样式表，它是非必要的。</p>
</li>
<li><p>一个小程序页面由四个文件组成，分别是：.js、.json、.wxss、.wxml四个文件。其中.js后缀的文件是页面脚本文件，用来控制页面逻辑；.json后缀的文件是页面配置文件；.wxss后缀的是页面样式表文件；.wxml后缀的文件是页面结构文件。.js文件和.wxml文件是必要的，另外两个文件是非必要的。</p>
</li>
</ul>
<p>注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p>app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>
<p>以下是一个包含了所有配置选项的简单配置app.json ：</p>
<pre><code>{
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/index&quot;
  ],
  &quot;window&quot;: {
    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
  },
  &quot;tabBar&quot;: {
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre><p>app.json 配置项列表</p>
<p><img src="/images/2016-12-9/4.PNG" alt=""></p>
<p>下面对这些配置项进行简单介绍。</p>
<h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h4><p>接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。</p>
<p>文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<p><img src="/images/2016-12-9/5.PNG" alt=""></p>
<h4 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h4><p>如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p>tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。</p>
<p>属性如下：</p>
<p><img src="/images/2016-12-9/6.PNG" alt=""></p>
<p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p>
<p><img src="/images/2016-12-9/7.PNG" alt=""></p>
<h4 id="networkTimeout"><a href="#networkTimeout" class="headerlink" title="networkTimeout"></a>networkTimeout</h4><p>可以设置各种网络请求的超时时间。</p>
<p>属性值如下：</p>
<p><img src="/images/2016-12-9/8.PNG" alt=""></p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发。可以帮助开发者快速定位一些常见的问题。</p>
<h3 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a>page.json</h3><p>每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。由于页面的配置只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，下面是一个简单的例子：</p>
<pre><code>{
  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,
  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,
  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,
  &quot;backgroundTextStyle&quot;: &quot;light&quot;
}
</code></pre><h2 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h2><p>小程序开发框架的逻辑层是由JavaScript编写，为了方便地开发小程序，在JavaScript的基础上做了一些修改，主要如下：</p>
<ul>
<li>增加App和Page方法，进行程序和页面注册；</li>
<li>增加getApp和getCurrentPages方法，分别用来获取App实例和当前页面栈；</li>
<li>由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等;</li>
<li>每个页面有独立的作用域，并提供模块化能力;</li>
<li>提供丰富的 API;</li>
<li>开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</li>
</ul>
<h3 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h3><p>App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/9.PNG" alt=""></p>
<p>注： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p>
<h3 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h3><p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/10.PNG" alt=""></p>
<h4 id="Page-prototype-setData"><a href="#Page-prototype-setData" class="headerlink" title="Page.prototype.setData()"></a>Page.prototype.setData()</h4><p>setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。</p>
<p>注意：</p>
<ol>
<li>直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。</li>
<li>单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</li>
</ol>
<p>setData 函数接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。</p>
<p>其中 key 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。</p>
<p>例子：</p>
<pre><code>&lt;!--index.wxml--&gt;
&lt;view&gt;{{text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt;
&lt;view&gt;{{array[0].text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInArray&quot;&gt; Change Array data &lt;/button&gt;
&lt;view&gt;{{object.text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInObject&quot;&gt; Change Object data &lt;/button&gt;
&lt;view&gt;{{newField.text}}&lt;/view&gt;
&lt;button bindtap=&quot;addNewField&quot;&gt; Add new data &lt;/button&gt;
//index.js
Page({
  data: {
    text: &apos;init data&apos;,
    array: [{text: &apos;init data&apos;}],
    object: {
      text: &apos;init data&apos;
    }
  },
  changeText: function() {
    // this.data.text = &apos;changed data&apos;  // bad, it can not work
    this.setData({
      text: &apos;changed data&apos;
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      &apos;array[0].text&apos;:&apos;changed data&apos;
    })
  },
  changeItemInObject: function(){
    this.setData({
      &apos;object.text&apos;: &apos;changed data&apos;
    });
  },
  addNewField: function() {
    this.setData({
      &apos;newField.text&apos;: &apos;new data&apos;
    })
  }
})
</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。</p>
<p>我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。</p>
<p>注：</p>
<ul>
<li>exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐使用 module.exports；</li>
<li>小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候可以拷贝出相关的代码到小程序的目录中。</li>
</ul>
<p>例子：</p>
<pre><code>// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
</code></pre><p>​在需要使用这些模块的文件中，使用 require(path) 将公共代码引入:</p>
<pre><code>var common = require(&apos;common.js&apos;)
Page({
  helloMINA: function() {
    common.sayHello(&apos;MINA&apos;)
  },
  goodbyeMINA: function() {
    common.sayGoodbye(&apos;MINA&apos;)
  }
})
</code></pre><h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。其中，WXML(WeiXin Markup language)用于描述页面的结构；WXSS(WeiXin Style Sheet)用于描述页面的样式；组件(Component)是视图的基本组成单元。</p>
<h3 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h3><p>WXML具有数据绑定、列表渲染、条件渲染、模板、事件和引用的功能。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>WXML 中的动态数据均来自对应 Page 的 data。</p>
<p>数据绑定使用Mustache语法（双大括号）将变量包起来，可以作用于：内容、组件属性、控制属性和关键字，其中后三者需要在双引号之内。</p>
<p>作用于关键字的例子：</p>
<pre><code>&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;    
</code></pre><ul>
<li><p>true：boolean 类型的 true，代表真值。</p>
</li>
<li><p>false： boolean 类型的 false，代表假值。</p>
</li>
</ul>
<p>注：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<p>还可在双大括号内进行简单的运算，支持的运算有：三元运算、算数运算、逻辑判断、字符串运算、数据路径运算等。</p>
<p>也可在双大括号内直接进行组合，构成新的对象或者数组。</p>
<p>具体的使用方法可参考官方文档给出的例子。</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>在框架中，我们用<code>wx:if</code>来判断是否需要渲染该代码块：</p>
<pre><code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;
</code></pre><p>也可以用<code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p>
<pre><code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre><p>因为<code>wx:if</code>是一个控制属性，需要将它添加到一个标签上。但是如果我们想一次性判断多个组件标签，我们可以使用一个<code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<pre><code>&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>注意：<code>&lt;block/&gt;</code>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>在组件上使用<code>wx:for</code>控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，使用<code>wx:for-index</code> 可以指定数组当前下标的变量名。</p>
<p>例子：</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}}: {{itemName.message}}
&lt;/view&gt;
</code></pre><p>类似block wx:if，也可以将wx:for用在<block>标签上，以渲染一个包含多节点的结构块。</block></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如<code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<p><code>wx:key</code> 的值以两种形式提供：</p>
<ul>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li>
</ul>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>如不提供 <code>wx:key</code>，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p>
<p>示例代码：</p>
<pre><code>&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; style=&quot;display: block;&quot;&gt; {{item.id}} &lt;/switch&gt;
&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;
&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;

&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; style=&quot;display: block;&quot;&gt; {{item}} &lt;/switch&gt;
&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add to the front &lt;/button&gt;

Page({
  data: {
    objectArray: [
      {id: 5, unique: &apos;unique_5&apos;},
      {id: 4, unique: &apos;unique_4&apos;},
      {id: 3, unique: &apos;unique_3&apos;},
      {id: 2, unique: &apos;unique_2&apos;},
      {id: 1, unique: &apos;unique_1&apos;},
      {id: 0, unique: &apos;unique_0&apos;},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i &lt; length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: &apos;unique_&apos; + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
</code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。模板拥有自己的作用域，只能使用data传入的数据。</p>
<p>例子：</p>
<pre><code>//定义模板
&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;

//使用模板
&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt;
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h5><p>事件分为冒泡事件和非冒泡事件：</p>
<ul>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ul>
<p>冒泡事件包括：</p>
<ul>
<li>touchstart：手指触摸动作开始；</li>
<li>touchmove：手指触摸后移动；</li>
<li>touchcancel：手指触摸动作被打断，如来电提醒，弹窗；</li>
<li>touchend：手指触摸动作结束；</li>
<li>tap：手指触摸后马上离开；</li>
<li>longtap：手指触摸后，超过350ms再离开。</li>
</ul>
<p>除以上之外的其他组件自定义事件如无特殊申明都是非冒泡事件。</p>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<ul>
<li>key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart；</li>
<li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li>
</ul>
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p>
<p><img src="/images/2016-12-9/11.PNG" alt=""></p>
<ul>
<li>type：事件的类型；</li>
<li>timeStamp：页面打开到触发事件所经过的毫秒数；</li>
<li><p>target：触发事件的源组件，包括：</p>
<ul>
<li>id：String，事件源组件的id；</li>
<li>tagName：String，当前组件的类型；</li>
<li>dataset：Object，事件源组件上由data-开头的自定义属性组成的集合。</li>
</ul>
</li>
<li><p>currentTarget：事件绑定的当前组件，属性同target；</p>
</li>
<li><p>touches：是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p>
<ul>
<li><p>Touch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>pageX, pageY：Number，距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴；</li>
<li>clientX, clientY：Number，距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
<li><p>CanvasTouch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>x, y：Number，距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
</ul>
</li>
<li><p>changedTouches：数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p>
</li>
<li><p>detail：自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息等，具体参见官方文档。</p>
</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>WXML 提供两种文件引用方式import和include。</p>
<ul>
<li>import：可以在该文件中使用目标文件定义的template。import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</li>
<li>include：include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置。</li>
</ul>
<h3 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h3><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。与 CSS 相比，WXSS扩展的特性有：尺寸单位，样式导入。</p>
<h4 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h4><ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li>
<li>rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。</li>
</ul>
<h4 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h4><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用;表示语句结束。</p>
<p>例子：</p>
<pre><code>/** common.wxss **/
.small-p {
  padding:5px;
}
/** app.wxss **/
@import &quot;common.wxss&quot;;
.middle-p {
  padding:15px;
}
</code></pre><p>WXSS目前支持的选择器有：<code>.class</code>、<code>#id</code>、<code>element</code>、<code>element, element</code>、<code>::after</code>、<code>::before</code>。</p>
<h2 id="组件和API"><a href="#组件和API" class="headerlink" title="组件和API"></a>组件和API</h2><p>框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<p>关于组件和API的详细内容参见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161122" target="_blank" rel="external">官方文档</a>.</p>
<p>官方文档阅读完后，就可以进行实际的开发了。对于一个新手来说，自己开发一个微信小程序可能有些难，不过网上有很多微信小程序的开发案例，可以在照着开发案例开发完一个微信小程序后，自己再独立的开发一个属性自己的微信小程序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[同一台电脑关联两个或多个Github账号]]></title>
      <url>https://fantasticzhang.github.io/2016/12/07/%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%85%B3%E8%81%94%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAGithub%E8%B4%A6%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>今天遇到了一个问题，我自己有一个github账号，项目组有一个github账号，然后我需要在我的电脑上同时管理这两个github账号的仓库，这时候该怎么办呢？在查阅了一些资料后，成功解决了这个问题，现将解决方案记录下来，以便日后查看。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>管理两个SSH key。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p><code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code></p>
<p>使用上面的命令在本地生成SSH key。由于需要管理两个github账号，因此在保存所生成的SSH key时需要注意两个key的文件名要有区别，比如我第一个账号生成的文件名为<code>id_rsa</code>，第二个账号生成的文件名为<code>id_rsa.gtensor</code>，这样就可以加以区分。</p>
<h3 id="将SSH-key添加到github"><a href="#将SSH-key添加到github" class="headerlink" title="将SSH key添加到github"></a>将SSH key添加到github</h3><p>将上一步所生成的两个SSH key分别添加到对应的github账户中。</p>
<h3 id="创建config文件"><a href="#创建config文件" class="headerlink" title="创建config文件"></a>创建config文件</h3><p><code>$touch config</code></p>
<p>在.ssh目录下，使用以上命令新建一个config文件，并在文件中添加如下内容：</p>
<pre><code>#default github
Host github.com
  HostName github.com
  IdentityFile ~/.ssh/id_rsa    
#gtensor github
Host github_gtensor
  HostName github.com  
  IdentityFile ~/.ssh/id_rsa.gtensor
</code></pre><p>其中，Host后面就是github账号的别名，这里就是为第二个github账号新增了一个别名<code>github_gtensor</code>，这样就将不同的账号区分开了。config文件的内容，需要根据自己的实际情况进行相应修改。</p>
<h3 id="将SSH-key添加到ssh-agent上"><a href="#将SSH-key添加到ssh-agent上" class="headerlink" title="将SSH key添加到ssh-agent上"></a>将SSH key添加到ssh-agent上</h3><p><code>$ ssh-add ~/.ssh/id_rsa.gtensor</code></p>
<p>在.ssh目录下，使用上面的命令将第二个账号的key添加到agent上。在执行以上命令时可能会出现错误提示： <code>Could not open a connection to your authentication agent</code>，此时需要执行以下命令开启ssh-agent服务：</p>
<p><code>$ eval $(ssh-agent)</code></p>
<h3 id="测试github连接是否成功"><a href="#测试github连接是否成功" class="headerlink" title="测试github连接是否成功"></a>测试github连接是否成功</h3><p><code>$ ssh –T git@github_gtensor</code></p>
<p>使用以上命令测试是否能连接github账户，其中<code>github_gtensor</code>即为我所设置的第二个github账号的别名，需要根据实际情况进行修改。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过以上配置，我们就可以通过使用github.com的别名github_gtensor来明确说明我们要使用id_rsa.gtensor的SSH key来连接github，即使用项目组的github账号进行操作。</p>
<p>例如，要克隆第二个github账号的远程仓库到本地，则原来的写法：</p>
<pre><code>$ git clone git@github.com: 第二个github账号的用户名/***.git
</code></pre><p>则现在的写法改为：</p>
<pre><code>$ git clone git@github_gtensor: 第二个github账号的用户名/***.git
</code></pre><p>我的环境是：win10 + git bash，测试成功，如有任何疑问，可给我留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Node的子进程调用脚本和系统命令]]></title>
      <url>https://fantasticzhang.github.io/2016/12/04/%E5%88%A9%E7%94%A8Node%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>child_process模块使得Node可以随意创建子进程。它提供了4个方法用于创建子进程。</p>
<ul>
<li>spawn(): 启动一个子进程来执行命令。</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile(): 启动一个子进程来执行可执行文件。</li>
<li>fork(): 与spawn()类似，不同点在于它创建Node的子进程只需要指定要执行的JavaScript文件模块即可。</li>
</ul>
<h2 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h2><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn()"></a>spawn()</h3><p><code>child_process.spawn(command[, args][, options])</code></p>
<p>spawn方法返回一个对象流，适合于输出大量数据然后需要读取的应用场合。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
free = shellProcess.spawn(&apos;free&apos;, [&apos;-m&apos;]);

// 捕获标准输出并将其打印到控制台
free.stdout.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard output:\n&apos; + data);
});

// 捕获标准错误输出并将其打印到控制台
free.stderr.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard error output:\n&apos; + data);
});

// 注册子进程关闭事件
free.on(&apos;exit&apos;, function (code) {
    console.log(&apos;child process exit ,exit:&apos; + code);
});
</code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><code>child_process.exec(command[, options][, callback])</code></p>
<p>exec方法会启动一个子进程来执行系统命令，并缓冲产生的数据，当子进程完成后回调函数就会被调用，可带有：</p>
<ul>
<li>当命令成功执行，缓冲的数据；</li>
<li>当命令执行失败，错误信息。</li>
</ul>
<p>exec方法并没有args参数选项，这是因为它允许我们执行多个命令，当使用exec方法时，如果需要传输参数到命令行，则参数应该作为整个命令字符串的一部分。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;chmod -R a+rwx start.sh&apos;, function(err,stdout,stderr){  //设置start.sh脚本的权限
       if(err) {
          return console.log(&apos;error:&apos;+stderr);
        }
   });
</code></pre><h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile()"></a>execFile()</h3><p><code>child_process.execFile(file[, args][, options][, callback])</code></p>
<p>当外部可执行文件存在时，该可执行文件将携带参数args被执行，当可执行文件退出时，回调函数被调用，回调函数带有子进程的标准输入输出，来自外部可执行文件的标准输出将被内部缓冲保存。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.execFile(&apos;./stop.sh&apos;, function(err, stdout, stderr){
     if(err) return console.error(err);
     console.log(&apos;stdout: &apos;+stdout);
});
</code></pre><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><code>fork(modulePath[,args][,options])</code></p>
<p>其中modulePath是一个字符串，用来指定JavaScript文件路径。</p>
<p>由于该方法还没有实际使用过，所以目前对它还不太了解，在日后充分了解后再进行补充。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>spawn()与exec()、execFile()的区别：</p>
<ul>
<li>exec()、execFile()都有一个回调函数获知子进程的状况；</li>
<li>exec()、execFile()创建时可指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</li>
</ul>
</li>
<li><p>exec()与execFile()的区别：exec()适合执行已有的命令，execFile()适合执行文件。</p>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="使用exec-方法执行sudo命令"><a href="#使用exec-方法执行sudo命令" class="headerlink" title="使用exec()方法执行sudo命令"></a>使用exec()方法执行sudo命令</h3><p>由于sudo命令需要输入密码，所以执行sudo命令与执行普通命令有所区别，下面是两种比较简单的解决方法：</p>
<h5 id="方法一：-S选项"><a href="#方法一：-S选项" class="headerlink" title="方法一： -S选项"></a>方法一： -S选项</h5><p>sudo命令有个-S选项，用于在需要输入密码的时候，读取密码。</p>
<p>假设密码为password，且假设要使用sudo命令执行脚本文件 tee_to_monitor.sh ，并向其传递参数 status ，那么，完整命令如下</p>
<p><code>echo &quot;password&quot; | sudo -S ./tee_to_monitor.sh status</code></p>
<p>相应的，node代码可以这样</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;echo &quot;zjl&quot; | sudo -S ./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>该方法比较简单，只需要使用<code>sudo npm start</code>启动应用即可，假设同样是上面的例子，此时node代码如下：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><p>也就是说，如果使用sudo命令启动应用，则该应用中就不需要再用sudo了。</p>
<h3 id="使用exec-方法实时获取输出"><a href="#使用exec-方法实时获取输出" class="headerlink" title="使用exec()方法实时获取输出"></a>使用exec()方法实时获取输出</h3><p>如果按照前面例子中的方法使用exec()，则子进程完成后回调函数才会被调用，如果想要实时获取输出，则可按照下面的例子使用exec()。</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
var child = shellProcess.exec(&apos;./start.sh&apos;);
// 捕获标准输出并使用socket通信传递数据
child.stdout.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 捕获标准错误输出并使用socket通信传递数据
child.stderr.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 注册子进程关闭事件
child.on(&apos;close&apos;,function(code){
  console.log(&apos;closing code: &apos;+code);
});
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的overflow属性和white-space属性]]></title>
      <url>https://fantasticzhang.github.io/2016/11/22/CSS%E7%9A%84overflow%E5%B1%9E%E6%80%A7%E5%92%8Cwhite-space%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>今天在写网页的时候用到了这两个属性，对于它们分别可能的取值及其含义一开始不是很确定，在查阅了网上的一些资料以及自己动手测试后，对它们每个可能取值的含义现已明确，因此记录下来方便之后查阅。</p>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p>overflow属性规定当内容溢出元素框时发生的事情。</p>
<h4 id="可能的取值"><a href="#可能的取值" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>visible：默认值。内容不会被修剪，会呈现在元素框之外。</li>
<li>hidden：内容会被修剪，并且其余内容是不可见的。</li>
<li>scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</li>
<li>auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</li>
<li>inherit：从父元素继承overflow属性的值。</li>
</ul>
<h4 id="scroll和auto的区别"><a href="#scroll和auto的区别" class="headerlink" title="scroll和auto的区别"></a>scroll和auto的区别</h4><ul>
<li>scroll：内容自动撑开容器的宽度不包括滚动条，相当于滚动条是一个和内容并列显示的组件。</li>
<li><p>auto：内容撑开容器的宽度包括滚动条。即 使用<code>white-space:nowrape;</code>撑开容器至正好显示所有内容时，如果有滚动条，则滚动条会覆盖在内容上方，导致内容宽度被再次缩小，然后出现省略号。由此推断渲染顺序：</p>
<p>  自适应宽度-&gt;根据高度显示滚动条-&gt;重新计算内部元素宽度。 </p>
</li>
</ul>
<p>综上，如果宽度是由内容自适应撑开的，则<code>overflow:auto;</code>带来的滚动条会占用内容的一部分宽度，导致内容显示不全。</p>
<h3 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h3><p>该属性声明建立布局过程中如何处理元素中的空白符。</p>
<h4 id="可能的取值-1"><a href="#可能的取值-1" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>normal：默认值。连续的空白符会被合并，换行符会被当做空白符来处理。填充line盒子时，必要的话会换行。</li>
<li>pre: 连续的空白符会被保留。在遇到换行符或者\<br\>元素时才会换行。</br\></li>
<li>nowrap: 连续的空白符会被合并，文本不会换行，会在同一行上继续，直到遇到\<br\>标签为止。</br\></li>
<li>pre-wrap：连续的空白符会被保留，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>pre-line：连续的空白符会被合并，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>inherit：从父元素继承white-space属性的值。</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="external">参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的定位技术]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>CSS使用top、left、right、bottom设置元素的二维（x轴和y轴）偏移量。使用z-index设置元素垂直于屏幕的方向，也就是“z轴”的偏移量。</p>
<p>CSS使用position选项来定义元素的定位属性，该选项有五个可选值：static、relative、absolute、fixed、inherit，默认值是static。inherit属性表示继承父元素的定位属性，因此只需掌握static、relative、absolute、fixed这四种定位属性的特性即可。</p>
<h3 id="相对定位技术"><a href="#相对定位技术" class="headerlink" title="相对定位技术"></a>相对定位技术</h3><p>相对定位即相对于文档流中的其他已定义的元素位置进行定位。relative和static都是相对于文档其他元素进行定位，都属于相对定位的范畴，区别在于一个可以控制位移，一个不能。</p>
<h4 id="static（默认值）"><a href="#static（默认值）" class="headerlink" title="static（默认值）"></a>static（默认值）</h4><p>如果使用默认值，在CSS中为元素定义top、left、right、 bottom、z-index都不会生效。也就是说，如果想设置元素的偏移量和z-index，必须为元素定义position属性（static除外）。</p>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p>relative的表现和默认值一样，只不过可以通过设置偏移量和z-index来控制相对于其正常位置进行的偏移。</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位的元素有以下几个特点：</p>
<ul>
<li>块级元素的宽度在未定义时不再为100%，而是根据内容自动调整。</li>
<li>在不定义z-index的情况下，absolute元素会覆盖在其他元素之上。</li>
<li>它会脱离正常的文档流，不再占据空间，类似于浮动后的效果。</li>
</ul>
<p>absolute和fixed都属于绝对定位的范畴，都遵循以上3个特点。</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p>absolute是相对上一个不为static的父元素进行绝对定位。也就是说，如果不指定父元素的position，absolute将相对于整个html文档进行绝对定位。</p>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>fixed是相对于浏览器窗口进行定位。也就是说，不论网页如何滚动，该元素始终停留在屏幕的某个位置上。例如：我们希望侧边控制栏始终对用户可见，就可以使用<code>position:fixed</code>来进行定位。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的优先级]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>如何确定CSS的优先级？首先要引入一个机制，分别用4个数字（a, b, c, d）表示优先级组合，它们的意思分别是：    </p>
<ul>
<li>第一个数字（a）表示style属性，优先级最高。由于一般都是class样式，所以该值一般都是0。  </li>
<li>第二个数字（b）是该CSS选择器上的id数量的总和，一般都是1个。</li>
<li>第三个数字（c）是用在该CSS选择器上的其他属性CSS选择器以及伪类的总和。这里包括class（比如 .btn）和属性选择器（比如 li[id=red]）。</li>
<li>第四个数字（d）计算元素（比如 table、p、div等）和伪元素（比如 first-child）。</li>
</ul>
<p>注：</p>
<ul>
<li>通用CSS选择器（*）是0优先级。</li>
<li>如果两个CSS选择器有同样的优先级，则在样式表中后面的那个起作用。</li>
</ul>
<p>几个例子：</p>
<ul>
<li>选择器：<code>#menu h2</code>， 优先级：0,1,0,1。   </li>
<li>选择器： <code>#leftbar li:first-child</code>，优先级： 0,1,0,2。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[又长大一岁啦]]></title>
      <url>https://fantasticzhang.github.io/2016/11/14/%E5%8F%88%E9%95%BF%E5%A4%A7%E4%B8%80%E5%B2%81%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>今天我又长大一岁啦~一大早就收到了爸爸妈妈的祝福和红包，以及好朋友的祝福，真的好开心~因此，想要简单记录一下这开心的一天。但由于博主经验不足图片格式还不太会调，可能看起来不太美观，以后会改正。</p>
<h3 id="美好的一天"><a href="#美好的一天" class="headerlink" title="美好的一天"></a>美好的一天</h3><p><img src="/images/2016-11-14/1.jpg" alt=""></p>
<p>闺蜜送的生日礼物，真的好喜欢，每一年的生日都给我好大的惊喜，也希望之后的每个生日都有你的陪伴。</p>
<p><img src="/images/2016-11-14/2.jpg" alt=""></p>
<p>早晨来到实验室就收到了学弟送的书，真的好感动~而且特意为我选了悬疑推理类的书，很符合我的口味，嘿嘿。真的很开心今年能认识你啦~</p>
<p><img src="/images/2016-11-14/3.jpg" alt=""></p>
<p>有个姐姐就是好，带我来吃海底捞啦，哈哈。一直听说海底捞的服务特别好，今天算是见识到了，店员知道今天我过生日，特意为我唱了生日快乐歌，而且还送了我礼物，真的好棒！对了，还可以免费做美甲，所以吃完饭后就做了一个，好开心。</p>
<p><img src="/images/2016-11-14/4.jpg" alt=""></p>
<p>店员知道今天我过生日，特意为我做了长寿面~</p>
<p><img src="/images/2016-11-14/5.jpg" alt=""></p>
<p>店家送给我的生日礼物，服务真的好周到。</p>
<p><img src="/images/2016-11-14/6.jpg" alt=""></p>
<p>最后，许下一个生日愿望，希望能实现~</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>今天一路上还收到了好多陌生人的祝福，真的好开心。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>https://fantasticzhang.github.io/2016/11/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>终于有自己的博客啦~</p>
<p>其实一直想要建一个属于自己的博客，用来记录自己日常生活中的点点滴滴、学习过程中整理的笔记以及一些技术感悟，记录自己读过的一些论文等，但由于自己的拖延症，一直没有弄:-P。终于，今天我也有了属于自己的博客啦，也希望自己之后能克服懒惰，经常更新。日积月累，总会有收获的。</p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>https://fantasticzhang.github.io/about/index.html</url>
      <content type="html"><![CDATA[<p>目前在北京读研，平时的工作主要是前端相关的。对前端技术也很感兴趣，处于边学边实践的阶段。欢迎志同道合的朋友与我多多交流，也期待大神的指点~</p>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://fantasticzhang.github.io/photos/output.json</url>
      <content type="html"><![CDATA[["IMG_20161005_164625.jpg","IMG_20161005_165430.jpg","IMG_20161005_165817.jpg","IMG_20161005_172129.jpg","IMG_20161006_130939.jpg","IMG_20161006_132426.jpg","IMG_20161006_132836.jpg","IMG_20161116_141430.jpg","IMG_20161116_150715.jpg","IMG_20161116_155406.jpg","IMG_20161118_124950.jpg","mmexport1479264425744.jpg","mmexport1479264435676.jpg","wen.jpg"]]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[学习过程中实现的实例demo]]></title>
      <url>https://fantasticzhang.github.io/demo/index.html</url>
      <content type="html"><![CDATA[<p>做前端和后台不太一样，总觉得只有自己动手做出来一些能看得见的东西，才会有一些成就感~</p>
<a id="more"></a>
<h2 id="实例一：Canvas小动画"><a href="#实例一：Canvas小动画" class="headerlink" title="实例一：Canvas小动画"></a>实例一：Canvas小动画</h2><p>使用html5的Canvas实现的一个小动画：模拟太空中一个行星群的运动。</p>
<ul>
<li>demo：<a href="/2017/03/10/实例demo之Canvas小动画/" title="实例demo之Canvas小动画">实例demo之Canvas小动画</a></li>
<li>源码：<a href="https://github.com/fantasticZhang/Asteroids" target="_blank" rel="external">View on GitHub</a></li>
</ul>
<h2 id="实例二：Fido-Bowling游戏"><a href="#实例二：Fido-Bowling游戏" class="headerlink" title="实例二：Fido Bowling游戏"></a>实例二：Fido Bowling游戏</h2><p>基于Canvas开发的一个小游戏——太空保龄球。将源码下载下来即可运行，无需安装任何插件。</p>
<ul>
<li>demo：<a href="/2017/03/12/实例demo之FidoBowling小游戏/" title="实例demo之FidoBowling小游戏">实例demo之FidoBowling小游戏</a></li>
<li>源码：<a href="https://github.com/fantasticZhang/FidoBowling" target="_blank" rel="external">View on GitHub</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[相册]]></title>
      <url>https://fantasticzhang.github.io/photos/index.html</url>
      <content type="html"><![CDATA[<p><link type="text/css" href="/css/photo.css" rel="stylesheet"></p>
<link type="text/css" href="/fancybox/jquery.fancybox.css" rel="stylesheet">

<div class="photos"><br>  <section class="archives album"><br>    <ul class="img-box-ul"></ul><br>  </section><br></div>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://fantasticzhang.github.io/photos/tool.js</url>
      <content type="html"><![CDATA["use strict";
    const fs = require("fs");
    const path = "../../photos";

    fs.readdir(path, function (err, files) {
        if (err) {
            return;
        }
        let arr = [];
        (function iterator(index) {
            if (index == files.length) {
                fs.writeFile("output.json", JSON.stringify(arr, null, "\t"));
                return;
            }

            fs.stat(path + "/" + files[index], function (err, stats) {
                if (err) {
                    return;
                }
                if (stats.isFile()) {
                    arr.push(files[index]);
                }
                iterator(index + 1);
            })
        }(0));
    });
]]></content>
    </entry>
    
  
</search>
