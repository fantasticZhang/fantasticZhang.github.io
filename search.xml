<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[纯CSS绘制各种角度的三角形]]></title>
      <url>https://fantasticzhang.github.io/2017/02/23/%E7%BA%AFCSS%E7%BB%98%E5%88%B6%E5%90%84%E7%A7%8D%E8%A7%92%E5%BA%A6%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      <content type="html"><![CDATA[<p>以下是纯CSS绘制各种角度的三角形的方法。</p>
<h2 id="Triangle-Up"><a href="#Triangle-Up" class="headerlink" title="Triangle Up"></a>Triangle Up</h2><p>代码：</p>
<pre><code>#triangle-up{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-left:40px solid transparent;
    border-right:40px solid transparent;
}

&lt;h3&gt;Triangle Up&lt;/h3&gt;
&lt;div id=&quot;triangle-up&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-up.PNG" alt=""></p>
<h2 id="Triangle-Down"><a href="#Triangle-Down" class="headerlink" title="Triangle Down"></a>Triangle Down</h2><p>代码：</p>
<pre><code>#triangle-bottom{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-left:40px solid transparent;
    border-right:40px solid transparent;
}

&lt;h3&gt;Triangle Down&lt;/h3&gt;
&lt;div id=&quot;triangle-bottom&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottom.PNG" alt=""></p>
<h2 id="Triangle-Left"><a href="#Triangle-Left" class="headerlink" title="Triangle Left"></a>Triangle Left</h2><p>代码：</p>
<pre><code>#triangle-left{
    width:0;
    height:0;
    border-right: 80px solid #00ffff;
    border-top:40px solid transparent;
    border-bottom:40px solid transparent;
}
&lt;h3&gt;Triangle Left&lt;/h3&gt;
&lt;div id=&quot;triangle-left&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-left.PNG" alt=""></p>
<h2 id="Triangle-Right"><a href="#Triangle-Right" class="headerlink" title="Triangle Right"></a>Triangle Right</h2><p>代码：</p>
<pre><code>#triangle-right{
    width:0;
    height:0;
    border-left: 80px solid #00ffff;
    border-top:40px solid transparent;
    border-bottom:40px solid transparent;
}
&lt;h3&gt;Triangle Right&lt;/h3&gt;
&lt;div id=&quot;triangle-right&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-right.PNG" alt=""></p>
<h2 id="Triangle-Top-Left"><a href="#Triangle-Top-Left" class="headerlink" title="Triangle Top Left"></a>Triangle Top Left</h2><p>代码：</p>
<pre><code>#triangle-topleft{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-right:80px solid transparent;
}
&lt;h3&gt;Triangle Top Left&lt;/h3&gt;
&lt;div id=&quot;triangle-topleft&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-topleft.PNG" alt=""></p>
<h2 id="Triangle-Top-Right"><a href="#Triangle-Top-Right" class="headerlink" title="Triangle Top Right"></a>Triangle Top Right</h2><p>代码：</p>
<pre><code>#triangle-topright{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-left:80px solid transparent;
}
&lt;h3&gt;Triangle Top Right&lt;/h3&gt;
&lt;div id=&quot;triangle-topright&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-topright.PNG" alt=""></p>
<h2 id="Triangle-Bottom-Left"><a href="#Triangle-Bottom-Left" class="headerlink" title="Triangle Bottom Left"></a>Triangle Bottom Left</h2><p>代码：</p>
<pre><code>#triangle-bottomleft{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-right:80px solid transparent;
}
&lt;h3&gt;Triangle Bottom Left&lt;/h3&gt;
&lt;div id=&quot;triangle-bottomleft&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottomleft.PNG" alt=""></p>
<h2 id="Triangle-Bottom-Right"><a href="#Triangle-Bottom-Right" class="headerlink" title="Triangle Bottom Right"></a>Triangle Bottom Right</h2><p>代码：</p>
<pre><code>#triangle-bottomright{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-left:80px solid transparent;
}
&lt;h3&gt;Triangle Bottom Right&lt;/h3&gt;
&lt;div id=&quot;triangle-bottomright&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottomright.PNG" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo主题中加入相册功能]]></title>
      <url>https://fantasticzhang.github.io/2017/02/21/hexo%E4%B8%BB%E9%A2%98%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>前段时间一个朋友问我：怎么给自己的博客加入相册功能？我还真被问住了，因为搭建博客的初衷是写一些文字性的东西，并没有考虑过“相册”这回事。但被朋友问到后，仔细想了想，给博客加入相册功能还是挺不错的，可以和大家分享一些自己喜欢的图片。于是参考了网上的相关资料，最终实现了一个简单的相册功能。现把实现过程记录下来，以供大家参考。</p>
<p>主要是参考了<a href="http://www.cnblogs.com/xljzlw/p/5137622.html" target="_blank" rel="external">这篇文章</a>,但这篇文章的作者使用的是<code>yilia</code>主题，该主题已实现了相册功能。而我使用的是<a href="https://github.com/hsihohuang/kiddochan" target="_blank" rel="external">kiddochan</a>主题，这个主题并没有实现相册功能。因此，我的实现过程和我参考的那篇文章也略有不同，但整体流程还是类似的。</p>
<h2 id="新建相册页面"><a href="#新建相册页面" class="headerlink" title="新建相册页面"></a>新建相册页面</h2><p><code>hexo new page “photos”</code></p>
<p>执行上面的命令，会在<code>source</code>文件夹中生成一个<code>photo</code>文件夹，打开<code>photo</code>文件夹中的<code>index.md</code>文件，修改内容如下：</p>
<pre><code>---
title: 相册
---

&lt;link type=&quot;text/css&quot; href=&quot;/css/photo.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;link type=&quot;text/css&quot; href=&quot;/fancybox/jquery.fancybox.css&quot; rel=&quot;stylesheet&quot;&gt;

&lt;div class=&quot;photos&quot;&gt;
  &lt;section class=&quot;archives album&quot;&gt;
    &lt;ul class=&quot;img-box-ul&quot;&gt;&lt;/ul&gt;
  &lt;/section&gt;
&lt;/div&gt;
</code></pre><p>其中，’photo.css’用来控制相册样式，由于我使用的主题并没有实现相册功能，因此需要另写一个样式来控制相册的展示。</p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>在主题的配置文件<code>_config.yml</code>的menu下添加一个相册的菜单：</p>
<pre><code>menu:
  主页: /
  归档: /archives
  关于: /about
  相册: /photos
</code></pre><h2 id="存放图片"><a href="#存放图片" class="headerlink" title="存放图片"></a>存放图片</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先图片不能放在<code>source</code>文件夹中，因为需要编译成静态文件，非常慢。那么该放到哪里好呢？</p>
<p>在使用hexo搭建博客时，我们都会在github上会建立一个名为<code>username.github.io</code>的仓库，而且仓库只存储了整个项目的一部分。所以，一般我们都会在github上另建一个仓库，用来存储整个博客项目的文件对博客进行备份，这样就能在不同的电脑上写博客了。因此，我们可以在根目录下新建一个<code>photos</code>文件夹用来存放相册需要展示的图片文件，这样图片的数量就不受限制了。</p>
<h3 id="存放图片-1"><a href="#存放图片-1" class="headerlink" title="存放图片"></a>存放图片</h3><p>在博客的根目录下新建一个<code>photos</code>的文件夹，里面存放你想要展示的图片文件。然后把整个博客项目部署到github上，才能访问到图片的线上地址。</p>
<h2 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h2><p>那么多图片的文件名该怎么获取呢？由于原生<code>js</code>不能很好的处理文件，因此不能直接在js文件中获取图片的文件名。但我们可以新建一个基于nodejs的js文件用来读取所有图片，并把所有的图片名称放在一个json文件中供相册页面的js文件使用。</p>
<p>在<code>source\photo</code>文件夹中新建一个<code>tool.js</code>文件，内容如下：</p>
<pre><code>&quot;use strict&quot;;
    const fs = require(&quot;fs&quot;);
    const path = &quot;../../photos&quot;;

    fs.readdir(path, function (err, files) {
        if (err) {
            return;
        }
        let arr = [];
        (function iterator(index) {
            if (index == files.length) {
                fs.writeFile(&quot;output.json&quot;, JSON.stringify(arr, null, &quot;\t&quot;));
                return;
            }

            fs.stat(path + &quot;/&quot; + files[index], function (err, stats) {
                if (err) {
                    return;
                }
                if (stats.isFile()) {
                    arr.push(files[index]);
                }
                iterator(index + 1);
            })
        }(0));
    });
</code></pre><p>通过<code>node tool.js</code>命令运行该文件，会在<code>source\photos</code>下生成一个<code>output.json</code>文件:</p>
<pre><code>[
    &quot;IMG_20161005_164625.jpg&quot;,
    &quot;IMG_20161005_165430.jpg&quot;,
    &quot;IMG_20161005_165817.jpg&quot;,
    &quot;IMG_20161005_172129.jpg&quot;,
    &quot;IMG_20161006_130939.jpg&quot;,
    &quot;IMG_20161006_132426.jpg&quot;,
    &quot;IMG_20161006_132836.jpg&quot;,
    &quot;IMG_20161116_141430.jpg&quot;,
    &quot;IMG_20161116_150715.jpg&quot;,
    &quot;IMG_20161116_155406.jpg&quot;,
    &quot;IMG_20161118_124950.jpg&quot;,
    &quot;mmexport1479264425744.jpg&quot;,
    &quot;mmexport1479264435676.jpg&quot;
]
</code></pre><p>之后每次添加了新的图片，都要运行<code>node tool.js</code>来更新<code>output.json</code>文件的内容。</p>
<h2 id="生成相册页的代码"><a href="#生成相册页的代码" class="headerlink" title="生成相册页的代码"></a>生成相册页的代码</h2><p>在<code>myBlog\themes\kiddochan\source\js</code>（myBlog为我的博客根目录，kiddochan为我使用的主题，替换成相应的即可）文件夹下新建一个photo.js，代码如下：</p>
<pre><code>//相册功能 2017-02-20 add
var page = 1;
var offset = 20;

function photoShow(page ,data){
  var begin = (page - 1) * offset;
  var end = page * offset;
  if (begin &gt;= data.length) return;
  var html, li = &quot;&quot;;
  for (var i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) {
      li += &apos;&lt;li&gt;&lt;div class=&quot;img-box&quot;&gt;&apos; +
          &apos;&lt;a class=&quot;img-bg&quot; rel=&quot;example_group&quot; href=&quot;https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&apos; + data[i] + &apos;?raw=true&quot;&gt;&lt;/a&gt;&apos; +
          &apos;&lt;img lazy-src=&quot;https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&apos; + data[i] + &apos;?raw=true&quot; /&gt;&apos; +
          &apos;&lt;/li&gt;&apos;;
  }

  $(&quot;.img-box-ul&quot;).append(li);
  $(&quot;.img-box-ul&quot;).lazyload();
  $(&quot;a[rel=example_group]&quot;).fancybox();
}

function photoScroll(data){
  $(window).scroll(function() {
      var windowPageYOffset = window.pageYOffset;
      var windowPageYOffsetAddHeight = windowPageYOffset + window.innerHeight;
    //  var sensitivity = 0;
      var offsetTop = $(&quot;.photos&quot;).offset().top + $(&quot;.photos&quot;).height();
      if (offsetTop &gt;= windowPageYOffset &amp;&amp; offsetTop &lt; windowPageYOffsetAddHeight) {
          photoShow(++page, data);
      }
  })
}

var photoInit = function() {
    $.getJSON(&quot;/photos/output.json&quot;, function (data) {
        photoShow(page, data);

        photoScroll(data);
    });
}
</code></pre><p>  其中，<code>https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&#39; + data[i] + &#39;?raw=true&quot;</code>是上传至github的图片链接。</p>
<p>  该文件读取json文件，将图片的线上url拼接起来渲染在相册页面上。</p>
<p>  在<code>myBlog\themes\layout\_patial\after_footer.ejs</code>文件中加入了如下代码：</p>
<pre><code>&lt;!--相冊功能--&gt;
&lt;script src=&quot;/js/jquery.lazyload.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/photo.js&quot;&gt;&lt;/script&gt;

$(document).ready(function(){
  //相册功能 2017-02-20 add
  if($(&quot;.photos&quot;).length) {
      photoInit();
   }
});
</code></pre><p>根据实际所使用的主题，添加到相应位置即可。</p>
<p>最后，运行<code>hexo g</code>、<code>hexo d</code>等相应命令，相册功能就实现了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grid布局]]></title>
      <url>https://fantasticzhang.github.io/2017/02/18/Grid%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Grid布局（又称网格布局）是指：以规则的网格阵列来指导和规范网页中的版面布局以及信息分布。</p>
<h1 id="CSS-Grid布局"><a href="#CSS-Grid布局" class="headerlink" title="CSS Grid布局"></a>CSS Grid布局</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSS Grid布局是一种二维网格布局系统，旨在彻底改变基于网格的用户界面的设计。目前，CSS Grid布局仅仅是一个W3C工作草案，因此还没有被任何浏览器默认支持。在Chrome中体验Grid布局的方法：打来浏览器并输入chrome://flags，找到”experimental web platform features”（实验性网络平台功能）,启用并重启浏览器。Opera和Firefox也支持CSS Grid布局，具体启用方法可参考相关网络资料。</p>
<h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><p>在整个Grid布局中常用到的术语如下：</p>
<ul>
<li>网格容器（Grid Container）：所有网格项的父元素；</li>
<li>网格项（Grid Item）：网格容器的直接子元素；</li>
<li>网格线（Grid Line）：组成网格的分界线；</li>
<li>网格轨道（Grid Track）：两个相邻的网格线之间为网格轨道，即网格的行或列；</li>
<li>网格单元（Grid Cell）：网格轨道相交的区域；</li>
<li>网格区域（Grid Area）：由任意数量的网格单元组成；</li>
<li>间距（Gutters）：两个网格轨道之间的区域。</li>
</ul>
<h2 id="设置在网格容器上的属性"><a href="#设置在网格容器上的属性" class="headerlink" title="设置在网格容器上的属性"></a>设置在网格容器上的属性</h2><ul>
<li>display：属性值有：grid、inline-grid、subgrid；</li>
<li>grid-template-columns：用一组值来设置列的大小；</li>
<li>grid-template-rows：用一组值来设置行的大小；</li>
<li>grid-template-areas：通过获取网格项中的grid-area属性值来定义网格模板，用’.’代表空网格单元；</li>
<li>grid-column-gap：网格单元列间距；</li>
<li>grid-row-gap：网格单元行间距；</li>
<li>grid-gap：网格单元间距，是grid-column-gap和grid-row-gap的简写；</li>
<li>justify-items：垂直于列网格线对齐，适用于网格容器中的所有网格项。属性值有：start、end、center、stretch；</li>
<li>align-items：垂直于行网格线对齐，适用于网格容器中的所有网格项。属性值同上；</li>
<li>justify-content：在总网格区域大小小于网格容器时，使用该属性设置网格的对齐方式（垂直于列网格线对齐）。属性值有：start、end、center、stretch、space-around、space-between、space-evenly；</li>
<li>align-content：在总网格区域大小小于网格容器时，使用该属性设置网格的对齐方式（垂直于行网格线对齐）。属性值同上；</li>
<li>grid-auto-columns：设置隐式网格轨道（列）的大小，当定位网格项超出网格容器范围时，将自动创建隐式网格轨道；</li>
<li>grid-auto-rows：设置隐式网格轨道（行）的大小；</li>
<li>grid-auto-flow：在没有设置网格项的位置时，这个属性控制网格项的排列方式。属性值有：row、column、dense；</li>
<li>grid：一种简写形式，设置网格容器所有属性。属性值有：none，(grid-template-rows) / (grid-template-columns)，(grid-auto-flow) [(grid-auto-rows) [ /(grid-auto-columns)]]。</li>
</ul>
<h2 id="设置在网格项上的属性"><a href="#设置在网格项上的属性" class="headerlink" title="设置在网格项上的属性"></a>设置在网格项上的属性</h2><ul>
<li>grid-column-start：通过网格线来定义网格项的列开始位置；</li>
<li>grid-column-end：通过网格线来定义网格项的列结束位置；</li>
<li>grid-row-start：通过网格线来定义网格项的行开始位置；</li>
<li>grid-row-end：通过网格线来定义网格项的行结束位置；</li>
<li>grid-column：是 grid-column-start、grid-column-end的简写；</li>
<li>grid-row：是 grid-row-start、grid-row-end 的简写；</li>
<li>grid-area：定义网格项名字，以便创建模块；</li>
<li>justify-self：定义单个网格项垂直于列网格线的对齐方式；</li>
<li>align-self：定义单个网格项垂直于行网格线的对齐方式；</li>
</ul>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>代码：</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .grid_1{
            display: grid;
            grid-template-columns: 150px 20px 150px 20px 150px;
            grid-template-rows: auto 20px auto 20px auto;
        }
        .item1{
            grid-column: 1;
            grid-row: 1;
            background: blueviolet;
        }
        .item2{
            grid-column: 3;
            grid-row: 1;
            background: chocolate;
        }
        .item3{
            grid-column: 5;
            grid-row: 1;
            background: #e2e242;
        }
        .item4{
            grid-column: 1;
            grid-row: 3;
            background: #42e2b9;
        }
        .item5{
            grid-column: 3;
            grid-row: 3;
            background: #e28cc8;
        }
        .item6{
            grid-column: 5;
            grid-row: 3;
            background: #2be24c;
        }
        .item7{
            grid-column: 1;
            grid-row: 5;
            background: #c2e2da;
        }
        .item8{
            grid-column: 3;
            grid-row: 5;
            background: blueviolet;
        }
        .item9{
            grid-column: 5;
            grid-row: 5;
            background: #e2203f;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;section class=&quot;grid_1&quot;&gt;
    &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt;
    &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt;
    &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt;
    &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;
    &lt;div class=&quot;item7&quot;&gt;7&lt;/div&gt;
    &lt;div class=&quot;item8&quot;&gt;8&lt;/div&gt;
    &lt;div class=&quot;item9&quot;&gt;9&lt;/div&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>效果图：</p>
<p><img src="/images/2017-02-18/Grid.PNG" alt=""></p>
<p>以上只是对CSS Grid布局的简单介绍，比较详细的介绍可参考<a href="http://peale.cn/2016/12/08/2016_12_8_grid/#more" target="_blank" rel="external">这篇文章</a></p>
<h1 id="Bootstrap对Grid布局的实现"><a href="#Bootstrap对Grid布局的实现" class="headerlink" title="Bootstrap对Grid布局的实现"></a>Bootstrap对Grid布局的实现</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过定义容器大小，平分12份，再调整内外边距，最后再结合媒体查询，就制作出了强大的响应式的栅格系统。</p>
<p>Bootstrap为不同的屏幕尺寸提供了不同的栅格样式。Bootstrap3中通过媒体查询@media定义了四种屏幕类型：超小屏幕设备手机（<768px，xs）、小屏幕设备平板（>= 768px，sm）、中等屏幕设备桌面（&gt;=992px，md）、大屏幕设备桌面（&gt;=1200px，lg）。针对四种不同的屏幕大小分别对container样式固定了尺寸（自动、750px、970px、1170px），例如：</768px，xs）、小屏幕设备平板（></p>
<pre><code>@media (min-width:1200){
  .container{ width:1170px; }
}
</code></pre><h2 id="Bootstrap中栅格系统的主要工作原理"><a href="#Bootstrap中栅格系统的主要工作原理" class="headerlink" title="Bootstrap中栅格系统的主要工作原理"></a>Bootstrap中栅格系统的主要工作原理</h2><ul>
<li>一行数据（row）必须包含在.container中，以便为其赋予合适的对齐方式和内边距（padding）。</li>
<li>使用行（row）在水平方向创建一组列（column）。</li>
<li>具体内容应当放置于列（column）内，而且只有列（column）可以作为行（row）的直接子元素。</li>
<li>内置了许多样式，可以使用像.row和.col-xs-5这样的样式来快速创建栅格布局。</li>
<li>通过设置padding从而创建列之间的间隔。然后通过为第一列和最后一列设置负的margin从而抵消掉padding的影响。</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围的。</li>
</ul>
<h2 id="涉及的CSS特性"><a href="#涉及的CSS特性" class="headerlink" title="涉及的CSS特性"></a>涉及的CSS特性</h2><ul>
<li>列组合涉及两个CSS特性：左浮动和宽度百分比；</li>
<li>列偏移（offset）涉及一个CSS特性：margin-left；</li>
<li>列排序（pull、push）涉及三个CSS特性：左浮动、left、right。</li>
</ul>
<p>此外，可使用Bootstrap提供的clearfix样式来清除浮动。</p>
<p>例：</p>
<pre><code>&lt;div class=”row”&gt;
    &lt;div class=”col-xs-6 col-sm-3”&gt;div1：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div2：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”clearfix visible-xs”&gt; &lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div3：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div4：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;/div&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js修改url中某个指定参数的值]]></title>
      <url>https://fantasticzhang.github.io/2017/01/16/js%E4%BF%AE%E6%94%B9url%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location对象很特别，因为它既是window对象的属性，也是document对象的属性；也就是说，window.location和document.location引用的是同一个对象。location对象将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下面是location对象的所有属性。</p>
<ul>
<li>hash：返回URL中的hash（#号后跟的零或多个字符），如果URL中不包含散列，则返回空字符串；例: “#contents”</li>
<li>host：返回服务器名称和端口号（如果有）；例：”www.baidu.com:80”</li>
<li>hostname：返回不带端口号的服务器名称；例：”www.baidu.com”</li>
<li>href：返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值；例：”<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>“</li>
<li>pathname：返回URL中的目录和（或）文件名；例：”/WilleyCDA/“</li>
<li>port：返回URL中指定的端口号。如果没有则返回空串。例：”8080”</li>
<li>portocol：返回页面使用的协议，通常是http:或https:  例：”http:”</li>
<li>search：返回URL的查询字符串。这个字符串以问好开头；例：”?q=javascript”</li>
</ul>
<h2 id="js修改url中某个指定参数的值"><a href="#js修改url中某个指定参数的值" class="headerlink" title="js修改url中某个指定参数的值"></a>js修改url中某个指定参数的值</h2><p>下面是一个利用javascript修改url中某个参数的值的办法，可以直接修改当前url中的某个参数的值而不会导致这个url中同一个参数存在多个值的情况。</p>
<pre><code>/*
* url 目标url
* arg 需要替换的参数名称
* arg_val 替换后的参数的值
* return url 参数替换后的url
*/
function changeURLArg(url,arg,arg_val){
    var pattern=arg+&apos;=([^&amp;]*)&apos;;
    var replaceText=arg+&apos;=&apos;+arg_val;
    if(url.match(pattern)){
        var tmp=&apos;/(&apos;+ arg+&apos;=)([^&amp;]*)/gi&apos;;
        tmp=url.replace(eval(tmp),replaceText);
        return tmp;
    }else{
        if(url.match(&apos;[\?]&apos;)){
            return url+&apos;&amp;&apos;+replaceText;
        }else{
            return url+&apos;?&apos;+replaceText;
        }
    }
    return url+&apos;\n&apos;+arg+&apos;\n&apos;+arg_val;
}
</code></pre><p>使用方法：</p>
<pre><code>changeURLArg(&apos;http://www.daimajiayuan.com/test.php?class_id=3&amp;id=2&apos;,&apos;class_id&apos;,4);
</code></pre><p>结果：<a href="http://www.daimajiayuan.com/test.php?class_id=4&amp;id=2" target="_blank" rel="external">http://www.daimajiayuan.com/test.php?class_id=4&amp;id=2</a></p>
<p><a href="http://www.daimajiayuan.com/sitejs-17226-1.html" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转载】2016年JavaScript回顾]]></title>
      <url>https://fantasticzhang.github.io/2016/12/30/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%912016%E5%B9%B4JavaScript%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<p>2016年是值得纪念、奇怪的、有点高兴也有点可怕的一年，这一切取决于你怎么看。跟其他事件相比仅仅专注于javascript可能看起来没什么大不了，但对于每个web开发人员来说javascript都是工作生活中非常大的一部分。</p>
<p><a href="http://www.modulecounts.com/" target="_blank" rel="external">JavaScript的流行继续激增</a>。不是每个人都喜欢这种语言，但是你很少听到十年前的嘲笑意见。就个人而言，我一直喜欢JavaScript，即使在早期，那些令人沮丧的年代。只要从C++、Java或PHP方向接近它的人首先都会感到困惑：JavaScript看起来很熟悉，但又不是。克服你的假设，你会喜欢它简单的优雅，实用性和灵活性。（比如：日期处理仍然是一个噩梦！)</p>
<p>JavaScript在5月份庆祝了它21岁的生日，让我们回顾下它成熟发展的这第一年…</p>
<h2 id="ECMAScript发展"><a href="#ECMAScript发展" class="headerlink" title="ECMAScript发展"></a>ECMAScript发展</h2><p>ES6/2015是语言自诞生以来最重要的更新。规范花了七年才完成，但浏览器和运行时终于开始支持箭头函数，let、const，这带来了更多的乐趣。<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external"> ES6兼容性表正在变成一个光辉的绿色</a>。</p>
<p>如果你需要支持旧的浏览器，全面切换到ES6也许会有一点早。对于旧的浏览器，一年多前发布的项目。您可以用ES6到ES5编译器（如Babel），但是开发非常复杂，需要引入额外的构建步骤。</p>
<p>ES7/2016是更多的革命。一个令人兴奋的新功能是async，它允许异步代码以同步方式写入，而没有回调或Promises（继续困惑我）的语法复杂性。</p>
<h2 id="渐进式Web应用程序"><a href="#渐进式Web应用程序" class="headerlink" title="渐进式Web应用程序"></a>渐进式Web应用程序</h2><p>我最喜欢的基于JavaScript的2016年技术授予Progressive Web Apps。 PWA是在谷歌的<a href="https://developers.google.com/web/shows/cds/2015/progressive-web-apps-chrome-dev-summit-2015" target="_blank" rel="external">2015年Chrome开发者峰会</a>上宣布，但稳定的技术和工具终于在7月到达Chrome 52。 PWA允许离线优先功能，并取代片状AppCache方法。 Web应用程序终于可以和native应用程序竞争，并提供以下优势：</p>
<ul>
<li>主屏幕图标</li>
<li>快速启动和自定义闪屏</li>
<li>快速执行</li>
<li>离线功能，无需互联网连接</li>
<li>网址，链接和书签</li>
<li>全屏或主题界面</li>
<li>沙盒执行</li>
<li>本地或基于云的存储</li>
<li>更少的设备空间和处理资源</li>
<li>更好的安全性（HTTPS是先决条件）</li>
<li>从任何搜索引擎轻松发现</li>
<li>请在安装前尝试</li>
<li>更简单的部署：它只是一个Web应用程序</li>
<li>没有AppStore废话：你的应用程序可以包含任何裸体画并且你绝对会渴望没有人能拿走你30％的利润！</li>
</ul>
<p>最重要的是：任何网站或者应用程序可以在几小时内转换为PWA。步骤：</p>
<ol>
<li>在服务器上启用HTTPS。</li>
<li>创建一个应用程序清单 - 应用程序根目录中的JSON文件，用于定义名称，颜色，图标和显示选项。</li>
<li>创建一个Service Worker - 根目录中的JavaScript文件用于拦截网络调用,并且可以根据需要返回缓存或实时数据。</li>
</ol>
<p>初期例子很少，但是PWA提供了一个不错的机会“动员”您的Web应用程序。虽然不能保证苹果将实施这项技术，但这并不重要，你的应用程序仍然可以在Safari中工作，只是它不会从离线执行中受益。我有一种感觉一旦Android上web体验有明显提升,苹果将鼓励支持PWA。</p>
<p>有关详细信息，请参阅 <a href="https://dev.opera.com/articles/pwa-resources/" target="_blank" rel="external">Dev.Opera’s Progressive Web Apps: The definitive collection of resources</a>和<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="external">Google的PWA指南</a>。</p>
<h2 id="框架固定"><a href="#框架固定" class="headerlink" title="框架固定"></a>框架固定</h2><p>很难做出一个公正的判断，但是<a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>似乎在今年受到最多的关注。你也许不同意;因为这取决于你使用的是什么，你曾经浏览过的地方和你说过的话！</p>
<p><a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>已经普及，2.0版本于9月发布。</p>
<p><a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>可能已经失去了它在2015年获得的一些势头，但这可能会随着9月发布Angular 2而改变。新版本是一个完全重写;它不是向后兼容v1.0。</p>
<p>虽然新的框架和库是令人兴奋的，但是十年前的jQuery仍然强大。版本3.0于6月9日发布，v3.1随后于7月7日出现。该库现在以严格模式运行，支持Promise，并实现了各种修复。 （查看完整修改列表的<a href="http://jquery.com/upgrade-guide/3.0/" target="_blank" rel="external">升级指南</a>。）</p>
<p>在使用JavaScript的96.4％的网站上用了jQuery。与之相比，Angular是最常用的现代框架 - 占0.5％。 jQuery 1.x是最流行的版本，占93.5％的使用率。版本2.x占6.0％、版本3.x占0.5％。</p>
<p>我一直批评开发人员上来就直接使用jQuery。当有一个其他更合适的选择或只要一小段JavaScript就能实现需求的时候，它就会被过度使用了。然而，它提供了更浅的学习曲线，比大多数框架更灵活。其他框架或库要取代它需要很多年的时间。</p>
<h2 id="API滥用"><a href="#API滥用" class="headerlink" title="API滥用"></a>API滥用</h2><p>比如电池状态API。在我2013年写JavaScript的时候，它似乎很有用;当你的应用程序检测到用户的手机即将关机的时候，到底怎样才能更好的最小化网络请求和处理呢?</p>
<p>不幸的是，Mozilla预估大约有6％的网站用了这个API​​，但大多数是广告客户用来检测电池状态，并跟踪用户浏览了哪些网站的域名。也有可能是某些服务商知道一个用户手机快关机绝望的时候，以此来提高某些服务的价格，</p>
<p>虽然这不是JavaScript或API的问题，出于隐私方面的原因，Mozilla采取了空前的手段把电池状态API从Firefox 53中删除。这不太可能出现在ios设备中,其他具有类似原因的API也包括传感器和蓝牙。这是一个不太光彩的事情：这些API都有实际的好处，我希望隐私问题可以在未来的版本得到解决。</p>
<h2 id="Node新版本"><a href="#Node新版本" class="headerlink" title="Node新版本"></a>Node新版本</h2><p>每年Node.JS会给我们带来两次发布进度，4月的6.0版本和10月的7.0版本。</p>
<p>目前该平台呈上升趋势，尽管W3Techs报告Node.js服务器使用率仅为0.2％，而PHP为82.3％。这些数字可能有点误导，因为Node.js即使安装了，也不一定能识别。</p>
<p>因为php已经开始很久了，并且现在依然是服务端最靠谱的选择。然而，Node.js正在书写自己的历史，并被所有语言信仰的开发者广泛使用。</p>
<h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>我非常喜欢npm，并且认为它是Node.js工具火爆的主要原因之一。在npm上我从来没有遇到过太多的问题，但我不是在Facebook这样大的项目上工作。</p>
<p>Facebook的工程师在10月份发布了Yarn。它是一个新的Node.js包管理器，旨在比npm更快更稳定。它依赖于npm注册表，因此可以和npm保持完全兼容。</p>
<p>Tim Severien的<a href="https://www.sitepoint.com/yarn-vs-npm/" target="_blank" rel="external">Yarn vs npm：你需要知道的一切</a>。我同意他的结论：</p>
<p>虽然Yarn不是一个复制品，但它改善了npm几个缺陷的地方。如果npm从Yarn身上学习，并要求Facebook、谷歌和其他Yarn贡献者一起来改进npm，这样是不是很爽呢？</p>
<h2 id="厌倦疲劳"><a href="#厌倦疲劳" class="headerlink" title="厌倦疲劳"></a>厌倦疲劳</h2><p>2016年的有篇文章叫I-can’t-take-this-any-more入选了Jose Aguinaga的<a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.e4rkosi1w" target="_blank" rel="external">2016年学习JavaScript的感觉</a>。亚军：dayssincelastjavascriptframework.com。</p>
<p>这可能是种幽默的方式以表明当前JavaScript的状态，但有一点要说明的就是，就是现在要跟上最新的趋势，框架和建议变得越来越难。当面对大量的技术方案评估时，开发人员会相互争执。</p>
<p>我的建议：不要试图跟上。因为这根本做不到。你今天重点关注的任何系统,明天都将被更好的东西取代。为您的项目选择一个好的方案，并坚持使用它，除非它让工作变得很糟糕。</p>
<p>有一个是可以确定的就是JavaScript本身。首先学习语言，并继续扩展你的知识。您的经验将帮助您了解每个框架的运作方式，以便您做出明智的选择，即便这种选择可能是完全放弃所有的框架。</p>
<p>新年快乐！</p>
<p>原文链接：<a href="http://cnedwan.com/2016/12/21/%E8%AF%91-2016%E5%B9%B4Javascript%E5%9B%9E%E9%A1%BE.html" target="_blank" rel="external">【译】2016年javascript回顾</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文字循环无缝滚动特效代码]]></title>
      <url>https://fantasticzhang.github.io/2016/12/29/%E6%96%87%E5%AD%97%E5%BE%AA%E7%8E%AF%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8%E7%89%B9%E6%95%88%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今天突然被问到了这个问题，现把我的解决方案记下来以便日后查看。下面是一个简单的小例子：</p>
<pre><code>&lt;div  id=&quot;textScroll&quot; style=&quot;overflow:hidden;height:200px;width:300px;font-size:14px;line-height:22px;text-align:left;padding:10px&quot;&gt;
&lt;div id=&quot;textScroll1&quot;&gt;
  文字实循环无缝滚动
  &lt;/div&gt;
&lt;div id=&quot;textScroll2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

//原理：设置好固定的宽高，内容的实际高度比这个高得多。控制滚动条，在滚到一定位置后减小滚动条高度，重复此过程。

var textScroll = document.getElementById(&quot;textScroll&quot;);
var textScroll1 = document.getElementById(&quot;textScroll1&quot;);
var textScroll2 = document.getElementById(&quot;textScroll2&quot;);
var speed=50;    //滚动速度值，值越大速度越慢

//复制文本,使文本总高度大于父元素高度，这样才能无缝滚动
var nnn=200/textScroll1.offsetHeight;
for(i=0;i&lt;nnn;i++){textScroll1.innerHTML+=&quot;&lt;br /&gt;&quot;+ textScroll1.innerHTML}
textScroll2.innerHTML = textScroll1.innerHTML;

function Marquee(){
if(textScroll2.offsetTop-textScroll.scrollTop&lt;=0)    //当滚动至textScroll2时
{
    textScroll.scrollTop-=textScroll1.offsetHeight;    //textScroll跳到最顶端,从头开始滚动

}
else{
    textScroll.scrollTop++;     //持续滚动
}
}

var MyMar = setInterval(Marquee,speed);        //设置定时器
textScroll.onmouseover = function(){clearInterval(MyMar)}    //鼠标经过时清除定时器达到滚动停止的目的
textScroll.onmouseout = function(){MyMar = setInterval(Marquee,speed)};    //鼠标移开时重设定时器
&lt;/script&gt;
</code></pre><p>例子很简单，可根据实际情况进行修改以满足实际需要。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序开发（一）]]></title>
      <url>https://fantasticzhang.github.io/2016/12/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>前段时间，微信小程序突然火了，朋友圈被刷屏了。但由于某些原因，博主一直没有了解它，终于在昨天，抽了些时间了解了下小程序，主要是阅读了官方文档，之后博主觉得，小程序还是蛮有意思的，于是决定将自己的学习过程记录下来，也希望能够和同样对微信小程序感兴趣的朋友们多多交流。</p>
<p>以下内容主要来自于<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1481249514" title="小程序官方文档" target="_blank" rel="external">官方文档</a>。</p>
<h1 id="微信小程序简介"><a href="#微信小程序简介" class="headerlink" title="微信小程序简介"></a>微信小程序简介</h1><p>下面是官方给出的关于微信小程序的介绍：</p>
<p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。小程序、订阅号、服务号、企业号是并行的体系。</p>
<p>由官方的表述来看，通俗一点的说，微信小程序其实就是微信提高了自身对HTML5特性的支持能力，开放了更多的系统调用。因此，微信里的HTML5产品将有更好的用户体验，更快的加载速度以及更多的功能。</p>
<h1 id="小程序注册"><a href="#小程序注册" class="headerlink" title="小程序注册"></a>小程序注册</h1><p>目前，微信小程序只开放了对企业、政府、媒体以及其他组织的注册，并没有开放对个人开发者的注册，那么个人如何注册小程序并进行学习呢？博主主要是参考了网上的一个方法，亲测可用。<a href="https://www.zhihu.com/question/52268924" target="_blank" rel="external">参考链接</a></p>
<h1 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h1><p>下面是官方文档给出的一个简易教程，这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。</p>
<p>注：以下教程默认注册账号、开发者、体验者都是使用管理员微信号。</p>
<h2 id="获取微信小程序的AppID"><a href="#获取微信小程序的AppID" class="headerlink" title="获取微信小程序的AppID"></a>获取微信小程序的AppID</h2><p>注册微信小程序并登录后，就可以在网站的“设置”-“开发者设置”中，查看到微信小程序的AppID了。</p>
<p><img src="/images/2016-12-9/1.png" alt=""></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们需要通过<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html?t=20161122" target="_blank" rel="external">开发者工具</a>，来完成小程序创建和代码编辑。</p>
<p>开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“firstProject”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。</p>
<p>为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。</p>
<p>项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。默认demo运行结果如下：</p>
<p><img src="/images/2016-12-9/2.PNG" alt=""></p>
<h2 id="项目结构简介"><a href="#项目结构简介" class="headerlink" title="项目结构简介"></a>项目结构简介</h2><p>点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p>
<p>下面简单介绍下这三个文件的功能。</p>
<ul>
<li><p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
<pre><code>//app.js
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync(&apos;logs&apos;) || []
    logs.unshift(Date.now())
    wx.setStorageSync(&apos;logs&apos;, logs)
  },
  getUserInfo:function(cb){
    var that = this
    if(this.globalData.userInfo){
      typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo
              typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)
            }
          })
        }
      })
    }
  },
  globalData:{
    userInfo:null
  }
})
</code></pre></li>
<li><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p>
<pre><code>{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;
  },
  &quot;tabBar&quot;: {
    &quot;position&quot;: &quot;bottom&quot;,
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre></li>
<li><p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p>
<pre><code>/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
} 
</code></pre></li>
</ul>
<p>在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成：</p>
<ul>
<li><p>.js后缀的文件是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
</li>
<li><p>.json后缀的文件是页面的配置文件，它是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p>
</li>
<li><p>.wxss后缀的是页面的样式表文件，它也是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
</li>
<li><p>.wxml后缀的文件是页面结构文件，用来搭建页面结构，绑定数据和交互处理函数。</p>
</li>
</ul>
<p>以上就是页面结构的简单介绍，在小程序开发框架一节中还会对这部分内容进行详细介绍。</p>
<h2 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h2><p>开发者工具左侧菜单栏选择”项目”，点击”预览”，扫码后即可在微信客户端中体验。</p>
<p><img src="/images/2016-12-9/3.PNG" alt=""></p>
<h1 id="小程序开发框架"><a href="#小程序开发框架" class="headerlink" title="小程序开发框架"></a>小程序开发框架</h1><p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p>
<p>框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p>
<p>下面将从目录结构、配置、逻辑层和视图层四个方面对小程序开发框架进行介绍。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。在上一节中我们已经对目录结构进行了简单的了解。</p>
<ul>
<li><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，分别是：app.js、app.json、app.wxss 。其中，app.js是小程序的脚本代码，用来控制小程序的逻辑，它是必要的；app.json是对整个小程序的全局配置，它也是必要的；app.wxss是整个小程序的公共样式表，它是非必要的。</p>
</li>
<li><p>一个小程序页面由四个文件组成，分别是：.js、.json、.wxss、.wxml四个文件。其中.js后缀的文件是页面脚本文件，用来控制页面逻辑；.json后缀的文件是页面配置文件；.wxss后缀的是页面样式表文件；.wxml后缀的文件是页面结构文件。.js文件和.wxml文件是必要的，另外两个文件是非必要的。</p>
</li>
</ul>
<p>注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p>app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>
<p>以下是一个包含了所有配置选项的简单配置app.json ：</p>
<pre><code>{
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/index&quot;
  ],
  &quot;window&quot;: {
    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
  },
  &quot;tabBar&quot;: {
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre><p>app.json 配置项列表</p>
<p><img src="/images/2016-12-9/4.PNG" alt=""></p>
<p>下面对这些配置项进行简单介绍。</p>
<h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h4><p>接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。</p>
<p>文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<p><img src="/images/2016-12-9/5.PNG" alt=""></p>
<h4 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h4><p>如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p>tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。</p>
<p>属性如下：</p>
<p><img src="/images/2016-12-9/6.PNG" alt=""></p>
<p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p>
<p><img src="/images/2016-12-9/7.PNG" alt=""></p>
<h4 id="networkTimeout"><a href="#networkTimeout" class="headerlink" title="networkTimeout"></a>networkTimeout</h4><p>可以设置各种网络请求的超时时间。</p>
<p>属性值如下：</p>
<p><img src="/images/2016-12-9/8.PNG" alt=""></p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发。可以帮助开发者快速定位一些常见的问题。</p>
<h3 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a>page.json</h3><p>每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。由于页面的配置只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，下面是一个简单的例子：</p>
<pre><code>{
  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,
  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,
  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,
  &quot;backgroundTextStyle&quot;: &quot;light&quot;
}
</code></pre><h2 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h2><p>小程序开发框架的逻辑层是由JavaScript编写，为了方便地开发小程序，在JavaScript的基础上做了一些修改，主要如下：</p>
<ul>
<li>增加App和Page方法，进行程序和页面注册；</li>
<li>增加getApp和getCurrentPages方法，分别用来获取App实例和当前页面栈；</li>
<li>由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等;</li>
<li>每个页面有独立的作用域，并提供模块化能力;</li>
<li>提供丰富的 API;</li>
<li>开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</li>
</ul>
<h3 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h3><p>App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/9.PNG" alt=""></p>
<p>注： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p>
<h3 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h3><p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/10.PNG" alt=""></p>
<h4 id="Page-prototype-setData"><a href="#Page-prototype-setData" class="headerlink" title="Page.prototype.setData()"></a>Page.prototype.setData()</h4><p>setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。</p>
<p>注意：</p>
<ol>
<li>直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。</li>
<li>单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</li>
</ol>
<p>setData 函数接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。</p>
<p>其中 key 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。</p>
<p>例子：</p>
<pre><code>&lt;!--index.wxml--&gt;
&lt;view&gt;{{text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt;
&lt;view&gt;{{array[0].text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInArray&quot;&gt; Change Array data &lt;/button&gt;
&lt;view&gt;{{object.text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInObject&quot;&gt; Change Object data &lt;/button&gt;
&lt;view&gt;{{newField.text}}&lt;/view&gt;
&lt;button bindtap=&quot;addNewField&quot;&gt; Add new data &lt;/button&gt;
//index.js
Page({
  data: {
    text: &apos;init data&apos;,
    array: [{text: &apos;init data&apos;}],
    object: {
      text: &apos;init data&apos;
    }
  },
  changeText: function() {
    // this.data.text = &apos;changed data&apos;  // bad, it can not work
    this.setData({
      text: &apos;changed data&apos;
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      &apos;array[0].text&apos;:&apos;changed data&apos;
    })
  },
  changeItemInObject: function(){
    this.setData({
      &apos;object.text&apos;: &apos;changed data&apos;
    });
  },
  addNewField: function() {
    this.setData({
      &apos;newField.text&apos;: &apos;new data&apos;
    })
  }
})
</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。</p>
<p>我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。</p>
<p>注：</p>
<ul>
<li>exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐使用 module.exports；</li>
<li>小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候可以拷贝出相关的代码到小程序的目录中。</li>
</ul>
<p>例子：</p>
<pre><code>// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
</code></pre><p>​在需要使用这些模块的文件中，使用 require(path) 将公共代码引入:</p>
<pre><code>var common = require(&apos;common.js&apos;)
Page({
  helloMINA: function() {
    common.sayHello(&apos;MINA&apos;)
  },
  goodbyeMINA: function() {
    common.sayGoodbye(&apos;MINA&apos;)
  }
})
</code></pre><h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。其中，WXML(WeiXin Markup language)用于描述页面的结构；WXSS(WeiXin Style Sheet)用于描述页面的样式；组件(Component)是视图的基本组成单元。</p>
<h3 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h3><p>WXML具有数据绑定、列表渲染、条件渲染、模板、事件和引用的功能。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>WXML 中的动态数据均来自对应 Page 的 data。</p>
<p>数据绑定使用Mustache语法（双大括号）将变量包起来，可以作用于：内容、组件属性、控制属性和关键字，其中后三者需要在双引号之内。</p>
<p>作用于关键字的例子：</p>
<pre><code>&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;    
</code></pre><ul>
<li><p>true：boolean 类型的 true，代表真值。</p>
</li>
<li><p>false： boolean 类型的 false，代表假值。</p>
</li>
</ul>
<p>注：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<p>还可在双大括号内进行简单的运算，支持的运算有：三元运算、算数运算、逻辑判断、字符串运算、数据路径运算等。</p>
<p>也可在双大括号内直接进行组合，构成新的对象或者数组。</p>
<p>具体的使用方法可参考官方文档给出的例子。</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>在框架中，我们用<code>wx:if</code>来判断是否需要渲染该代码块：</p>
<pre><code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;
</code></pre><p>也可以用<code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p>
<pre><code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre><p>因为<code>wx:if</code>是一个控制属性，需要将它添加到一个标签上。但是如果我们想一次性判断多个组件标签，我们可以使用一个<code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<pre><code>&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>注意：<code>&lt;block/&gt;</code>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>在组件上使用<code>wx:for</code>控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，使用<code>wx:for-index</code> 可以指定数组当前下标的变量名。</p>
<p>例子：</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}}: {{itemName.message}}
&lt;/view&gt;
</code></pre><p>类似block wx:if，也可以将wx:for用在<block>标签上，以渲染一个包含多节点的结构块。</block></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如<code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<p><code>wx:key</code> 的值以两种形式提供：</p>
<ul>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li>
</ul>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>如不提供 <code>wx:key</code>，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p>
<p>示例代码：</p>
<pre><code>&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; style=&quot;display: block;&quot;&gt; {{item.id}} &lt;/switch&gt;
&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;
&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;

&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; style=&quot;display: block;&quot;&gt; {{item}} &lt;/switch&gt;
&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add to the front &lt;/button&gt;

Page({
  data: {
    objectArray: [
      {id: 5, unique: &apos;unique_5&apos;},
      {id: 4, unique: &apos;unique_4&apos;},
      {id: 3, unique: &apos;unique_3&apos;},
      {id: 2, unique: &apos;unique_2&apos;},
      {id: 1, unique: &apos;unique_1&apos;},
      {id: 0, unique: &apos;unique_0&apos;},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i &lt; length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: &apos;unique_&apos; + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
</code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。模板拥有自己的作用域，只能使用data传入的数据。</p>
<p>例子：</p>
<pre><code>//定义模板
&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;

//使用模板
&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt;
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h5><p>事件分为冒泡事件和非冒泡事件：</p>
<ul>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ul>
<p>冒泡事件包括：</p>
<ul>
<li>touchstart：手指触摸动作开始；</li>
<li>touchmove：手指触摸后移动；</li>
<li>touchcancel：手指触摸动作被打断，如来电提醒，弹窗；</li>
<li>touchend：手指触摸动作结束；</li>
<li>tap：手指触摸后马上离开；</li>
<li>longtap：手指触摸后，超过350ms再离开。</li>
</ul>
<p>除以上之外的其他组件自定义事件如无特殊申明都是非冒泡事件。</p>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<ul>
<li>key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart；</li>
<li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li>
</ul>
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p>
<p><img src="/images/2016-12-9/11.PNG" alt=""></p>
<ul>
<li>type：事件的类型；</li>
<li>timeStamp：页面打开到触发事件所经过的毫秒数；</li>
<li><p>target：触发事件的源组件，包括：</p>
<ul>
<li>id：String，事件源组件的id；</li>
<li>tagName：String，当前组件的类型；</li>
<li>dataset：Object，事件源组件上由data-开头的自定义属性组成的集合。</li>
</ul>
</li>
<li><p>currentTarget：事件绑定的当前组件，属性同target；</p>
</li>
<li><p>touches：是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p>
<ul>
<li><p>Touch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>pageX, pageY：Number，距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴；</li>
<li>clientX, clientY：Number，距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
<li><p>CanvasTouch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>x, y：Number，距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
</ul>
</li>
<li><p>changedTouches：数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p>
</li>
<li><p>detail：自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息等，具体参见官方文档。</p>
</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>WXML 提供两种文件引用方式import和include。</p>
<ul>
<li>import：可以在该文件中使用目标文件定义的template。import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</li>
<li>include：include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置。</li>
</ul>
<h3 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h3><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。与 CSS 相比，WXSS扩展的特性有：尺寸单位，样式导入。</p>
<h4 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h4><ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li>
<li>rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。</li>
</ul>
<h4 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h4><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用;表示语句结束。</p>
<p>例子：</p>
<pre><code>/** common.wxss **/
.small-p {
  padding:5px;
}
/** app.wxss **/
@import &quot;common.wxss&quot;;
.middle-p {
  padding:15px;
}
</code></pre><p>WXSS目前支持的选择器有：<code>.class</code>、<code>#id</code>、<code>element</code>、<code>element, element</code>、<code>::after</code>、<code>::before</code>。</p>
<h2 id="组件和API"><a href="#组件和API" class="headerlink" title="组件和API"></a>组件和API</h2><p>框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<p>关于组件和API的详细内容参见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161122" target="_blank" rel="external">官方文档</a>.</p>
<p>官方文档阅读完后，就可以进行实际的开发了。对于一个新手来说，自己开发一个微信小程序可能有些难，不过网上有很多微信小程序的开发案例，可以在照着开发案例开发完一个微信小程序后，自己再独立的开发一个属性自己的微信小程序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[同一台电脑关联两个或多个Github账号]]></title>
      <url>https://fantasticzhang.github.io/2016/12/07/%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%85%B3%E8%81%94%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAGithub%E8%B4%A6%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>今天遇到了一个问题，我自己有一个github账号，项目组有一个github账号，然后我需要在我的电脑上同时管理这两个github账号的仓库，这时候该怎么办呢？在查阅了一些资料后，成功解决了这个问题，现将解决方案记录下来，以便日后查看。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>管理两个SSH key。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p><code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code></p>
<p>使用上面的命令在本地生成SSH key。由于需要管理两个github账号，因此在保存所生成的SSH key时需要注意两个key的文件名要有区别，比如我第一个账号生成的文件名为<code>id_rsa</code>，第二个账号生成的文件名为<code>id_rsa.gtensor</code>，这样就可以加以区分。</p>
<h3 id="将SSH-key添加到github"><a href="#将SSH-key添加到github" class="headerlink" title="将SSH key添加到github"></a>将SSH key添加到github</h3><p>将上一步所生成的两个SSH key分别添加到对应的github账户中。</p>
<h3 id="创建config文件"><a href="#创建config文件" class="headerlink" title="创建config文件"></a>创建config文件</h3><p><code>$touch config</code></p>
<p>在.ssh目录下，使用以上命令新建一个config文件，并在文件中添加如下内容：</p>
<pre><code>#default github
Host github.com
  HostName github.com
  IdentityFile ~/.ssh/id_rsa    
#gtensor github
Host github_gtensor
  HostName github.com  
  IdentityFile ~/.ssh/id_rsa.gtensor
</code></pre><p>其中，Host后面就是github账号的别名，这里就是为第二个github账号新增了一个别名<code>github_gtensor</code>，这样就将不同的账号区分开了。config文件的内容，需要根据自己的实际情况进行相应修改。</p>
<h3 id="将SSH-key添加到ssh-agent上"><a href="#将SSH-key添加到ssh-agent上" class="headerlink" title="将SSH key添加到ssh-agent上"></a>将SSH key添加到ssh-agent上</h3><p><code>$ ssh-add ~/.ssh/id_rsa.gtensor</code></p>
<p>在.ssh目录下，使用上面的命令将第二个账号的key添加到agent上。在执行以上命令时可能会出现错误提示： <code>Could not open a connection to your authentication agent</code>，此时需要执行以下命令开启ssh-agent服务：</p>
<p><code>$ eval $(ssh-agent)</code></p>
<h3 id="测试github连接是否成功"><a href="#测试github连接是否成功" class="headerlink" title="测试github连接是否成功"></a>测试github连接是否成功</h3><p><code>$ ssh –T git@github_gtensor</code></p>
<p>使用以上命令测试是否能连接github账户，其中<code>github_gtensor</code>即为我所设置的第二个github账号的别名，需要根据实际情况进行修改。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过以上配置，我们就可以通过使用github.com的别名github_gtensor来明确说明我们要使用id_rsa.gtensor的SSH key来连接github，即使用项目组的github账号进行操作。</p>
<p>例如，要克隆第二个github账号的远程仓库到本地，则原来的写法：</p>
<pre><code>$ git clone git@github.com: 第二个github账号的用户名/***.git
</code></pre><p>则现在的写法改为：</p>
<pre><code>$ git clone git@github_gtensor: 第二个github账号的用户名/***.git
</code></pre><p>我的环境是：win10 + git bash，测试成功，如有任何疑问，可给我留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Node的子进程调用脚本和系统命令]]></title>
      <url>https://fantasticzhang.github.io/2016/12/04/%E5%88%A9%E7%94%A8Node%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>child_process模块使得Node可以随意创建子进程。它提供了4个方法用于创建子进程。</p>
<ul>
<li>spawn(): 启动一个子进程来执行命令。</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile(): 启动一个子进程来执行可执行文件。</li>
<li>fork(): 与spawn()类似，不同点在于它创建Node的子进程只需要指定要执行的JavaScript文件模块即可。</li>
</ul>
<h2 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h2><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn()"></a>spawn()</h3><p><code>child_process.spawn(command[, args][, options])</code></p>
<p>spawn方法返回一个对象流，适合于输出大量数据然后需要读取的应用场合。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
free = shellProcess.spawn(&apos;free&apos;, [&apos;-m&apos;]);

// 捕获标准输出并将其打印到控制台
free.stdout.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard output:\n&apos; + data);
});

// 捕获标准错误输出并将其打印到控制台
free.stderr.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard error output:\n&apos; + data);
});

// 注册子进程关闭事件
free.on(&apos;exit&apos;, function (code) {
    console.log(&apos;child process exit ,exit:&apos; + code);
});
</code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><code>child_process.exec(command[, options][, callback])</code></p>
<p>exec方法会启动一个子进程来执行系统命令，并缓冲产生的数据，当子进程完成后回调函数就会被调用，可带有：</p>
<ul>
<li>当命令成功执行，缓冲的数据；</li>
<li>当命令执行失败，错误信息。</li>
</ul>
<p>exec方法并没有args参数选项，这是因为它允许我们执行多个命令，当使用exec方法时，如果需要传输参数到命令行，则参数应该作为整个命令字符串的一部分。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;chmod -R a+rwx start.sh&apos;, function(err,stdout,stderr){  //设置start.sh脚本的权限
       if(err) {
          return console.log(&apos;error:&apos;+stderr);
        }
   });
</code></pre><h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile()"></a>execFile()</h3><p><code>child_process.execFile(file[, args][, options][, callback])</code></p>
<p>当外部可执行文件存在时，该可执行文件将携带参数args被执行，当可执行文件退出时，回调函数被调用，回调函数带有子进程的标准输入输出，来自外部可执行文件的标准输出将被内部缓冲保存。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.execFile(&apos;./stop.sh&apos;, function(err, stdout, stderr){
     if(err) return console.error(err);
     console.log(&apos;stdout: &apos;+stdout);
});
</code></pre><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><code>fork(modulePath[,args][,options])</code></p>
<p>其中modulePath是一个字符串，用来指定JavaScript文件路径。</p>
<p>由于该方法还没有实际使用过，所以目前对它还不太了解，在日后充分了解后再进行补充。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>spawn()与exec()、execFile()的区别：</p>
<ul>
<li>exec()、execFile()都有一个回调函数获知子进程的状况；</li>
<li>exec()、execFile()创建时可指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</li>
</ul>
</li>
<li><p>exec()与execFile()的区别：exec()适合执行已有的命令，execFile()适合执行文件。</p>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="使用exec-方法执行sudo命令"><a href="#使用exec-方法执行sudo命令" class="headerlink" title="使用exec()方法执行sudo命令"></a>使用exec()方法执行sudo命令</h3><p>由于sudo命令需要输入密码，所以执行sudo命令与执行普通命令有所区别，下面是两种比较简单的解决方法：</p>
<h5 id="方法一：-S选项"><a href="#方法一：-S选项" class="headerlink" title="方法一： -S选项"></a>方法一： -S选项</h5><p>sudo命令有个-S选项，用于在需要输入密码的时候，读取密码。</p>
<p>假设密码为password，且假设要使用sudo命令执行脚本文件 tee_to_monitor.sh ，并向其传递参数 status ，那么，完整命令如下</p>
<p><code>echo &quot;password&quot; | sudo -S ./tee_to_monitor.sh status</code></p>
<p>相应的，node代码可以这样</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;echo &quot;zjl&quot; | sudo -S ./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>该方法比较简单，只需要使用<code>sudo npm start</code>启动应用即可，假设同样是上面的例子，此时node代码如下：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><p>也就是说，如果使用sudo命令启动应用，则该应用中就不需要再用sudo了。</p>
<h3 id="使用exec-方法实时获取输出"><a href="#使用exec-方法实时获取输出" class="headerlink" title="使用exec()方法实时获取输出"></a>使用exec()方法实时获取输出</h3><p>如果按照前面例子中的方法使用exec()，则子进程完成后回调函数才会被调用，如果想要实时获取输出，则可按照下面的例子使用exec()。</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
var child = shellProcess.exec(&apos;./start.sh&apos;);
// 捕获标准输出并使用socket通信传递数据
child.stdout.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 捕获标准错误输出并使用socket通信传递数据
child.stderr.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 注册子进程关闭事件
child.on(&apos;close&apos;,function(code){
  console.log(&apos;closing code: &apos;+code);
});
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的overflow属性和white-space属性]]></title>
      <url>https://fantasticzhang.github.io/2016/11/22/CSS%E7%9A%84overflow%E5%B1%9E%E6%80%A7%E5%92%8Cwhite-space%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>今天在写网页的时候用到了这两个属性，对于它们分别可能的取值及其含义一开始不是很确定，在查阅了网上的一些资料以及自己动手测试后，对它们每个可能取值的含义现已明确，因此记录下来方便之后查阅。</p>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p>overflow属性规定当内容溢出元素框时发生的事情。</p>
<h4 id="可能的取值"><a href="#可能的取值" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>visible：默认值。内容不会被修剪，会呈现在元素框之外。</li>
<li>hidden：内容会被修剪，并且其余内容是不可见的。</li>
<li>scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</li>
<li>auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</li>
<li>inherit：从父元素继承overflow属性的值。</li>
</ul>
<h4 id="scroll和auto的区别"><a href="#scroll和auto的区别" class="headerlink" title="scroll和auto的区别"></a>scroll和auto的区别</h4><ul>
<li>scroll：内容自动撑开容器的宽度不包括滚动条，相当于滚动条是一个和内容并列显示的组件。</li>
<li><p>auto：内容撑开容器的宽度包括滚动条。即 使用<code>white-space:nowrape;</code>撑开容器至正好显示所有内容时，如果有滚动条，则滚动条会覆盖在内容上方，导致内容宽度被再次缩小，然后出现省略号。由此推断渲染顺序：</p>
<p>  自适应宽度-&gt;根据高度显示滚动条-&gt;重新计算内部元素宽度。 </p>
</li>
</ul>
<p>综上，如果宽度是由内容自适应撑开的，则<code>overflow:auto;</code>带来的滚动条会占用内容的一部分宽度，导致内容显示不全。</p>
<h3 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h3><p>该属性声明建立布局过程中如何处理元素中的空白符。</p>
<h4 id="可能的取值-1"><a href="#可能的取值-1" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>normal：默认值。连续的空白符会被合并，换行符会被当做空白符来处理。填充line盒子时，必要的话会换行。</li>
<li>pre: 连续的空白符会被保留。在遇到换行符或者\<br\>元素时才会换行。</br\></li>
<li>nowrap: 连续的空白符会被合并，文本不会换行，会在同一行上继续，直到遇到\<br\>标签为止。</br\></li>
<li>pre-wrap：连续的空白符会被保留，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>pre-line：连续的空白符会被合并，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>inherit：从父元素继承white-space属性的值。</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="external">参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的定位技术]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>CSS使用top、left、right、bottom设置元素的二维（x轴和y轴）偏移量。使用z-index设置元素垂直于屏幕的方向，也就是“z轴”的偏移量。</p>
<p>CSS使用position选项来定义元素的定位属性，该选项有五个可选值：static、relative、absolute、fixed、inherit，默认值是static。inherit属性表示继承父元素的定位属性，因此只需掌握static、relative、absolute、fixed这四种定位属性的特性即可。</p>
<h3 id="相对定位技术"><a href="#相对定位技术" class="headerlink" title="相对定位技术"></a>相对定位技术</h3><p>相对定位即相对于文档流中的其他已定义的元素位置进行定位。relative和static都是相对于文档其他元素进行定位，都属于相对定位的范畴，区别在于一个可以控制位移，一个不能。</p>
<h4 id="static（默认值）"><a href="#static（默认值）" class="headerlink" title="static（默认值）"></a>static（默认值）</h4><p>如果使用默认值，在CSS中为元素定义top、left、right、 bottom、z-index都不会生效。也就是说，如果想设置元素的偏移量和z-index，必须为元素定义position属性（static除外）。</p>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p>relative的表现和默认值一样，只不过可以通过设置偏移量和z-index来控制相对于其正常位置进行的偏移。</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位的元素有以下几个特点：</p>
<ul>
<li>块级元素的宽度在未定义时不再为100%，而是根据内容自动调整。</li>
<li>在不定义z-index的情况下，absolute元素会覆盖在其他元素之上。</li>
<li>它会脱离正常的文档流，不再占据空间，类似于浮动后的效果。</li>
</ul>
<p>absolute和fixed都属于绝对定位的范畴，都遵循以上3个特点。</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p>absolute是相对上一个不为static的父元素进行绝对定位。也就是说，如果不指定父元素的position，absolute将相对于整个html文档进行绝对定位。</p>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>fixed是相对于浏览器窗口进行定位。也就是说，不论网页如何滚动，该元素始终停留在屏幕的某个位置上。例如：我们希望侧边控制栏始终对用户可见，就可以使用<code>position:fixed</code>来进行定位。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的优先级]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>如何确定CSS的优先级？首先要引入一个机制，分别用4个数字（a, b, c, d）表示优先级组合，它们的意思分别是：    </p>
<ul>
<li>第一个数字（a）表示style属性，优先级最高。由于一般都是class样式，所以该值一般都是0。  </li>
<li>第二个数字（b）是该CSS选择器上的id数量的总和，一般都是1个。</li>
<li>第三个数字（c）是用在该CSS选择器上的其他属性CSS选择器以及伪类的总和。这里包括class（比如 .btn）和属性选择器（比如 li[id=red]）。</li>
<li>第四个数字（d）计算元素（比如 table、p、div等）和伪元素（比如 first-child）。</li>
</ul>
<p>注：</p>
<ul>
<li>通用CSS选择器（*）是0优先级。</li>
<li>如果两个CSS选择器有同样的优先级，则在样式表中后面的那个起作用。</li>
</ul>
<p>几个例子：</p>
<ul>
<li>选择器：<code>#menu h2</code>， 优先级：0,1,0,1。   </li>
<li>选择器： <code>#leftbar li:first-child</code>，优先级： 0,1,0,2。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[又长大一岁啦]]></title>
      <url>https://fantasticzhang.github.io/2016/11/14/%E5%8F%88%E9%95%BF%E5%A4%A7%E4%B8%80%E5%B2%81%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>今天我又长大一岁啦~一大早就收到了爸爸妈妈的祝福和红包，以及好朋友的祝福，真的好开心~因此，想要简单记录一下这开心的一天。但由于博主经验不足图片格式还不太会调，可能看起来不太美观，以后会改正。</p>
<h3 id="美好的一天"><a href="#美好的一天" class="headerlink" title="美好的一天"></a>美好的一天</h3><p><img src="/images/2016-11-14/1.jpg" alt=""></p>
<p>闺蜜送的生日礼物，真的好喜欢，每一年的生日都给我好大的惊喜，也希望之后的每个生日都有你的陪伴。</p>
<p><img src="/images/2016-11-14/2.jpg" alt=""></p>
<p>早晨来到实验室就收到了学弟送的书，真的好感动~而且特意为我选了悬疑推理类的书，很符合我的口味，嘿嘿。真的很开心今年能认识你啦~</p>
<p><img src="/images/2016-11-14/3.jpg" alt=""></p>
<p>有个姐姐就是好，带我来吃海底捞啦，哈哈。一直听说海底捞的服务特别好，今天算是见识到了，店员知道今天我过生日，特意为我唱了生日快乐歌，而且还送了我礼物，真的好棒！对了，还可以免费做美甲，所以吃完饭后就做了一个，好开心。</p>
<p><img src="/images/2016-11-14/4.jpg" alt=""></p>
<p>店员知道今天我过生日，特意为我做了长寿面~</p>
<p><img src="/images/2016-11-14/5.jpg" alt=""></p>
<p>店家送给我的生日礼物，服务真的好周到。</p>
<p><img src="/images/2016-11-14/6.jpg" alt=""></p>
<p>最后，许下一个生日愿望，希望能实现~</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>今天一路上还收到了好多陌生人的祝福，真的好开心。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>https://fantasticzhang.github.io/2016/11/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>终于有自己的博客啦~</p>
<p>其实一直想要建一个属于自己的博客，用来记录自己日常生活中的点点滴滴、学习过程中整理的笔记以及一些技术感悟，记录自己读过的一些论文等，但由于自己的拖延症，一直没有弄:-P。终于，今天我也有了属于自己的博客啦，也希望自己之后能克服懒惰，经常更新。日积月累，总会有收获的。</p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>https://fantasticzhang.github.io/about/index.html</url>
      <content type="html"><![CDATA[<p>目前在北京读研，平时的工作主要是前端相关的。对前端技术也很感兴趣，处于边学边实践的阶段。欢迎志同道合的朋友与我多多交流，也期待大神的指点~</p>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://fantasticzhang.github.io/photos/output.json</url>
      <content type="html"><![CDATA[["IMG_20161005_164625.jpg","IMG_20161005_165430.jpg","IMG_20161005_165817.jpg","IMG_20161005_172129.jpg","IMG_20161006_130939.jpg","IMG_20161006_132426.jpg","IMG_20161006_132836.jpg","IMG_20161116_141430.jpg","IMG_20161116_150715.jpg","IMG_20161116_155406.jpg","IMG_20161118_124950.jpg","mmexport1479264425744.jpg","mmexport1479264435676.jpg"]]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[相册]]></title>
      <url>https://fantasticzhang.github.io/photos/index.html</url>
      <content type="html"><![CDATA[<p><link type="text/css" href="/css/photo.css" rel="stylesheet"></p>
<link type="text/css" href="/fancybox/jquery.fancybox.css" rel="stylesheet">

<div class="photos"><br>  <section class="archives album"><br>    <ul class="img-box-ul"></ul><br>  </section><br></div>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://fantasticzhang.github.io/photos/tool.js</url>
      <content type="html"><![CDATA["use strict";
    const fs = require("fs");
    const path = "../../photos";

    fs.readdir(path, function (err, files) {
        if (err) {
            return;
        }
        let arr = [];
        (function iterator(index) {
            if (index == files.length) {
                fs.writeFile("output.json", JSON.stringify(arr, null, "\t"));
                return;
            }

            fs.stat(path + "/" + files[index], function (err, stats) {
                if (err) {
                    return;
                }
                if (stats.isFile()) {
                    arr.push(files[index]);
                }
                iterator(index + 1);
            })
        }(0));
    });
]]></content>
    </entry>
    
  
</search>
