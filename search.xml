<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[利用Node的子进程调用脚本和系统命令]]></title>
      <url>https://fantasticzhang.github.io/2016/12/04/%E5%88%A9%E7%94%A8Node%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>child_process模块使得Node可以随意创建子进程。它提供了4个方法用于创建子进程。</p>
<ul>
<li>spawn(): 启动一个子进程来执行命令。</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile(): 启动一个子进程来执行可执行文件。</li>
<li>fork(): 与spawn()类似，不同点在于它创建Node的子进程只需要指定要执行的JavaScript文件模块即可。</li>
</ul>
<h2 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h2><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn()"></a>spawn()</h3><p><code>child_process.spawn(command[, args][, options])</code></p>
<p>spawn方法返回一个对象流，适合于输出大量数据然后需要读取的应用场合。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
free = shellProcess.spawn(&apos;free&apos;, [&apos;-m&apos;]);

// 捕获标准输出并将其打印到控制台
free.stdout.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard output:\n&apos; + data);
});

// 捕获标准错误输出并将其打印到控制台
free.stderr.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard error output:\n&apos; + data);
});

// 注册子进程关闭事件
free.on(&apos;exit&apos;, function (code) {
    console.log(&apos;child process exit ,exit:&apos; + code);
});
</code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><code>child_process.exec(command[, options][, callback])</code></p>
<p>exec方法会启动一个子进程来执行系统命令，并缓冲产生的数据，当子进程完成后回调函数就会被调用，可带有：</p>
<ul>
<li>当命令成功执行，缓冲的数据；</li>
<li>当命令执行失败，错误信息。</li>
</ul>
<p>exec方法并没有args参数选项，这是因为它允许我们执行多个命令，当使用exec方法时，如果需要传输参数到命令行，则参数应该作为整个命令字符串的一部分。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;chmod -R a+rwx start.sh&apos;, function(err,stdout,stderr){  //设置start.sh脚本的权限
       if(err) {
          return console.log(&apos;error:&apos;+stderr);
        }
   });
</code></pre><h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile()"></a>execFile()</h3><p><code>child_process.execFile(file[, args][, options][, callback])</code></p>
<p>当外部可执行文件存在时，该可执行文件将携带参数args被执行，当可执行文件退出时，回调函数被调用，回调函数带有子进程的标准输入输出，来自外部可执行文件的标准输出将被内部缓冲保存。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.execFile(&apos;./stop.sh&apos;, function(err, stdout, stderr){
     if(err) return console.error(err);
     console.log(&apos;stdout: &apos;+stdout);
});
</code></pre><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><code>fork(modulePath[,args][,options])</code></p>
<p>其中modulePath是一个字符串，用来指定JavaScript文件路径。</p>
<p>由于该方法还没有实际使用过，所以目前对它还不太了解，在日后充分了解后再进行补充。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>spawn()与exec()、execFile()的区别：</p>
<ul>
<li>exec()、execFile()都有一个回调函数获知子进程的状况；</li>
<li>exec()、execFile()创建时可指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</li>
</ul>
</li>
<li><p>exec()与execFile()的区别：exec()适合执行已有的命令，execFile()适合执行文件。</p>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="使用exec-方法执行sudo命令"><a href="#使用exec-方法执行sudo命令" class="headerlink" title="使用exec()方法执行sudo命令"></a>使用exec()方法执行sudo命令</h3><p>由于sudo命令需要输入密码，所以执行sudo命令与执行普通命令有所区别，下面是两种比较简单的解决方法：</p>
<h5 id="方法一：-S选项"><a href="#方法一：-S选项" class="headerlink" title="方法一： -S选项"></a>方法一： -S选项</h5><p>sudo命令有个-S选项，用于在需要输入密码的时候，读取密码。</p>
<p>假设密码为password，且假设要使用sudo命令执行脚本文件 tee_to_monitor.sh ，并向其传递参数 status ，那么，完整命令如下</p>
<p><code>echo &quot;password&quot; | sudo -S ./tee_to_monitor.sh status</code></p>
<p>相应的，node代码可以这样</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;echo &quot;zjl&quot; | sudo -S ./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>该方法比较简单，只需要使用<code>sudo npm start</code>启动应用即可，假设同样是上面的例子，此时node代码如下：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><p>也就是说，如果使用sudo命令启动应用，则该应用中就不需要再用sudo了。</p>
<h3 id="使用exec-方法实时获取输出"><a href="#使用exec-方法实时获取输出" class="headerlink" title="使用exec()方法实时获取输出"></a>使用exec()方法实时获取输出</h3><p>如果按照前面例子中的方法使用exec()，则子进程完成后回调函数才会被调用，如果想要实时获取输出，则可按照下面的例子使用exec()。</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
var child = shellProcess.exec(&apos;./start.sh&apos;);
// 捕获标准输出并使用socket通信传递数据
child.stdout.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 捕获标准错误输出并使用socket通信传递数据
child.stderr.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 注册子进程关闭事件
child.on(&apos;close&apos;,function(code){
  console.log(&apos;closing code: &apos;+code);
});
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的overflow属性和white-space属性]]></title>
      <url>https://fantasticzhang.github.io/2016/11/22/CSS%E7%9A%84overflow%E5%B1%9E%E6%80%A7%E5%92%8Cwhite-space%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>今天在写网页的时候用到了这两个属性，对于它们分别可能的取值及其含义一开始不是很确定，在查阅了网上的一些资料以及自己动手测试后，对它们每个可能取值的含义现已明确，因此记录下来方便之后查阅。</p>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p>overflow属性规定当内容溢出元素框时发生的事情。</p>
<h4 id="可能的取值"><a href="#可能的取值" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>visible：默认值。内容不会被修剪，会呈现在元素框之外。</li>
<li>hidden：内容会被修剪，并且其余内容是不可见的。</li>
<li>scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</li>
<li>auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</li>
<li>inherit：从父元素继承overflow属性的值。</li>
</ul>
<h4 id="scroll和auto的区别"><a href="#scroll和auto的区别" class="headerlink" title="scroll和auto的区别"></a>scroll和auto的区别</h4><ul>
<li>scroll：内容自动撑开容器的宽度不包括滚动条，相当于滚动条是一个和内容并列显示的组件。</li>
<li><p>auto：内容撑开容器的宽度包括滚动条。即 使用<code>white-space:nowrape;</code>撑开容器至正好显示所有内容时，如果有滚动条，则滚动条会覆盖在内容上方，导致内容宽度被再次缩小，然后出现省略号。由此推断渲染顺序：</p>
<p>  自适应宽度-&gt;根据高度显示滚动条-&gt;重新计算内部元素宽度。 </p>
</li>
</ul>
<p>综上，如果宽度是由内容自适应撑开的，则<code>overflow:auto;</code>带来的滚动条会占用内容的一部分宽度，导致内容显示不全。</p>
<h3 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h3><p>该属性声明建立布局过程中如何处理元素中的空白符。</p>
<h4 id="可能的取值-1"><a href="#可能的取值-1" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>normal：默认值。连续的空白符会被合并，换行符会被当做空白符来处理。填充line盒子时，必要的话会换行。</li>
<li>pre: 连续的空白符会被保留。在遇到换行符或者\<br\>元素时才会换行。</br\></li>
<li>nowrap: 连续的空白符会被合并，文本不会换行，会在同一行上继续，直到遇到\<br\>标签为止。</br\></li>
<li>pre-wrap：连续的空白符会被保留，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>pre-line：连续的空白符会被合并，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>inherit：从父元素继承white-space属性的值。</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="external">参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的定位技术]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>CSS使用top、left、right、bottom设置元素的二维（x轴和y轴）偏移量。使用z-index设置元素垂直于屏幕的方向，也就是“z轴”的偏移量。</p>
<p>CSS使用position选项来定义元素的定位属性，该选项有五个可选值：static、relative、absolute、fixed、inherit，默认值是static。inherit属性表示继承父元素的定位属性，因此只需掌握static、relative、absolute、fixed这四种定位属性的特性即可。</p>
<h3 id="相对定位技术"><a href="#相对定位技术" class="headerlink" title="相对定位技术"></a>相对定位技术</h3><p>相对定位即相对于文档流中的其他已定义的元素位置进行定位。relative和static都是相对于文档其他元素进行定位，都属于相对定位的范畴，区别在于一个可以控制位移，一个不能。</p>
<h4 id="static（默认值）"><a href="#static（默认值）" class="headerlink" title="static（默认值）"></a>static（默认值）</h4><p>如果使用默认值，在CSS中为元素定义top、left、right、 bottom、z-index都不会生效。也就是说，如果想设置元素的偏移量和z-index，必须为元素定义position属性（static除外）。</p>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p>relative的表现和默认值一样，只不过可以通过设置偏移量和z-index来控制相对于其正常位置进行的偏移。</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位的元素有以下几个特点：</p>
<ul>
<li>块级元素的宽度在未定义时不再为100%，而是根据内容自动调整。</li>
<li>在不定义z-index的情况下，absolute元素会覆盖在其他元素之上。</li>
<li>它会脱离正常的文档流，不再占据空间，类似于浮动后的效果。</li>
</ul>
<p>absolute和fixed都属于绝对定位的范畴，都遵循以上3个特点。</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p>absolute是相对上一个不为static的父元素进行绝对定位。也就是说，如果不指定父元素的position，absolute将相对于整个html文档进行绝对定位。</p>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>fixed是相对于浏览器窗口进行定位。也就是说，不论网页如何滚动，该元素始终停留在屏幕的某个位置上。例如：我们希望侧边控制栏始终对用户可见，就可以使用<code>position:fixed</code>来进行定位。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的优先级]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>如何确定CSS的优先级？首先要引入一个机制，分别用4个数字（a, b, c, d）表示优先级组合，它们的意思分别是：    </p>
<ul>
<li>第一个数字（a）表示style属性，优先级最高。由于一般都是class样式，所以该值一般都是0。  </li>
<li>第二个数字（b）是该CSS选择器上的id数量的总和，一般都是1个。</li>
<li>第三个数字（c）是用在该CSS选择器上的其他属性CSS选择器以及伪类的总和。这里包括class（比如 .btn）和属性选择器（比如 li[id=red]）。</li>
<li>第四个数字（d）计算元素（比如 table、p、div等）和伪元素（比如 first-child）。</li>
</ul>
<p>注：</p>
<ul>
<li>通用CSS选择器（*）是0优先级。</li>
<li>如果两个CSS选择器有同样的优先级，则在样式表中后面的那个起作用。</li>
</ul>
<p>几个例子：</p>
<ul>
<li>选择器：<code>#menu h2</code>， 优先级：0,1,0,1。   </li>
<li>选择器： <code>#leftbar li:first-child</code>，优先级： 0,1,0,2。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[又长大一岁啦]]></title>
      <url>https://fantasticzhang.github.io/2016/11/14/%E5%8F%88%E9%95%BF%E5%A4%A7%E4%B8%80%E5%B2%81%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>今天我又长大一岁啦~一大早就收到了爸爸妈妈的祝福和红包，以及好朋友的祝福，真的好开心~因此，想要简单记录一下这开心的一天。但由于博主经验不足图片格式还不太会调，可能看起来不太美观，以后会改正。</p>
<h3 id="美好的一天"><a href="#美好的一天" class="headerlink" title="美好的一天"></a>美好的一天</h3><p><img src="/images/2016-11-14/1.jpg" alt=""></p>
<p>闺蜜送的生日礼物，真的好喜欢，每一年的生日都给我好大的惊喜，也希望之后的每个生日都有你的陪伴。</p>
<p><img src="/images/2016-11-14/2.jpg" alt=""></p>
<p>早晨来到实验室就收到了学弟送的书，真的好感动~而且特意为我选了悬疑推理类的书，很符合我的口味，嘿嘿。真的很开心今年能认识你啦~</p>
<p><img src="/images/2016-11-14/3.jpg" alt=""></p>
<p>有个姐姐就是好，带我来吃海底捞啦，哈哈。一直听说海底捞的服务特别好，今天算是见识到了，店员知道今天我过生日，特意为我唱了生日快乐歌，而且还送了我礼物，真的好棒！对了，还可以免费做美甲，所以吃完饭后就做了一个，好开心。</p>
<p><img src="/images/2016-11-14/4.jpg" alt=""></p>
<p>店员知道今天我过生日，特意为我做了长寿面~</p>
<p><img src="/images/2016-11-14/5.jpg" alt=""></p>
<p>店家送给我的生日礼物，服务真的好周到。</p>
<p><img src="/images/2016-11-14/6.jpg" alt=""></p>
<p>最后，许下一个生日愿望，希望能实现~</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>今天一路上还收到了好多陌生人的祝福，真的好开心。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>https://fantasticzhang.github.io/2016/11/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>终于有自己的博客啦~</p>
<p>其实一直想要建一个属于自己的博客，用来记录自己日常生活中的点点滴滴、学习过程中整理的笔记以及一些技术感悟，记录自己读过的一些论文等，但由于自己的拖延症，一直没有弄:-P。终于，今天我也有了属于自己的博客啦，也希望自己之后能克服懒惰，经常更新。日积月累，总会有收获的。</p>
]]></content>
    </entry>
    
  
  
</search>
