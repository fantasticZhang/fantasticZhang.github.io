<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JavaScript总结之引用类型]]></title>
      <url>https://fantasticzhang.github.io/2017/06/21/JavaScript%E6%80%BB%E7%BB%93%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起，引用类型的值（对象）是引用类型的一个实例。ECMAScript提供了许多原生的引用类型，下面一一简单介绍。</p>
<h1 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h1><p>Object是一个基础类型，其他所有引用类型都从Object继承了基本的行为。</p>
<p>创建Object实例有两种方法：构造函数法和对象字面量法。</p>
<ul>
<li><p>构造函数法：</p>
<pre><code>var person = new Object();
person.name = &quot;zjl&quot;;
person.age = 25;
</code></pre></li>
<li><p>对象字面量法：</p>
<pre><code>var person = {
    name : &quot;zjl&quot;,
    age : 25
};
</code></pre></li>
</ul>
<p>访问对象的属性，有两种方法：点表示法和方括号法。例:</p>
<pre><code>console.log(person.name);
console.log(person[&quot;name&quot;]);
</code></pre><h2 id="ES6新增特性"><a href="#ES6新增特性" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h2><h3 id="属性的简写"><a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h3><p>ES6中，对象中的属性和方法都可以简写，如下所示：</p>
<pre><code>var birth = &apos;2000/01/01&apos;;

var Person = {

  name: &apos;张三&apos;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log(&apos;我的名字是&apos;, this.name); }

};
</code></pre><p>即ES6允许在对象之中直接写变量，此时属性名为变量名，属性值为变量值。而方法也可以按照如上方式简写。</p>
<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>此外，ES6允许字面量定义对象时，用表达式作为对象的属性名或方法名，即把表达式放在方括号内：</p>
<pre><code>var lastWord = &apos;last word&apos;;

var a = {
  &apos;first word&apos;: &apos;hello&apos;,
  [lastWord]: &apos;world&apos;,
  [&apos;h&apos; + &apos;ello&apos;]() {
    return &apos;hi&apos;;
  }
};

a[&apos;first word&apos;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&apos;last word&apos;] // &quot;world&quot;
a.hello();  //&quot;hi&quot;
</code></pre><p>注：</p>
<ul>
<li><p>属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code>// 报错
var foo = &apos;bar&apos;;
var bar = &apos;abc&apos;;
var baz = { [foo] };

// 正确
var foo = &apos;bar&apos;;
var baz = { [foo]: &apos;abc&apos;};    
</code></pre></li>
<li><p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p>
<pre><code>const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
</code></pre></li>
</ul>
<pre><code>  [keyA]: &apos;valueA&apos;,
  [keyB]: &apos;valueB&apos;
};
myObject // Object {[object Object]: &quot;valueB&quot;}
</code></pre><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><p>对象的方法也是函数，因此也有name属性，一般情况下返回方法名，但是有以下三种特殊情况：</p>
<ul>
<li><p>对象的方法使用了取值函数<code>getter</code>和存值函数<code>setter</code>:</p>
<p>此时，<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面。</p>
<pre><code>const obj = {
get foo() {},
set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property &apos;name&apos; of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;);

descriptor.get.name // &quot;get foo&quot;
descriptor.set.name // &quot;set foo&quot;
</code></pre></li>
<li><p><code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code></p>
</li>
<li><p>对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述:</p>
<pre><code>const key1 = Symbol(&apos;description&apos;);
const key2 = Symbol();
let obj = {
[key1]() {},
[key2]() {},
};
obj[key1].name // &quot;[description]&quot;
obj[key2].name // &quot;&quot;
</code></pre></li>
</ul>
<h3 id="新增的一些方法"><a href="#新增的一些方法" class="headerlink" title="新增的一些方法"></a>新增的一些方法</h3><ul>
<li>Object.is()：用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</li>
<li><p>Object.assign()：用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）：</p>
<ul>
<li>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）；</li>
<li>第一个参数是目标对象，后面的参数都是源对象;</li>
<li>目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性;</li>
<li>如果只有一个参数，Object.assign会直接返回该参数;</li>
<li>如果该参数不是对象，则会先转成对象;</li>
<li>如果非对象参数出现在目标对象的位置，且为<code>undefined</code>或<code>null</code>，则会报错；</li>
<li>如果非对象参数出现在源对象的位置（即非首参数），且无法转成对象，就会跳过。即，如果undefined和null不在首参数，就不会报错；除了字符串会以数组形式，拷贝到目标对象，其他值都不会产生效果；</li>
<li>Object.assign方法实行的是浅拷贝，而不是深拷贝。</li>
</ul>
</li>
<li><p>Object.getOwnPropertyDescriptor()：获取指定属性的描述对象。</p>
</li>
<li><p>属性的遍历：</p>
<ul>
<li>for…in：for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</li>
<li>Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有Symbol属性。</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</li>
</ul>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为 Symbol 值的属性，按照生成时间排序。</li>
</ul>
</li>
<li><p>Object.setPrototypeOf()：作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身。</p>
</li>
<li>Object.getPrototypeOf()：与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。</li>
<li>Object.values()：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。返回数组的成员顺序，与上文中的属性的遍历部分介绍的排列规则一致。</li>
<li>Object.entries()：方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</li>
<li>Object.getOwnPropertyDescriptors()：返回指定对象所有自身属性（非继承属性）的描述对象。</li>
</ul>
<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<pre><code>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre><p>注：</p>
<ul>
<li>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。</li>
<li>解构赋值必须是最后一个参数，否则会报错。</li>
<li>解构赋值不会拷贝继承自原型对象的属性。</li>
</ul>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于使用Object.assign方法。</p>
<pre><code>let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。放在扩展运算符之前，相当于设置默认值。</p>
<pre><code>let aWithOverrides = { ...a, x: 1, y: 2 };
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
</code></pre><p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p>
<pre><code>// 并不会抛出错误，因为x属性只是被定义，但没执行
let aWithXGetter = {
  ...a,
  get x() {
    throws new Error(&apos;not thrown yet&apos;);
  }
};

// 会抛出错误，因为x属性被执行了
let runtimeError = {
  ...a,
  ...{
    get x() {
      throws new Error(&apos;thrown now&apos;);
    }
  }
};
</code></pre><p>如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。</p>
<pre><code>let emptyObject = { ...null, ...undefined }; // 不报错
</code></pre><h1 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h1><p>ECMAScript中的Array类型和其他语言中的数组有很大不同：ECMAScript数组的每一项可以保存任何类型的数据；数组的大小是可以动态调整的。</p>
<h2 id="创建Array类型"><a href="#创建Array类型" class="headerlink" title="创建Array类型"></a>创建Array类型</h2><p>创建数组有两种方法：构造函数法和数组字面量表示法。</p>
<ul>
<li><p>构造函数法：</p>
<pre><code>var colors = new Array(3);      //创建一个包含3项的数组
var names = new Array(&quot;Greg&quot;);  //创建一个包含1项（&quot;Greg&quot;)的数组
</code></pre></li>
<li><p>数组字面量表示法：</p>
<pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
var names = [];                        //创建一个空数组
</code></pre></li>
</ul>
<p>数组有一个<code>length</code>属性，表示该数组中元素的个数。<code>length</code>属性可以修改，通过修改该属性，可以从数组末尾移除项或向数组中添加新项。</p>
<h2 id="Array类型的方法"><a href="#Array类型的方法" class="headerlink" title="Array类型的方法"></a>Array类型的方法</h2><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>检测某个对象是否为数组有两种方法：<code>instanceof</code>操作符和<code>Array.isArray()</code>。</p>
<ul>
<li>使用<code>instanceof</code>的缺点：只针对一个全局作用域而言，如果有多个全局执行环境，则结果可能不准确；</li>
<li>Array.isArray()：只检测该值是不是数组，而不管其属于哪一个全局执行环境。</li>
</ul>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><ul>
<li>toString()：返回数组中每个值的字符串形式拼接成的一个以逗号为分隔符的字符串（会调用每一项的toString方法）；</li>
<li>toLocaleString()：与toString的唯一区别是：会调用每一项的toLocaleString方法；</li>
<li>valueOf()：返回数组本身。</li>
</ul>
<p>还可以使用join()方法对数组进行转换，该方法接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];   
alert(colors.toString());    //red,blue,green
alert(colors.valueOf());     //red,blue,green
alert(colors);               //red,blue,green
alert(colors.join(&quot;,&quot;));      //red,green,blue
alert(colors.join(&quot;||&quot;));     //red||green||blue
</code></pre><p>注：alert()方法要接收字符串参数，因此如果参数是数组会后台自动调用toString()方法。</p>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><ul>
<li>push()：参数为任意多个项，依次放到数组末尾，返回数组长度。</li>
<li>pop()：删除最后一项，返回删除的项。</li>
</ul>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><ul>
<li><p>数组的首尾依次与队列的首尾对应：</p>
<ul>
<li>入队：push()；</li>
<li>出队：shift()，移除数组中的第一项并返回该项。</li>
</ul>
</li>
<li><p>数组的首对应队尾，数组的末端对应队头：</p>
<ul>
<li>入队：unshift()，参数为任意多项，在数组前端添加任意多个项并返回新数组的长度；</li>
<li>出队：pop()。</li>
</ul>
</li>
</ul>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><ul>
<li>reverse()：数组元素倒置；</li>
<li>sort()：对数组进行排序。默认将数组每一项转换为<strong>字符串</strong>（调用每一项的<code>toString</code>方法），然后比较字符串升序排序。该方法可接收一个排序函数，该排序函数有两个值作为参数，当函数返回正则第一个值应排在第二个值之后；当函数返回负则第一个值应排在第二个值之前；返回0则两个值相等。</li>
</ul>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul>
<li>concat()：参数可有多个，可为项或数组。返回一个新数组，该数组为原来的数组的基础上增加参数；</li>
<li>slice()：第一个参数：起始位置；第二个参数（可选）：结束位置；返回起始到结束（不包括结束位置）之间的项组成的数组。如果传入负数，则会将负参数加上该数组的长度；如果结束位置小于起始位置，则返回空数组；</li>
<li><p>splice()：会更改（删除、插入、替换）调用该函数的数组，返回值为删除项组成的数组。</p>
<ul>
<li>删除：传入两个参数，要删除的第一项的位置和删除的项数；</li>
<li>插入：传入三个及以上参数：起始位置、0、要插入的项；</li>
<li>替换：传入三个及以上参数：起始位置、删除的项数、要插入的项。</li>
</ul>
</li>
</ul>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>有indexOf()和lastIndexOf()两个方法。均接收至多两个参数：要查找的项和（可选）标识查找起点位置的索引。</p>
<ul>
<li>indexOf()：从数组的开头开始向后查找；</li>
<li>lastIndexOf()：从数组的尾部开始向前查找。</li>
</ul>
<p>这两个方法要求查找的项必须严格相等（使用<code>===</code>)，因此如果数组中存在<code>NaN</code>项，则无法查找到。</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>有五个方法，每个方法都接收至多两个参数。第一个参数：在每一项上运行的函数（该函数的参数有三个：item(当前项的值),index(该项在数组中的位置),array(数组对象本身)）；第二个参数(可选):运行该函数的作用域对象，会影响<code>this</code>的值。</p>
<ul>
<li>every()：对数组的每一项运行给定函数，如果该函数对每一项都返回<code>true</code>，则最终结果返回<code>true</code>。只要其中一项返回了<code>false</code>，就不再遍历，直接得到最终结果（<code>false</code>）；</li>
<li>some()：对数组的每一项运行给定函数，如果对任一项返回<code>true</code>，最终结果就会返回<code>true</code>。只要其中一项返回了<code>true</code>，就不再遍历，直接得到最终结果（<code>true</code>）；</li>
<li>filter()：对数组的每一项运行给定函数，返回该函数会返回<code>true</code>的项组成的数组；</li>
<li>map()：对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组；</li>
<li>forEach()：对数组的每一项运行给定函数，没有返回值。</li>
</ul>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>有两个方法：reduce()（从头开始向后遍历数组）和reduceRight()（从尾开始向前遍历数组），这两个方法都会迭代数组的所有项，然后构成一个最终返回的值。每个方法接收至多两个参数：在每一项上调用的函数和作为归并基础的初始值（可选）。</p>
<p>传递的函数有四个参数：<code>prev</code>前一个值，<code>cur</code>当前值，<code>index</code>项的索引，<code>array</code>数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。如果未传入作为归并基础的初始值，则第一次迭代发生在数组的第二项，因此第一次迭代的<code>prev</code>的值是数组的第一项；如果传入了初始值，则第一次迭代发生在数组的第一项。</p>
<pre><code>var values = [1,2,3,4,5];
var sum1 = values.reduce(function(prev, cur, index, array){
    return prev + cur;

});
console.log(sum1);  //15

var sum2 = values.reduce(function(prev,cur,index,array){
     return prev+cur;

},10);
console.log(sum2);  //25

var sum3 = values.reduceRight(function(prev,cur,index,array){
    return prev*cur;
})
console.log(sum3);  //120

var sum4 = values.reduceRight(function(prev,cur,index,array){
    return prev*cur;
},10);
console.log(sum4);  //1200
</code></pre><h2 id="ES6新增特性-1"><a href="#ES6新增特性-1" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h2><ul>
<li><p>Array.from()：</p>
<p>用于将两类对象转为真正的数组：类似数组的对象和可遍历（具有Iterator接口）的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>lengt</code>h属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组。此外。扩展运算符<code>...</code>也能将可遍历的对象转为真正的数组。可接收三个参数：第一个参数要转换的对象（必须）；第二个参数是一个函数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组；第三个参数用来绑定第二个参数中的<code>this</code>。</p>
</li>
<li>Array.of()：用于将一组值，转换为数组。</li>
<li><p>Array.prototype.copyWithin(target, start = 0, end = this.length)：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。如果是非数值，则会转化为数值，如果为负数，则从倒数的位置开始。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
</li>
<li><p>Array.prototype.find(callback)：找出第一个符合条件（返回值为<code>true</code>）的数组成员。</p>
</li>
<li>Array.prototype.findIndex(callback)：用法与find方法非常类似，返回第一个符合条件的数组成员的位置。</li>
<li>Array.prototype.fill：使用给定值，填充一个数组。</li>
<li>数组实例的entries()，keys()和values()：用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</li>
<li>Array.prototype.includes：返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。如果数组中有项<code>NaN</code>，是可以查找到的。</li>
<li><p>对于数组的空位，ES6则是明确将空位转为undefined：</p>
<ul>
<li>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</li>
<li>扩展运算符（…）也会将空位转为undefined。</li>
<li>copyWithin()会连空位一起拷贝。</li>
<li>fill()会将空位视为正常的数组位置。</li>
<li>for…of循环也会遍历空位。</li>
<li>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</li>
</ul>
<p>ES5 对空位的处理则很不一致：</p>
<ul>
<li>forEach(), filter(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
</li>
</ul>
<h1 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h1><p>提供了有关日期和时间的信息。</p>
<h2 id="创建Date类型"><a href="#创建Date类型" class="headerlink" title="创建Date类型"></a>创建Date类型</h2><p>创建一个Date类型的实例，有以下三种方法：</p>
<ul>
<li><p>Date构造函数法（基于本地时区创建）：</p>
<pre><code>var date = new Date();
</code></pre><p>在调用构造函数且不传递任何参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建Date对象，则必须传入毫秒数，因此有下面几种方法。</p>
</li>
<li><p><code>Date.parse()</code>（基于本地时区创建）：</p>
<p><code>Date.parse()</code>接收一个字符串，然后尝试根据这个字符串返回相应日期的毫秒数。如果传入的字符串不能表示日期，则返回NaN。传入的字符串可以有多种形式。</p>
<pre><code>var someDate = new Date(Date.parse(&quot;May 18, 2017&quot;));
someDate = new Date(Date.parse(&apos;5/18/2017&apos;));
someDate = new Date(Date.parse(&quot;Thu May 18 2017 09:53:23 GMT+0800&quot;));
someDate = new Date(Date.parse(&quot;2017-05-18T09:54:21&quot;));
</code></pre><p>实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用<code>Date.parse()</code>方法。</p>
</li>
<li><p><code>Date.UTC()</code>（基于GMT创建）：</p>
<p>同样返回的是表示日期的毫秒数，但它进行的是一种<strong>绝对运算</strong>，传入的时间就是UTC时间，不会转换为当地时间。</p>
<p>可接收7个参数，分别是年份、基于0的月份、月中的天（1~31）、小时数（0~23）、分钟、秒、毫秒。只有前两个参数是必须的。</p>
<pre><code>var allFives = new Date(Date.UTC(2017,4, 18, 17, 55, 55)); //Fri May 19 2017 01:55:55 GMT+0800 (中国标准时间)
</code></pre></li>
</ul>
<p>GMT：世界时，即格林尼治所在地区的标准时间 （它刚好是本初子午线经过的地方）。往东的时区时间晚（表示为GMT+hh:mm)；往西的时区时间早(表示为GMT-hh:mm)。</p>
<h2 id="Date类型的方法"><a href="#Date类型的方法" class="headerlink" title="Date类型的方法"></a>Date类型的方法</h2><ul>
<li>得到当前时间的毫秒数：<code>var start=Date.now()</code>；</li>
<li>继承的方法：<code>toLocaleString()</code>、<code>toString()</code>，返回日期和时间，根据浏览器的不同而不同；<code>valueOf()</code>返回日期的毫秒表示；</li>
<li>日期格式化的方法（Date：星期几、月、日和年；Time：时、分、秒和时区）：toDateString()、toTimeString()、toLocaleDateString()、toLocaleTimeString()、toUTCString()；</li>
<li>其他方法：<code>getTime()</code>返回表示日期的毫秒数（同<code>valueOf</code>）， <code>setTime()</code>以毫秒数设置日期，<code>getTimezoneOffset()</code>返回本地时间与UTC时间相差的分钟数，getFullYear()、getUTCFullYear()、getMonth()、getUTCMonth()、getDate()、getDay()、getHours()、getMinuates()、getSeconds()、getMilliseconds()等等。</li>
</ul>
<h1 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h1><p>提供了有关正则表达式的一些功能。</p>
<h2 id="创建RegExp类型"><a href="#创建RegExp类型" class="headerlink" title="创建RegExp类型"></a>创建RegExp类型</h2><p>有两种方法：正则表达式字面量形式和RegExp构造函数法。</p>
<ul>
<li><p>正则表达式字面量形式：</p>
<p>语法：<code>var expression = /pattern/flags;</code>。其中pattern为模式，可以是任何简单化复杂的正则表达式；flags为标志，用以表明正则表达式的行为。flags的取值可以是：<code>g</code>（全局模式），<code>i</code>（不区分大小写模式），<code>m</code>（多行模式）。</p>
<pre><code>var pattern = /.at/gi;  //匹配虽有以&quot;at&quot;结尾的3个字符的组合，不区分大小写。
</code></pre><p>正则表达式中的<strong>元字符</strong>包括：<code>( [ { \ ^ $ | ) ? * + . } ]</code>。模式中使用的所有元字符必须转义。</p>
</li>
<li><p>RegExp构造函数：</p>
<p>接收两个参数：要匹配的字符串模式；可选的标志字符串。</p>
<pre><code>var pattern = new RegExp(&quot;.at&quot;,&quot;gi&quot;);  //匹配虽有以&quot;at&quot;结尾的3个字符的组合，不区分大小写。
</code></pre><p>由于构造函数的模式参数是字符串，因此所有元字符都必须<strong>双重转义</strong>。</p>
</li>
</ul>
<h2 id="RegExp类型的属性和方法"><a href="#RegExp类型的属性和方法" class="headerlink" title="RegExp类型的属性和方法"></a>RegExp类型的属性和方法</h2><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><ul>
<li>global：布尔值，表示是否设置了<code>g</code>标志；</li>
<li>ignoreCase：布尔值，表示是否设置了<code>i</code>标志；</li>
<li>multiline：布尔值，表示是否设置了<code>m</code>标志；</li>
<li>source：正则表达式的字符串表示。注意是按照字面量形式而非传入构造函数中的字符串模式返回；</li>
<li>lastIndex：整数值，表示开始搜索下一个匹配项的字符位置。</li>
</ul>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p>exec()</p>
<p>接收一个参数，即应用该模式的字符串。返回值是包含第一个匹配项信息的数组或者<code>null</code>，返回数组的第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。此外，该函数还有两个属性：<code>input</code>表示应用正则表达式的字符串；<code>index</code>表示匹配项在字符串中的位置。</p>
<pre><code>var text2 = &quot;cat, bat, sat, fat&quot;;
var pattern1 = /(.)at/g;

var matches2 = pattern1.exec(text2);
console.log(matches2.index);    //0
console.log(matches2[0]);       //&quot;cat&quot;
console.log(matches2[1]);       //&quot;c&quot;
console.log(pattern1.lastIndex);//3

matches2 = pattern1.exec(text2);
console.log(matches2.index);    //5
console.log(matches2[0]);       //&quot;bat&quot;
console.log(matches2[1]);       //&quot;b&quot;
console.log(pattern1.lastIndex);//8
</code></pre><p>全局模式和非全局模式的区别：全局模式下，每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直至末尾；非全局模式下每次调用<code>exec()</code>返回的都是第一个匹配项。</p>
</li>
<li><p>test()</p>
<p>接收一个字符串参数。在模式与该参数匹配的情况下返回<code>true</code>；否则返回<code>false</code>。</p>
</li>
<li><p>toLocaleString()、toString()：返回正则表达式的字面量（字符串形式）；valueOf()：返回正则表达式<strong>本身</strong>。</p>
</li>
</ul>
<h3 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h3><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的<strong>最近一次</strong>正则表达式操作而变化。每个属性都有两种访问方式：</p>
<ul>
<li><code>input</code>或<code>$_</code>：最近一次要匹配的字符串；</li>
<li><code>lastMatch</code>或<code>$&amp;</code>：最近一次的匹配项；</li>
<li><code>lastParen</code>或<code>$+</code>：最近一次匹配的捕获组；</li>
<li><code>leftContent</code>或$反引号:input字符串中lastMatch之前的文本；</li>
<li><code>rightContent</code>或<code>$&#39;</code>：input字符串中lastMatch之后的文本；</li>
<li><code>$n</code>：n的取值1-9，分别存储第一个、第二个、…第九个匹配的捕获组。</li>
</ul>
<h2 id="ES6新增特性-2"><a href="#ES6新增特性-2" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符（ES5中不可以）。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<pre><code>new RegExp(/abc/ig, &apos;i&apos;).flags
// &quot;i&quot;
</code></pre><p>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</p>
<p>上面代码中的<code>flags</code>属性ES6为正则表达式新增的，会返回正则表达式的<strong>修饰符</strong>。</p>
<h3 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a><code>u</code>修饰符</h3><p>ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。</p>
<pre><code>/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)
// false
/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)
// true

/\u{20BB7}/u.test(&apos;𠮷&apos;) // true
</code></pre><p>使用了<code>u</code>修饰符，<code>.</code>可以代表任何字符，包括4字节的UTF-16字符；正则表达式中也可正常使用\u{}的形式来表示码点超过<code>\uFFFF</code>的字符了。</p>
<h3 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a><code>y</code> 修饰符</h3><p><code>y</code>修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code>var s = &apos;aaa_aa_a&apos;;
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null
</code></pre><p>与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<pre><code>var r = /hello\d/y;
r.sticky // true

/abc/ig.flags
// &apos;gi&apos;
</code></pre><p>但是，单单一个<code>y</code>修饰符对match方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p>
<h3 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h3><p>”先行断言“指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。”后行否定断言“则与”先行否定断言“相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<p>“后行断言”时，执行顺序是从右到左；”后行断言”的反斜杠引用，与通常的顺序相反，必须放在对应的那个括号之前。</p>
<pre><code>/(?&lt;=(o)d\1)r/.exec(&apos;hodor&apos;)  // null
/(?&lt;=\1d(o))r/.exec(&apos;hodor&apos;)  // [&quot;r&quot;, &quot;o&quot;]
</code></pre><p>目前只是一个提案。V8 引擎4.9版已经支持，Chrome 浏览器49版打开”experimental JavaScript features“开关（地址栏键入about:flags），就可以使用这项功能。</p>
<h1 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h1><p>ECMAScript中的函数实际上是对象，即每个函数都是Function类型的实例，而且与其他引用类型一样具有属性和方法。因此每个函数名实际上也是一个指向函数对象的指针。</p>
<h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p>创建一个函数有三种方法：函数声明法，函数表达式法，Function构造函数法。</p>
<ul>
<li><p>函数声明法</p>
<pre><code>function sum(num1,num2){
    return num1+num2;
}
</code></pre></li>
<li><p>函数表达式法</p>
<pre><code>var sum=function(num1,num2){
    return num1+num2;
};    //注意结尾要加分号
</code></pre></li>
<li><p>Function构造函数</p>
<pre><code>var sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);  //最后一个参数始终被看成是函数体
</code></pre></li>
</ul>
<p>由于这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串，因此不推荐这种方法。</p>
<p>函数声明和函数表达式的区别：JS解析器有一个<strong>函数声明提升</strong>的过程，即在代码开始执行之前，JS引擎会读取函数声明并将它们放到源代码树的顶部。因此，如果使用函数声明的方式定义函数，则即使声明函数的代码在调用它的代码后面，JS引擎也能把函数声明提升到顶部，代码不会出错。但是，如果使用函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。所以如果函数表达式在调用它的代码之后，会在执行期间导致错误。</p>
<p>由于JS中的每个函数名实际上也是一个指向函数对象的指针，所以相同的函数名实际上是同一个变量，因此<strong>没有重载</strong>。例：</p>
<pre><code>function addSomeNumber(num）{
    return num + 100;
}

function addSomeNumber(num) {
    return num+200;
}
var result=addSomeNumber(100); //300
</code></pre><p>以上的代码等同于下面的代码：</p>
<pre><code>var addSomeNumber = function(num){
    return num + 100;
};
addSomeNumber = function(num){
   return num + 200;
};
var result=addSomeNumber(100); //300
</code></pre><p>即在创建第二个函数时，实际上覆盖了引用第一个函数的变量<code>addSomeNumber</code>。</p>
<h2 id="Function类型的属性和方法"><a href="#Function类型的属性和方法" class="headerlink" title="Function类型的属性和方法"></a>Function类型的属性和方法</h2><ul>
<li><p>函数内部属性：</p>
<ul>
<li>arguments：是一个类数组对象，包含着传入函数中的所有参数。其中<code>arguments.callee</code>是一个指针，指向拥有这个arguments对象的函数；</li>
<li>this：引用的是函数据以执行的环境对象。</li>
</ul>
</li>
<li><p>函数对象的属性：</p>
</li>
<li><p>length：函数希望接收的命名参数的个数（不包括设置了默认值的参数）；</p>
</li>
<li><p>caller：保存着调用当前函数的函数的引用，如果在全局作用域调用当前函数，则它的值为<code>null</code>。例：</p>
<pre><code>function outer(){
     inner();
 }

 function inner(){
     alert(arguments.callee.caller);
 }

 outer();    //会显示outer函数的源代码
</code></pre></li>
<li><p>函数对象的方法：</p>
<ul>
<li><p>call()和apply()：在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p>
<ul>
<li>call()：第一个参数是在其中运行函数的作用域，后面的参数<strong>*依次</strong>为传递的参数</li>
<li>apply()：第一个参数是在其中运行函数的作用域，第二个参数是参数数组，可以是Array实例，也可以是arguments对象。</li>
</ul>
</li>
<li><p>bind()：会创建一个函数的实例，其this值会被绑定到传给bind()函数的参数，且以后不会变。</p>
</li>
<li>toLocaleString()、toString()、valueOf()：返回函数的代码。</li>
</ul>
</li>
</ul>
<h2 id="ES6新增特性-3"><a href="#ES6新增特性-3" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h2><p>总的来说，ES6中对于函数新增的特性主要有两个：一是函数参数方面的扩展（可以设默认值、rest参数、扩展运算符等）；二是箭头函数。</p>
<h3 id="函数参数新增的特性"><a href="#函数参数新增的特性" class="headerlink" title="函数参数新增的特性"></a>函数参数新增的特性</h3><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x, y = &apos;World&apos;) {
  console.log(x, y);
}

log(&apos;Hello&apos;) // Hello World
log(&apos;Hello&apos;, &apos;China&apos;) // Hello China
log(&apos;Hello&apos;, &apos;&apos;) // Hello
</code></pre><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真(<code>length</code>属性的含义是，该函数预期传入的参数个数。)，而且如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。此外，一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code>(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
</code></pre><p>ES6 引入 <code>rest</code> 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。<code>rest</code> 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code>function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
</code></pre><p>扩展运算符是三个点（<code>...</code>）。它好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<pre><code>function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers) // 42
</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<pre><code>var f = v =&gt; v;
</code></pre><p>上面的箭头函数等同于：</p>
<pre><code>var f = function(v) {
  return v;
};
</code></pre><p>另一个例子：</p>
<pre><code>// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);
</code></pre><p>箭头函数有几个使用注意点。</p>
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
<h3 id="函数的name属性"><a href="#函数的name属性" class="headerlink" title="函数的name属性"></a>函数的name属性</h3><p>返回该函数的函数名。</p>
<p>如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<pre><code>var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre><p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</p>
<pre><code>const bar = function baz() {};

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;
</code></pre><p>Function构造函数返回的函数实例，name属性的值为anonymous。</p>
<pre><code>(new Function).name // &quot;anonymous&quot;
</code></pre><p>bind返回的函数，name属性值会加上bound前缀。</p>
<pre><code>function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;
</code></pre><h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>ECMAScript提供了三种特殊的引用类型：Boolean、Number、String，分别与三种基本类型对应。每当读取一个基本类型值的例：候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。例：</p>
<pre><code>var str = &quot;wenhaoyang&quot;;
var str2 = str.substring(3);
</code></pre><p>执行第二行代码时，<code>str</code>处于读取模式，因此后台会自动进行下列过程：</p>
<ol>
<li>创建一个<code>String</code>类型的实例；</li>
<li>在实例上调用指定的方法；</li>
<li>销毁这个实例。</li>
</ol>
<p>所以，引用类型与基本包装类型的主要区别是对象的<strong>生存期</strong>。如果用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中；而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。例：</p>
<pre><code>var s1 = &quot;some text&quot;;
s1.color = &quot;red&quot;;
alert(s1.color);   //undefined
</code></pre><p>原因：第二行创建的String对象在执行第三行代码时已经被销毁了，第三行代码又创建自己的String对象，而该对象没有color属性。</p>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>创建Boolean类型的实例：</p>
<pre><code>var booleanObject = new Boolean(true);   //注意此时是object，而不是boolean基本类型
</code></pre><p>Boolean类型的实例的<code>valueOf()</code>方法会返回基本类型值true或false；<code>toString()</code>方法会返回字符串”true”或”false”。</p>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><h3 id="创建Number类型的实例"><a href="#创建Number类型的实例" class="headerlink" title="创建Number类型的实例"></a>创建Number类型的实例</h3><pre><code>var numberObject = new Number(10);
</code></pre><h3 id="实例的方法"><a href="#实例的方法" class="headerlink" title="实例的方法"></a>实例的方法</h3><ul>
<li>valueOf()：返回对象表示的基本类型的数值</li>
<li>toString()（可传递表示基数的参数）、toLocaleString()：返回字符串形式的数值；</li>
<li>toFixed():接收一个参数指定小数位，然后会按照指定的小数位返回数值的字符串表示；</li>
<li><p>toExponential():接收一个参数用来指定输出结果中的小数位数，返回以指数表示法表示的数值的字符串形式。</p>
<pre><code>例：
var num=10;
alert(num.toExponential(1)); //&quot;1.0e+1&quot;
</code></pre></li>
<li><p>toPrecision()：接收一个参数用来指定表示数值的所有数字位数（不包括指数部分），然后根据实际情况，返回固定大小格式（fixed）或指数格式（exponential）。</p>
</li>
</ul>
<h3 id="ES6新增特性-4"><a href="#ES6新增特性-4" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h3><ul>
<li><code>Number.isFinite()</code>：检查一个数值是否为有限的;</li>
<li><code>Number.isNaN()</code>：检查一个值是否为<code>NaN</code>；这两个新方法只对数值有效，即不会对非数值进行转换。非数值一律返回false。</li>
<li><code>Number.parseInt()</code>,<code>Number.parseFloat()</code>：ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。</li>
<li><code>Number.isInteger()</code>：用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</li>
<li><code>Number.EPSILON</code>：新增的一个极小的常量。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。</li>
<li><code>Number.isSafeInteger()</code>：用来判断一个整数是否落在安全范围之内（<code>Number.MIN_SAFE_INTEGER</code>）到（<code>Number.MAX_SAFE_INTEGER</code>）之间）。</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="创建String类型的实例"><a href="#创建String类型的实例" class="headerlink" title="创建String类型的实例"></a>创建String类型的实例</h3><pre><code>var stringObject = new String(&quot;hello world&quot;);
</code></pre><p>实例的valueOf()、toString()、toLocaleString()：返回对象表示的基本字符串值；实例的<code>length</code>属性：表示字符串中包含的<strong>字符</strong>数量。</p>
<h3 id="实例的方法-1"><a href="#实例的方法-1" class="headerlink" title="实例的方法"></a>实例的方法</h3><ul>
<li><p>字符方法</p>
<ul>
<li>charAt()：以单字符字符串的形式返回给定位置的那个字符；</li>
<li>charCodeAt()：返回给定位置的那个字符对应的字符编码（number类型）。</li>
</ul>
</li>
<li><p>字符串操作方法</p>
<ul>
<li>concat()：可接收任意多个参数，用于将一个或多个字符串拼接起来，返回拼接得到的新字符串；</li>
<li>slice()和subString()：第一个参数：指定起始位置；第二个参数：指定结束位置。返回从起始位置到结束位置的前一个位置的子串；</li>
<li>subStr()：第一个参数：指定起始位置；第二个参数：指定返回的字符个数。返回相应的子串。</li>
</ul>
<p>如果传递给这些方法的参数是负数，则：</p>
<ul>
<li>slice()：将传入的负值与字符串的长度相加；</li>
<li>subString()：第一个参数为负则加上字符串的长度；第二个参数为负则转换为0。<strong>注</strong>：该函数总是将较小的数作为开始位置，较大的数作为结束位置；</li>
<li>subStr()：把所有负值参数都转换为0。</li>
</ul>
</li>
<li><p>字符串位置方法</p>
<p>indexOf()和lastIndexOf()：从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（如果没有，则返回-1）。都支持第二个参数，表示开始搜索的位置。如果第一个参数不是字符串，则会先进行转换。</p>
<p>区别：indexOf()从字符串的开头向后搜索；lastIndexOf()从字符串的末尾向前搜索。</p>
</li>
<li><p>trim()</p>
<p>创建一个字符串的副本，删除前置及后缀的所有空格，之后返回结果。</p>
</li>
<li><p>字符串大小写转换方法</p>
</li>
</ul>
<p>toLowerCase()、toUpperCase()、toLocaleLowerCase()、toLocaleUpperCase()</p>
<ul>
<li><p>字符串模式匹配方法</p>
<ul>
<li>match()：本质上与调用RegExp的exec()方法相同。该方法值接收一个参数（正则表达式或RegExp对象）。</li>
<li>search()：接收参数同<code>match()</code>，返回字符串中第一个匹配项的索引，如果没有找到匹配项则返回-1。注：该方法始终从字符串开头向后查找。</li>
<li><p>replace()：两个参数，第一个参数可以是一个RegExp对象或一个字符串（<strong>这个字符串不会被转换成正则表达式</strong>）；第二个参数可以是一个字符串或一个函数。</p>
<ul>
<li>如果第一个参数是字符串或未指定全局(g)的RegExp对象，则只会替换第一个子字符串。如果想替换所有的子字符串，则提供一个正则表达式，并指定为全局(g)。</li>
<li>第二个参数是字符串：可以使用一些特殊的字符序列（<code>$$</code>，<code>$&amp;</code>，<code>$&#39;</code>，$反引号，<code>$n</code>,<code>$nn</code>)，将正则表达式操作得到的值插入到结果字符串中。</li>
<li><p>第二个参数是函数：</p>
<ul>
<li>在只有一个匹配项的情况下，会传递3个参数：模式的匹配项(match)、模式匹配项在字符串中的位置(pos)、原始字符串(originalText)。返回一个字符串，表示应该被替换的字符串；</li>
<li>如果正则表达式定义了多个捕获组，传递的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项…但最后两个参数仍然是模式的匹配项在字符串中的位置和原始字符串。</li>
</ul>
</li>
</ul>
</li>
<li><p>split()：基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。其中，分隔符可以是字符串也可以是RegExp对象。还可以用第二个参数指定结果数组的大小。</p>
</li>
</ul>
</li>
<li><p>localCompare()</p>
<p>比较两个字符串，并返回下列在值中的一个：</p>
<ul>
<li>字符串在<strong>字母表</strong>中应排在字符串参数之前：返回一个负数；</li>
<li>字符串等于字符串参数：返回0</li>
<li>字符串在字母表中应排在字符串参数之后：返回一个正数。</li>
</ul>
</li>
<li><p>fromCharCode()</p>
<p>静态方法，接收多个字符编码，然后将它们转换成一个字符串并返回。</p>
</li>
</ul>
<h1 id="Global对象和Math对象"><a href="#Global对象和Math对象" class="headerlink" title="Global对象和Math对象"></a>Global对象和Math对象</h1><h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>ES5中，Global对象的属性与全局变量是等价的，即：不属于任何其他对象的属性和方法，最终都是Global对象的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。ES6中，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；但<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>
<p>Global对象在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。</p>
<h3 id="获取Global对象"><a href="#获取Global对象" class="headerlink" title="获取Global对象"></a>获取Global对象</h3><pre><code>// 方法一
(typeof window !== &apos;undefined&apos;
   ? window
   : (typeof process === &apos;object&apos; &amp;&amp;
      typeof require === &apos;function&apos; &amp;&amp;
      typeof global === &apos;object&apos;)
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== &apos;undefined&apos;) { return self; }
  if (typeof window !== &apos;undefined&apos;) { return window; }
  if (typeof global !== &apos;undefined&apos;) { return global; }
  throw new Error(&apos;unable to locate global object&apos;);
};
</code></pre><h3 id="Global对象的方法"><a href="#Global对象的方法" class="headerlink" title="Global对象的方法"></a>Global对象的方法</h3><ul>
<li><p>URI编码：</p>
<ul>
<li>encodeURI()：不会对本身属于URI的特殊字符进行编码，主要用于整个URI。</li>
<li>encodeURIComponent()：会对它发现的任何非标准字符进行编码，主要用于对URI中的某一段的编码。</li>
<li>相对应的解码方法：decodeURI()、decodeURIComponent()</li>
</ul>
</li>
<li><p>eval()方法</p>
<p>只接受一个参数：要执行的ECMAScript字符串。它会将传入的参数当做实际的ECMAScript语句来解析，然后把执行结果插入到原位置。<br>在eval()中创建的任何变量或函数都不会被提升。严格模式下外部访问不到eval()中创建的任何变量或函数。</p>
</li>
</ul>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><ul>
<li><p>Math对象的属性：<code>Math.E``、Math.LN10</code>、<code>Math.LN2</code>、<code>Math.LOG2E</code>、<code>Math.LOG10E</code>、<code>Math.PI</code>、<code>Math.SQRT1_2</code>、<code>Math.SQRT2</code>；</p>
</li>
<li><p>Math对象的方法:</p>
<ul>
<li>min()、max()：传入任意多个数值参数，然后确定最小值或最大值</li>
<li>舍入方法：<code>Math.ceil()</code>执行向上舍入<code>；Math.floor()</code>执行向下舍入；<code>Math.round()</code>执行四舍五入；</li>
<li>random()：返回大于等于0小于1的一个随机数。从某个整数范围内随机选取一个值的方法：<code>Math.floor(Math.random()*可能值 的总数+第一个可能值)</code></li>
<li>其他方法：Math.abs(num)、Math.exp(num)、Math.log(num)、Math.pow(num,power)、Math.sqrt(num)、Math.acos(num)、Math.asin(num)、Math.atan(num)、Math.atan2(y,x)(y/x的反正切值）、Math.cos(num)、Math.sin(num)、Math.tan(num)。</li>
</ul>
</li>
</ul>
<h3 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h3><ul>
<li><p><code>Math.trunc()</code>：用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值，对于空值和无法截取整数的值，返回NaN。</p>
<ul>
<li><p><code>Math.sign()</code>：用来判断一个数到底是正数、负数、还是零。对于非数值，使用Number方法将其先转为数值再进行判断。</p>
</li>
<li><p>参数为正数，返回+1；</p>
</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
</li>
</ul>
<ul>
<li><code>Math.cbrt()</code>：用于计算一个数的立方根。对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</li>
<li><code>Math.clz32()</code>：返回一个数的32位无符号整数形式有多少个前导0。对于小数，Math.clz32方法只考虑整数部分；对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</li>
<li><code>Math.imul()</code>：返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。<code>Math.imul(0x7fffffff, 0x7fffffff) // 1</code></li>
<li><code>Math.fround()</code>：返回一个数的单精度浮点数形式。先使用Number方法将其转为数值。</li>
<li><code>Math.hypot()</code>：返回所有参数的平方和的平方根。如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</li>
<li><code>Math.expm1(x)</code>：返回<code>ex - 1</code>，即<code>Math.exp(x) - 1</code>。</li>
<li><code>Math.log1p(x)</code>：返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于<code>-1</code>，返回<code>NaN</code>。</li>
<li><code>Math.log10(x)</code>：返回以10为底的<code>x</code>的对数。</li>
<li><code>Math.log2(x)</code>：返回以2为底的<code>x</code>的对数。</li>
<li><code>Math.sinh(x)</code>：返回<code>x</code>的双曲正弦</li>
<li><code>Math.cosh(x)</code>：返回<code>x</code>的双曲余弦</li>
<li><code>Math.tanh(x)</code>：返回<code>x</code>的双曲正切</li>
<li><code>Math.asinh(x)</code>：返回<code>x</code>的反双曲正弦</li>
<li><code>Math.acosh(x)</code>：返回<code>x</code>的反双曲余弦</li>
<li><code>Math.atanh(x)</code>：返回<code>x</code>的反双曲正切</li>
<li><p>指数运算符<code>**</code>：</p>
<pre><code>let a = 1.5;
a **= 2;
// 等同于 a = a * a;

let b = 4;
b **= 3;
// 等同于 b = b * b * b;
</code></pre></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Webpack入门学习]]></title>
      <url>https://fantasticzhang.github.io/2017/06/01/Webpack%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>前段时间在学习React时，用到了Webpack，于是简单地学习了一下，下面将Webpack的基础知识记录下来，以便日后查看。</p>
<p>以下内容来自于：<a href="https://github.com/zhaoda/webpack-handbook/" target="_blank" rel="external">webpack-handbook</a></p>
<p>在介绍Webpack之前，首先介绍一下模块系统。</p>
<h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><h2 id="为什么会出现模块系统"><a href="#为什么会出现模块系统" class="headerlink" title="为什么会出现模块系统"></a>为什么会出现模块系统</h2><p>当前，越来越多的网站已经从网页模式进化到了WebAPP模式。webapp通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的JavaScript代码，这给前端开发的流程和资源组织带来了巨大的挑战。</p>
<p>由于前端产品的交付是基于浏览器的，各种资源是通过增量加载的方式运行到浏览器端，因此需要一个模块化系统，在开发环境中组织好这些碎片化的代码和资源，并且保证它们在浏览器端快速、优雅地加载和更新。而这个理想中的模块化系统是前端工程师多年来一直探索的难题。</p>
<h2 id="已有的模块系统"><a href="#已有的模块系统" class="headerlink" title="已有的模块系统"></a>已有的模块系统</h2><p>模块系统主要解决模块的定义、依赖和导出。</p>
<h3 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h3><pre><code>&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt;
</code></pre><p>最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中。</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><pre><code>require(&quot;module&quot;);
require(&quot;../file.js&quot;);
exports.doStuff = function() {};
module.exports = someValue;
</code></pre><p>该规范的核心思想是允许模块通过 require 方法来<strong>同步</strong>加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。</p>
<p>实现：服务器端的<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>；<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>（浏览器端的 CommonJS 实现）；<a href="https://github.com/medikoo/modules-webmake" target="_blank" rel="external">modules-webmake</a>；<a href="https://github.com/substack/wreq" target="_blank" rel="external">wreq</a>。</p>
<h3 id="AMD（Asynchronous-Module-Definition）"><a href="#AMD（Asynchronous-Module-Definition）" class="headerlink" title="AMD（Asynchronous Module Definition）"></a>AMD（Asynchronous Module Definition）</h3><pre><code>define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) {
return someExportedValue;
});
require([&quot;module&quot;, &quot;../file&quot;], function(module, file) { });
</code></pre><p>只有一个主要接口 <code>define(id?, dependencies?,factory)</code> ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块提前执行，依赖前置。适合在浏览器环境中异步加载模块，但提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</p>
<p>实现：<a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a>；<a href="https://github.com/cujojs/curl" target="_blank" rel="external">curl</a>。</p>
<h3 id="CMD（Common-Module-Definition-）"><a href="#CMD（Common-Module-Definition-）" class="headerlink" title="CMD（Common Module Definition ）"></a>CMD（Common Module Definition ）</h3><pre><code>define(function(require, exports, module) {
var $ = require(&apos;jquery&apos;);
var Spinning = require(&apos;./spinning&apos;);
exports.doSomething = ...
module.exports = ...
})
</code></pre><p>和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。依赖 SPM 打包，模块的加载逻辑偏重。</p>
<p>实现：<a href="http://seajs.org/" target="_blank" rel="external">Sea.js</a>；<a href="https://github.com/cloudcome/coolie" target="_blank" rel="external">coolie</a></p>
<h3 id="UMD（Universal-Module-Definition）"><a href="#UMD（Universal-Module-Definition）" class="headerlink" title="UMD（Universal Module Definition）"></a>UMD（Universal Module Definition）</h3><p>类似于兼容 CommonJS 和 AMD 的语法糖，是模块定义的跨平台解决方案。</p>
<h3 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h3><pre><code>import &quot;jquery&quot;;
export function doStuff() {}
module &quot;localModule&quot; {}
</code></pre><p>EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和AMD 模块，都只能在运行时确定这些东西。</p>
<p>实现：<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>。</p>
<h2 id="为什么会需要Webpack"><a href="#为什么会需要Webpack" class="headerlink" title="为什么会需要Webpack"></a>为什么会需要Webpack</h2><h3 id="已有模块系统的缺点"><a href="#已有模块系统的缺点" class="headerlink" title="已有模块系统的缺点"></a>已有模块系统的缺点</h3><p>市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。这些已有的模块化工具并不能很好的完成如下的目标：</p>
<ul>
<li>将依赖树拆分成按需加载的块；</li>
<li>初始化加载的耗时尽量少；</li>
<li>各种静态资源都可以视作模块；</li>
<li>将第三方库整合成模块的能力；</li>
<li>可以自定义打包逻辑的能力；</li>
<li>适合大项目，无论是单页还是多页的 Web 应用。</li>
</ul>
<h3 id="Webpack的特点"><a href="#Webpack的特点" class="headerlink" title="Webpack的特点"></a>Webpack的特点</h3><h4 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h4><p>Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p>
<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p>
<h4 id="智能解析"><a href="#智能解析" class="headerlink" title="智能解析"></a>智能解析</h4><p>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式require(“./templates/“ + name + “.jade”) 。</p>
<h4 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h4><p>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</p>
<h4 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h4><p>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p>
<h1 id="Webpack的基本使用"><a href="#Webpack的基本使用" class="headerlink" title="Webpack的基本使用"></a>Webpack的基本使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通常我们会将 Webpack 安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack。</p>
<pre><code># 进入项目目录
# 确定已经有 package.json，没有就通过 npm init 创建
# 安装 webpack 依赖
$ npm install webpack --save-dev

# 查看 webpack 版本信息
$ npm info webpack
# 安装指定版本的 webpack
$ npm install webpack@1.12.x --save-dev

# 安装 Webpack 开发工具
$ npm install webpack-dev-server --save-dev
</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js，然后编译 entry.js 并打包到 bundle.js：</p>
<pre><code>&lt;!-- index.html --&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

// entry.js
document.write(&apos;It works.&apos;)

$ webpack entry.js bundle.js
</code></pre><p>用浏览器打开 index.html 将会看到 <code>It works.</code> 。</p>
<p>Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（ 模块） 都打包到bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。</p>
<h3 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h3><p>Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件，这个文件是一个 node.js 模块，返回一<br>个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。</p>
<pre><code>//webpack.config.js 文件示例

var webpack = require(&apos;webpack&apos;)

module.exports = {
    entry:&apos;./entry.js&apos;,
    output:{
        path:__dirname,
        filename:&apos;bundle.js&apos;
    },
    module:{
        loaders:[
            {test:/\.css$/,loader:&apos;style-loader!css-loader&apos;}
        ]
    },
    plugins:[
        new webpack.BannerPlugin(&apos;This file is created by zjl&apos;)
    ]
}
</code></pre><p>其中，<code>loaders</code>用来指定模块和资源的转换器。Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader进行转换。Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如CoffeeScript、 JSX、 LESS 或图片。</p>
<p>还可以通过命令行的方式使用或是在 require() 引用模块的时候添加：</p>
<pre><code>require(&quot;!style-loader!css-loader!./style.css&quot;) // 载入 style.css
document.write(&apos;It works.&apos;)

webpack entry.js bundle.js --module-bind &apos;css=style-loader!css-loader&apos;
</code></pre><p><code>plugins</code>选项用来指定插件信息。Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件。在上面的例子中用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件<br>的作用是给输出的文件头部添加注释信息。</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li><p>通过参数让编译的输出内容带有进度和颜色：</p>
<pre><code>$ webpack --progress --colors
</code></pre></li>
<li><p>开启监听模式（没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的）</p>
<pre><code>$ webpack --progress --colors --watch
</code></pre></li>
<li><p>使用 webpack-dev-server 开发服务</p>
<p>它将在 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> 或<a href="http://localhost:8080/webpack-dev-server/" target="_blank" rel="external">http://localhost:8080/webpack-dev-server/</a> 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。</p>
<pre><code># 安装
$ npm install webpack-dev-server -g
# 运行
$ webpack-dev-server --progress --colors
</code></pre></li>
<li><p>打印错误详情</p>
<pre><code>$ webpack --display-error-details
</code></pre></li>
<li><p>webpack-dev-server设置成手机也能访问的方法：</p>
<pre><code>webpack-dev-server --host 0.0.0.0 --port 8080
</code></pre><p>指定–host为0.0.0.0就可以了。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript总结之变量和作用域]]></title>
      <url>https://fantasticzhang.github.io/2017/05/14/JavaScript%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JavaScript中使用<code>var</code>关键字来声明变量，JavaScript变量可以用来保存两种类型的值：基本类型值（Undefined、Null、Boolean、Number、String和引用类型值（Object）。具有如下特点：</p>
<ul>
<li>基本类型值在内存中占据固定大小的空间，保存在<strong>栈</strong>内存中；引用类型的值是对象，保存在<strong>堆</strong>内存中。</li>
<li>复制基本类型的值，会创建这个值的一个副本；复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>
<li>可使用<code>typeof</code>操作符来确定一个值是哪种基本类型；可使用<code>instanceof</code>操作符来确定一个值是哪种引用类型。</li>
</ul>
<p>JavaScript中没有块级作用域，只有函数级作用域和全局作用域。使用<code>var</code>声明的变量会自动添加到最接近的环境中（函数的局部环境或是全局环境），但是如果在初始化变量时未使用<code>var</code>关键字，则该变量会被添加到全局环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链能够保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在环境的变量对象，下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样一直延伸到全局执行环境。全局执行环境中的变量对象始终是作用域链中的最后一个对象。而标识符的解析就是沿着作用域链一级一级地搜索标识符的过程，从作用域链的前端开始，逐级地向后回溯，直至找到标识符为止。</p>
<p>JavaScript具有自动垃圾回收机制，因此很多时候我们并不用关系内存的分配和回收问题。目前主流的垃圾收集算法是“标记清除”，该算法的思想是给当前不使用的值加上标记，然后再回收其内存。但是，为了确保有效回收内存，我们可以及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用（置为null）。</p>
<h1 id="ES6的新特性"><a href="#ES6的新特性" class="headerlink" title="ES6的新特性"></a>ES6的新特性</h1><p>ES6中新增了两个声明变量的关键字：let和const。</p>
<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><p><code>let</code>命令用来声明变量，所声明的变量只在<code>let</code>命令所在的代码块内有效。</p>
<h3 id="与var比较"><a href="#与var比较" class="headerlink" title="与var比较"></a>与var比较</h3><pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
</code></pre><p>上面代码中，变量<code>i</code>是<code>var</code>声明的，在全局范围内都有效。所以每一次循环，新的<code>i</code>值都会覆盖旧值，导致最后输出的是最后一轮的<code>i</code>值，即输出的是10.</p>
<p>使用<code>let</code>声明变量：</p>
<pre><code>var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
</code></pre><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，仅在块级作用域内有效。因此当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。<br> （JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。）</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。但<code>let</code>命令所声明的变量一定要在声明后使用，否则报错。</p>
<h3 id="暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="暂时性死区（temporal dead zone，简称 TDZ）"></a>暂时性死区（temporal dead zone，简称 TDZ）</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。即：区块中存在<code>let</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<pre><code>var tmp = 123
if (true) {
// TDZ开始
tmp = &apos;abc&apos;; // ReferenceError
console.log(tmp); // ReferenceError

let tmp; // TDZ结束
console.log(tmp); // undefined

tmp = 123;
console.log(tmp); // 123
}
</code></pre><p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code>// 报错
function () {
  let a = 10;
  var a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}
</code></pre><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>与<code>let</code>命令一样，<code>const</code>命令是块级作用域、不能提升、存在暂时性死区等。</p>
<p>但是，对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p>
<p>注：ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。，ES6一共有6种声明变量的方法:<code>var</code>命令、<code>function</code>命令、<code>let</code>命令、<code>const</code>命令、<code>import</code>命令和<code>class</code>命令。</p>
<h2 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h2><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，因此如果在块级作用域里声明了函数，实际都能运行，不会报错。不过，“严格模式”下还是会报错。</p>
<p>ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外<strong>不可引用</strong>。</p>
<p>但是，为了减轻因此产生的不兼容问题，ES6在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="external">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式:</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>因此，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>
<pre><code>// 浏览器的 ES6 环境
function f() { console.log(&apos;I am outside!&apos;); }
(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log(&apos;I am inside!&apos;); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</p>
<pre><code>// 浏览器的 ES6 环境
function f() { console.log(&apos;I am outside!&apos;); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log(&apos;I am inside!&apos;); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre><p>参考链接：</p>
<p><a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/let</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript总结之基本概念]]></title>
      <url>https://fantasticzhang.github.io/2017/05/14/JavaScript%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>最近在面试的过程中发现，JavaScript的一些基础知识自己有些遗忘，于是决定重新学习JavaScript，同时学习ES6的相关新特性，记下笔记以便日后回顾。学习资料：《JavaScript高级程序设计》，<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript6入门</a>。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>JavaScript由以下三部分组成：</p>
<ul>
<li>ECMAScript：由ECMAScript-262定义，提供核心语言功能；</li>
<li>文档对象模型（DOM）：提供访问和操作网页内容的方法和接口；</li>
<li>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。</li>
</ul>
<p>ECMAScript与JavaScript的关系：前者是后者的标准，后者是前者的一种实现。即ECMAScript就是对实现该标准规定的各个方面内容的语言的描述，JavaScript实现了ECMAScript，Adobe ActionScript同样也实现了ECMAScript。</p>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>ECMAScript标识符采用驼峰大小写格式，按照以下规则组合起来的一个或多个字符：</p>
<ul>
<li>第一个字符必须是字母、下划线<code>_</code>或美元符号<code>$</code>;</li>
<li>其他字符可以是字母、数字、下划线或美元符号。</li>
</ul>
<p>此外，ECMAScript中的一切变量、函数和操作符等都区分大小写。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>ECMAScript中有五种基本数据类型：Undefined、Null、Boolean、Number、String；一种复杂数据类型：Object。</p>
<p>对于给定变量，可以使用<code>typeof</code>操作符来检测其数据类型，该操作符可能的返回值如下：</p>
<ul>
<li>“undefined”：该值未定义或未初始化；</li>
<li>“boolean”：该值是布尔值；</li>
<li>“string”：该值是字符串；</li>
<li>“number”：该值是数值或<code>NaN</code>；</li>
<li>“object”：该值是对象或<code>null</code>；</li>
<li>“function”：该值是函数。</li>
</ul>
<h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>该类型只要一个值<code>undefined</code>，在使用var声明变量但未对其加以初始化时，这个变量的值就是<code>undefined</code>。</p>
<p>对未初始化的变量执行<code>typeof</code>操作符会返回<code>undefined</code>；对未声明的变量执行<code>typeof</code>操作符也会返回<code>undefined</code>值。</p>
<p>根据以上特点，在写程序时可对，每个变量进行显示初始化，这样就能用<code>typeof</code>操作符检测出那些未声明的变量。</p>
<h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>该类型只有一个值<code>null</code>，表示一个空对象指针。 使用<code>typeof</code>操作符检测<code>null</code>时会返回”object”。</p>
<p>因此，可以使用<code>null</code>来初始化一个将来用于保存对象的变量，这样只要直接检查null值就能知道相应的变量是否已经保存了一个对象的引用。</p>
<p><code>null == undefined</code> 返回 <code>true</code></p>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>该类型有两个字面量值：<code>true</code>和<code>false</code>，其他类型的值可以使用转型函数<code>Boolean()</code>转变成对应的Boolean值。</p>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>该类型使用IEEE754格式来表示整数和浮点数值。如果浮点数本身表示一个整数，则该值会被转换为整数。</p>
<p>在进行浮点数计算时，注意精度问题。浮点数值的最高精度是17位小数，例如：0.1加0.2的结果是0.30000000000000004。</p>
<p>数值范围：<code>Number.MIN_VALUE</code>到<code>Number.MAX_VALUE</code>，超出范围的会被转化成<code>Infinity</code>或<code>-Infinity</code>。可使用<code>isFinite()</code>函数来确定一个数值是不是有穷的。</p>
<p>NaN：表示一个本来要返回数值的操作数未返回数值的情况。任何涉及NaN的操作都会返回NaN；NaN与任何值都不相等，包括其本身。<code>isNaN()</code>函数用来确定参数是否“不是数值”。</p>
<p>数值转换：</p>
<ul>
<li>Number()：空字符串、null转换为0；undefined转换为NaN；如果是字符串则只能包含数字（正负号、十进制、十六进制、浮点数），如果包含这之外的其他字符，则返回NaN。</li>
<li>parseInt()：会忽略前导空格，直到找到第一个非空格字符。如果第一个字符不是数字或负号则返回NaN；如果是数字字符，则会解析完后续所有字符或者遇到了一个非数字字符。可以用第二个参数来指定转换时使用的基数（即多少进制），如果指定的基数和第一个参数的数字不匹配，会返回0。</li>
<li>parseFloat()：与<code>parseInt()</code>的解析方式类似，但不会忽略第一个小数点<code>.</code>，而且只解析十进制数值。</li>
</ul>
<h3 id="ES6新特性之二进制和八进制表示法"><a href="#ES6新特性之二进制和八进制表示法" class="headerlink" title="ES6新特性之二进制和八进制表示法"></a>ES6新特性之二进制和八进制表示法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<pre><code>0b111110111 === 503 // true
0o767 === 503 // true
</code></pre><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>用于表示由零个或多个16位Unicode字符组成的字符序列。任何字符都可使用<code>lenght</code>属性来取得其长度，该属性返回的字符数包括<strong>16位字符</strong>的数目。</p>
<p>数值、布尔值、字符串值和对象都有<code>toString()</code>方法，使用该方法可返回相应值的字符串表现形式，在调用数值的<code>toString()</code>方法时还可传递一个参数，该参数指定输出数值的基数。此外，其他任何类型的值还可使用转型函数<code>String()</code>来转变成对应的String值,<code>String(null)</code>返回”null”,<code>String(undefined)</code>返回<code>undefined</code>。</p>
<p>注：ECMAScript中的字符串是不可变的，即字符串一旦创建它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p>
<h3 id="ES6新增特性"><a href="#ES6新增特性" class="headerlink" title="ES6新增特性"></a>ES6新增特性</h3><h4 id="字符的Unicode表示方法"><a href="#字符的Unicode表示方法" class="headerlink" title="字符的Unicode表示方法"></a>字符的Unicode表示方法</h4><p>JavaScript允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的Unicode码点。但是这种表示方法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<pre><code>&quot;\u{20BB7}&quot;
// &quot;𠮷&quot;

&quot;\u{41}\u{42}\u{43}&quot;
// &quot;ABC&quot;

let hello = 123;
hell\u{6F} // 123

&apos;\u{1F680}&apos; === &apos;\uD83D\uDE80&apos;
// true
</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。<code>{}</code>中可以放入任意的JavaScript表达式，可以进行运算，可以引用对象属性，还可以进行函数调用。</p>
<pre><code>var x = 1;
var y = 2;

`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;

function fn() {
return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar
</code></pre><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p> Object类型是所有它的实例的基础，即Object类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p> Object的每个实例都具有如下属性和方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数；</li>
<li>hasOwnProperty(propertyName)：检查给定的属性在当前对象的实例中（而不是实例的的原型中）是否存在；</li>
<li><p>isPrototypeOf(Object)：检查当前对象是否存在于传入对象的原型链中，例：</p>
<pre><code>function Site(){
    this.name = &quot;Fantastic&quot;;
    this.url = &quot;http://fantasticzhang.gtensor.com/&quot;;

    this.sayHello = function(){
        document.writeln(&quot;欢迎来到&quot; + this.name);
    };
}

var s =  new Site();
document.writeln( Site.prototype.isPrototypeOf(s) ); // true

var obj = {
    engine: &quot;apache&quot;
    ,sayHi: function(){
        document.writeln(&quot;欢迎访问&quot; + this.url);
    }
};
// 使用对象obj覆盖Site本身的prototype属性
Site.prototype = obj;

var s2 =  new Site();
document.writeln( obj.isPrototypeOf(s2) ); // true
</code></pre><ul>
<li>propertyIsEnumerable(propertyName)：检查给定的属性是否能使用<code>for-in</code>语句来枚举；</li>
<li>toLocalString()、toString()：返回对象的字符串表示，其中<code>toLocalString</code>与执行环境的地区对应；</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。</li>
</ul>
</li>
</ul>
<h2 id="ES6新特性之Symbol类型"><a href="#ES6新特性之Symbol类型" class="headerlink" title="ES6新特性之Symbol类型"></a>ES6新特性之Symbol类型</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<pre><code>var s1 = Symbol(&apos;foo&apos;);
var s2 = Symbol(&apos;bar&apos;);

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;
</code></pre><p>Symbol.for()是另一种生成新的Symbol的方法。它与Symbol()的区别是：Symbol.for()会被<strong>登记</strong>在全局环境中供搜索，Symbol()不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30次，会返回30个不同的Symbol值。</p>
<pre><code>var s1 = Symbol.for(&apos;foo&apos;);
var s2 = Symbol.for(&apos;foo&apos;);
s1 === s2 // true
</code></pre><p>Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。</p>
<pre><code>var s1 = Symbol.for(&quot;foo&quot;);
Symbol.keyFor(s1) // &quot;foo&quot;

var s2 = Symbol(&quot;foo&quot;);
Symbol.keyFor(s2) // undefined
</code></pre><p>上面代码中，变量s2属于未登记的Symbol值，所以返回undefined。</p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>ECMAScript的操作符能够适用于很多值，如字符串、数值、布尔值、对象等。不过在进行相应的操作前一般会对操作数进行相应的转换。</p>
<h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><p>包括递增<code>++</code>、递减<code>--</code>、一元加<code>+</code>、一元减<code>-</code>操作符。</p>
<ul>
<li>操作数是数值：直接进行相应计算；</li>
<li>操作数是非数值（不包括对象）：像转型函数<code>Number()</code>一样先对操作数转换成数值，之后在进行计算；</li>
<li>操作数是对象：调用对象的<code>valueOf()</code>和（或）<code>toString()</code>方法，之后后应用上一规则。</li>
</ul>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>包括按位非<code>~</code>、按位与<code>&amp;</code>、按位或<code>|</code>、按位异或<code>^</code>、左移<code>&lt;&lt;</code>、有符号右移<code>&gt;&gt;</code>（符号位不变，空位用符号位的值填充）、无符号右移<code>&gt;&gt;&gt;</code>（符号位也移动，用0填充空位）。</p>
<p>ECMAScript中所有数值都是以IEEE-754 64位格式存储，但位操作符是先将64位的值转换成<strong>32位的整数</strong>，然后执行操作，最后再将结果转回64位。这个操作导致了一个负效应，即在对特殊的<code>NaN</code>和<code>Infinity</code>值应用位操作时，这两个值都会被当成0来处理；而在对浮点数值应用位操作时，会当做整数来处理，即截取浮点数的整数位。</p>
<p>如果对非数值应用位操作符，则会先使用<code>Number()</code>函数将其转换成一个数值，之后再应用位操作，得到的结果是一个数值。</p>
<h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><h3 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非!"></a>逻辑非<code>!</code></h3><p>该操作符始终会返回一个布尔值。遵循以下规则：</p>
<ul>
<li>操作数是一个数值：0返回<code>true</code>；其他非0数值返回<code>false</code>；</li>
<li>操作数是一个字符串：空串返回<code>true</code>；其他非空串返回<code>false</code>；</li>
<li>操作数是一个对象：<code>null</code>返回<code>true</code>；其他非空对象返回<code>false</code>；</li>
<li>操作数是<code>NaN</code>或<code>undefined</code>：返回<code>true</code>；</li>
<li>操作数是<code>+/-Infinity</code>：返回false。</li>
</ul>
<h3 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与&amp;&amp;"></a>逻辑与<code>&amp;&amp;</code></h3><p>该操作符可用于任何类型的操作数，且返回值不一定是布尔值。</p>
<p>设<code>a &amp;&amp; b</code>，则遵循以下规则：</p>
<ul>
<li>如果a是非0数值（包括+/-Infinity）、非空串或非空对象或<code>true</code>，则返回b；</li>
<li>如果a是<code>null</code>、<code>NaN</code>、<code>undefined</code>或求值结果是<code>false</code>，则返回a；该情况下会执行短路操作。</li>
</ul>
<h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或||"></a>逻辑或<code>||</code></h3><p>该操作符可用于任何类型的操作数，且返回值不一定是布尔值。</p>
<p>设<code>a || b</code>，则遵循以下规则：</p>
<ul>
<li>如果a是非0数值（包括+/-Infinity）、非空串、非空对象或<code>true</code>，则返回a；该情况下会执行短路操作。</li>
<li>如果a是<code>null</code>、<code>NaN</code>、<code>undefined</code>或求值结果为<code>false</code>，则返回b。</li>
</ul>
<h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>包括乘法<code>*</code>、除法<code>/</code>、求余<code>%</code>。</p>
<p>设<code>a*b</code>，则遵循以下规则：</p>
<ul>
<li>a、b都是数值，正常计算，如发生溢出，则结果为<code>Infinity</code>或<code>-Infinity</code>；</li>
<li>a、b中有一个是<code>NaN</code>，则结果是<code>NaN</code>；</li>
<li>a和b一个是<code>Infinity</code>，一个是0，则结果是<code>NaN</code>；</li>
<li>a和b一个是<code>Infinity</code>，一个是非0数值，则结果是<code>Infinity</code>或<code>-Infinity</code>；</li>
<li>a、b中有非数值，则先调用<code>Number()</code>将其转换为数值，再按如上规则计算。</li>
</ul>
<p>设<code>a/b</code>，则遵循以下规则：</p>
<ul>
<li>a、b都是数值，正常计算，如发生溢出，则结果为<code>Infinity</code>或<code>-Infinity</code>；</li>
<li>a、b中有一个是<code>NaN</code>，则结果是<code>NaN</code>；</li>
<li>a、b都是0，结果为<code>NaN</code>;</li>
<li>a、b都是<code>±Infinity</code>，结果为<code>NaN</code>；</li>
<li>a是<code>±Infinity</code>，b是有限数值，则结果是<code>±Infinity</code>;</li>
<li>a是有限数值，b是<code>±Infinity</code>，则结果是<code>±0</code>；</li>
<li>a是非零数值，b是0，则结果是<code>±Infinity</code>。</li>
</ul>
<p>设<code>a%b</code>，则遵循以下规则：</p>
<ul>
<li>a、b都是数值，正常计算；</li>
<li>a、b中有一个是<code>NaN</code>，则结果是<code>NaN</code>；</li>
<li>a、b都是0，结果为<code>NaN</code>;</li>
<li>a是<code>±Infinity</code>，结果是<code>NaN</code>;</li>
<li>a是有限数值，b是<code>±Infinity</code>，则结果是a；</li>
<li>a是非零数值，b是0，则结果是<code>NaN</code>。</li>
</ul>
<h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><p>包括加法<code>+</code>、减法<code>-</code>。</p>
<p>设<code>a+b</code>，则遵循以下规则：</p>
<ul>
<li>如果a和b中有一个是字符串，则将另一个转换为字符串，然后将两个字符串拼接起来；</li>
<li><p>如果a和b都不是字符串，则先调用<code>Number()</code>将非数值转换为数值，再进行计算：</p>
<ul>
<li>a、b中有一个是<code>NaN</code>，结果是<code>NaN</code>;</li>
<li>a、b都是<code>Infinity</code>，结果是<code>Infinity</code>;</li>
<li>a、b都是<code>-Infinity</code>，结果是<code>-Infinity</code>;</li>
<li>a是<code>Infinity</code>，b是<code>-Infinity</code>（或相反），则结果是<code>NaN</code>；</li>
<li>a、b都是<code>+0</code>，则结果是<code>+0</code>；</li>
<li>a、b都是<code>-0</code>，则结果是<code>-0</code>；</li>
<li>a是<code>+0</code>，b是<code>-0</code>（或相反），则结果是<code>+0</code>。</li>
</ul>
</li>
</ul>
<p>设<code>a-b</code>，先将非数值转换为数值，再进行计算，遵循以下规则：</p>
<ul>
<li>a、b中有一个是<code>NaN</code>，结果是<code>NaN</code>;</li>
<li>a、b都是<code>Infinity</code>，结果是<code>NaN</code>;</li>
<li>a、b都是<code>-Infinity</code>，结果是<code>NaN</code>;</li>
<li>a是<code>Infinity</code>，b是<code>-Infinity</code>，则结果是<code>Infinity</code>；</li>
<li>a是<code>-Infinity</code>，b是<code>Infinity</code>，则结果是<code>-Infinity</code>；</li>
<li>a、b都是<code>+0</code>，则结果是<code>+0</code>；</li>
<li>a、b都是<code>-0</code>，则结果是<code>+0</code>；</li>
<li>a是<code>+0</code>，b是<code>-0</code>，则结果是<code>+0</code>；</li>
<li>a是<code>-0</code>，b是<code>+0</code>，则结果是<code>-0</code>。</li>
</ul>
<h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>包括大于<code>&gt;</code>、大于等于<code>&gt;=</code>、小于<code>&lt;</code>、小于等于<code>&lt;=</code>。遵循以下规则：</p>
<ul>
<li>两个操作数都是数值，则执行数值比较；</li>
<li>两个操作数都是字符串，则比较两个字符串对应的<strong>字符编码值</strong>；</li>
<li>有一个操作数是<code>NaN</code>，则结果为<code>false</code>；</li>
<li>其他情况，则先将非数值转换为数值，再进行运算。</li>
</ul>
<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><h3 id="相等-和不相等"><a href="#相等-和不相等" class="headerlink" title="相等==和不相等!="></a>相等<code>==</code>和不相等<code>!=</code></h3><p>在比较之前会根据实际情况对两个操作数进行转换。设两个操作数分别是a、b，则遵循以下规则：</p>
<ul>
<li>a、b都是数值，则执行数值比较；</li>
<li>a、b都是字符串，则比较两个字符串对应的<strong>字符编码值</strong>；</li>
<li>如果a和b都是对象，则比较它们是不是同一个对象，如果它们都指向同一个对象，则相等操作符返回true，否则返回false；</li>
<li>a或b有一个是NaN，则相等操作符返回false，不相等操作符返回true；</li>
<li>null和undefined是相等的；</li>
<li>在比较之前，不能将null和undefined转换成其他任何值；</li>
<li>其他情况，先将非数值转换为数值，再进行运算。</li>
</ul>
<h3 id="全等-和不全等"><a href="#全等-和不全等" class="headerlink" title="全等===和不全等!=="></a>全等<code>===</code>和不全等<code>!==</code></h3><p>不会对操作数进行转换。</p>
<ul>
<li>全等<code>===</code>：两个操作数未经转换就相等的情况下返回true；</li>
<li>不全等<code>!==</code>：两个操作数未经转换就不相等的情况下返回true。</li>
</ul>
<h2 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h2><ul>
<li>条件操作符：<code>variable = boolean_expression ? true_value:false_value</code>；</li>
<li>赋值操作符：=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=；</li>
<li>逗号操作符：在用于赋值时，逗号操作符总会返回表达式中的最后一项。</li>
</ul>
<h2 id="ES6新特性之变量的解构赋值"><a href="#ES6新特性之变量的解构赋值" class="headerlink" title="ES6新特性之变量的解构赋值"></a>ES6新特性之变量的解构赋值</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。在ES6中，数组、对象、字符串等都可以进行解构赋值。</p>
<p>解构赋值允许指定默认值，当相应位置的成员严格 等于<code>undefined</code>时（使用严格相等运算符<code>===</code>判断），默认值生效。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<p>数组的结构赋值：</p>
<pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
</code></pre><p>结构对象的解构赋值：</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>由上可知，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p>字符串的解构赋值：</p>
<p>字符串在解构赋值时被转换成了一个类似数组的对象，这个类似数组的对象有一个<code>length</code>属性。</p>
<pre><code>const [a, b, c, d, e] = &apos;hello&apos;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;

let {length : len} = &apos;hello&apos;;
len // 5
</code></pre><p>数值和布尔值的解构赋值：</p>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code>let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre><p>函数参数的解构赋值：</p>
<pre><code>function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><p>上面代码中，函数move的参数表面上是一个对象，但在传入参数的那一刻，对象就被解构成<strong>变量</strong>x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<pre><code>function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</code></pre><p>上面代码是为函数<code>move</code>的<strong>参数</strong>指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<p>解构赋值的用途有很多，例如：交换变量的值、从函数返回多个值、函数参数设置默认值、提取JSON数据等等。</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>包括：if语句、do-while语句、while语句、for语句、for-in语句、lable语句、break和continue语句、with语句、switch语句。</p>
<ul>
<li>for-in语句：可以用来枚举对象的属性。例：<code>for(var obj in window) console.log(obj)</code>；</li>
<li><p>lable语句：可以在代码中添加标签，常与break和continue语句配合使用。例：</p>
<pre><code>var num = 0;
outermost:
for (var i=0; i &lt; 10; i++) {
     for (var j=0; j &lt; 10; j++) {
        if (i == 5 &amp;&amp; j == 5) {
            break outermost;
        }
        num++;
    }
}
alert(num);    //55

var num = 0;
outermost:
for (var i=0; i &lt; 10; i++) {
     for (var j=0; j &lt; 10; j++) {
        if (i == 5 &amp;&amp; j == 5) {
            continue outermost;
        }
        num++;
    }
}

alert(num);    //95
</code></pre></li>
<li><p>with语句：<code>with(expression) statement</code>,将代码的作用域设置到一个特定的对象中。例：</p>
<pre><code>with(location){
    var qs = search.substring(1);
    var hostName = hostname;   
    var url = href;
}

alert(qs);
alert(hostName);
alert(url);
</code></pre></li>
<li>switch语句：可在switch语句中使用任何数据类型，每个case可以是常量、变量、表达式等，switch语句在比较值时使用的是<strong>全等</strong>操作符。</li>
</ul>
<h2 id="ES6新特性之for-of循环"><a href="#ES6新特性之for-of循环" class="headerlink" title="ES6新特性之for...of循环"></a>ES6新特性之<code>for...of</code>循环</h2><p>ES6引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有iterator接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。<code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator对象，以及字符串。例：</p>
<pre><code>const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];

for(let v of arr) {
  console.log(v); // red green blue
}
</code></pre><p>对于JavaScript之前就有的<code>for</code>循环、<code>forEach</code>、<code>for...in</code>循环等方法，有如下缺点：</p>
<ul>
<li><code>for</code>循环：写法不够简便；</li>
<li><code>forEach</code>方法：无法中途跳出循环，<code>break</code>或<code>return</code>命令都不起作用；</li>
<li><p><code>for...in</code>：数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等；for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。例：</p>
<p>  let arr = [3, 5, 7];<br>  arr.foo = ‘hello’;</p>
<p>  for (let i in arr) {</p>
<pre><code>console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;
</code></pre><p>  }</p>
<p>  for (let i of arr) {</p>
<pre><code>console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;
</code></pre><p>  }</p>
</li>
</ul>
<p><code>for...of</code>与以上遍历方法相比有以下优点：有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点;不同用于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用;提供了遍历所有数据结构的统一操作接口。</p>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>遍历器（Itertator）是一种接口，为各种不同的数据结构提供了一种统一的访问机制，即<code>for...of</code>循环。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>ES6规定，默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，该属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p>
<p>下面是一个为对象添加Iterator接口的例子。</p>
<pre><code>let obj = {
  data: [ &apos;hello&apos;, &apos;world&apos; ],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index &lt; self.data.length) {
          return {
            value: self.data[index++],
            done: false
          };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};
</code></pre><p>在ES6中，有四类数据结构原生具备Iterator接口：数组、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Set和Map结构、字符串，这是因为这些数据结构原生部署了Symbol.iterator属性。例：</p>
<pre><code>let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
let iter = arr[Symbol.iterator]();

iter.next() // { value: &apos;a&apos;, done: false }
iter.next() // { value: &apos;b&apos;, done: false }
iter.next() // { value: &apos;c&apos;, done: false }
iter.next() // { value: undefined, done: true }
</code></pre><p>对于那些没有Iterator接口的，需要我们自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口。例：</p>
<pre><code>let iterable = {
  0: &apos;a&apos;,
  1: &apos;b&apos;,
  2: &apos;c&apos;,
  length: 3,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
};
for (let item of iterable) {
  console.log(item); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;
</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>ECMAScript中的函数与其他语言中的函数有很多不同之处：</p>
<ul>
<li>无需指定函数的返回值，未指定返回值的函数返回的是<code>undefined</code>；</li>
<li>ECMAScript中没有函数签名（接受的参数的类型和数量）的概念，其函数参数是以一个包含零或多个值的数组的形式传递的，函数接收到的始终是这个数组，而不关心数组中包含哪些参数，因此命名的参数只是提供便利，而不是必须的；</li>
<li>可以向ECMAScript函数传递任意数量的参数，并通过<code>arguments</code>对象来访问这些参数，使用该对象的<code>lenght</code>属性来确定传递的参数的个数；</li>
<li><code>arguments</code>对象和命名参数的内存空间是<strong>独立</strong>的，但它们的值会<strong>同步</strong>，未传递值的命名参数自动被赋值为<code>undefined</code>；</li>
<li>ECMAScript中的所有参数传递的都是值</li>
<li>由于不存在函数签名的特性，ECMAScript函数不能重载。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS清除浮动的方法]]></title>
      <url>https://fantasticzhang.github.io/2017/05/05/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>CSS的float（浮动）属性有四个可选项：<code>none</code>（默认值，即不浮动）、<code>left</code>（向左浮动）、<code>right</code>（向右浮动）、<code>inherit</code>（继承父元素的float值）。设置了浮动的元素（<code>left</code>、<code>right</code>）有如下几个特点：</p>
<ul>
<li>对于块级元素，在不设置宽度的情况下默认宽度为100%；一旦设置了浮动，它的宽度会根据内容进行自动调整；</li>
<li>设置了浮动的元素会脱离文档流，向左/向右浮动，直到遇到父元素或者别的浮动元素；</li>
<li>设置了浮动的元素会导致父元素高度坍塌；</li>
<li>虽然浮动的元素脱离了文档流，但里面的内容仍然占据空间，会根据相对位置进行布局。</li>
</ul>
<p>解决父元素高度坍塌的方式：清除浮动。底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。清除浮动有两种思路：利用CSS的clear属性；使父容器成为BFC容器。</p>
<h1 id="利用CSS的clear属性"><a href="#利用CSS的clear属性" class="headerlink" title="利用CSS的clear属性"></a>利用CSS的clear属性</h1><p>clear属性定义了元素的哪一侧不允许出现浮动元素，可选项有<code>left</code>、<code>right</code>、<code>both</code>。有以下两种方式清除浮动。</p>
<h2 id="在需要的地方添加定义了clear-both的空标签"><a href="#在需要的地方添加定义了clear-both的空标签" class="headerlink" title="在需要的地方添加定义了clear:both的空标签"></a>在需要的地方添加定义了<code>clear:both</code>的空标签</h2><pre><code>&lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;
        我是左栏
    &lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;
        我是右栏
    &lt;/div&gt;
    &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>下面一个”万能”的清除浮动代码，可在不同浏览器下兼容：</p>
<pre><code>.clear{

    background: none;
    border:0;
    clear:both;   /*重点，其他的都是兼容性代码*/
    display: block;
    float: none;
    font-size: 0;
    margin: 0;
    padding: 0;
    overflow: hidden;
    visibility: hidden;
    width:0;
    height:0;
}
</code></pre><p>在需要清除浮动的元素后面添加<code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</code>即可。</p>
<h2 id="对父元素使用-after伪类"><a href="#对父元素使用-after伪类" class="headerlink" title="对父元素使用:after伪类"></a>对父元素使用<code>:after</code>伪类</h2><pre><code>//css
/*同时加入:before以解决现代浏览器上边距折叠的问题*/
.clearfix:before,
.clearfix:after{
    content: &quot;&quot;;
    display: table;
}
.clearfix:after{
    clear: both;
}
.clearfix{
    zoom: 1;  /*IE6、7不支持after伪类，因此需要添加这个兼容性代码*/
}
//html
&lt;body&gt;
&lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;
        我是左栏
    &lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;
        我是右栏
    &lt;/div&gt;
    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h2 id="关于IE6、7下的兼容性问题"><a href="#关于IE6、7下的兼容性问题" class="headerlink" title="关于IE6、7下的兼容性问题"></a>关于IE6、7下的兼容性问题</h2><p>旧版本的IE下有一个<code>hasLayout</code>属性，很多IE下的css Bug都与这个属性有关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于其最近拥有布局的祖先元素来计算尺寸和组织内容。</p>
<ul>
<li>当<code>hasLayout</code>为<code>true</code>时，相当于元素产生新BFC，元素自己对自身内容进行组织和尺寸计算;</li>
<li>当<code>hasLayout</code>为<code>false</code>时，相当于元素不产生新BFC，元素由其最近拥有布局的祖先元素进行组织和尺寸计算。</li>
</ul>
<p>因此，很多情况下，我们把<code>hasLayout</code>的状态改成<code>true</code>就可以解决很大部分IE下显示的bug。但我们不能直接设定<code>hasLayout</code>属性，只能通过设定一些特定的css属性来触发并改变<code>hasLayout</code>状态。触发<code>hasLayout</code>为<code>true</code>的方式:</p>
<ul>
<li>position: absolute</li>
<li>float: left|right</li>
<li>display: inline-block</li>
<li>width: 除”auto”外的任意值</li>
<li>height: 除”auto”外的任意值</li>
<li>zoom: 除”normal”外的任意值</li>
<li>writing-mode: tb-rl</li>
</ul>
<h1 id="使父容器成为BFC容器"><a href="#使父容器成为BFC容器" class="headerlink" title="使父容器成为BFC容器"></a>使父容器成为BFC容器</h1><p>BFC（Block Formatting Context）即块级格式化上下文。BFC容器有如下三个特征：</p>
<ul>
<li>BFC会阻止垂直外边距叠加：BFC容器是一个隔离的容器，和其他元素互不干扰；所以可以通过触发两个元素的BFC来解决垂直边距折叠问题；</li>
<li>BFC不会重叠浮动元素；</li>
<li>BFC可以包含浮动：可使用该特性来解决浮动父元素高度坍塌的问题。</li>
</ul>
<p>因此，我们可以利用BFC的“包含浮动”这条特性条来“清浮动”，也就是说只要父容器形成BFC就可以。触发BFC的方式：</p>
<ul>
<li>float：left|right</li>
<li>overflow：hidden|auto|scorll</li>
<li>display：table-cell|table-caption|inline-block|flex|inline-flex</li>
<li>position：absolute|fixed</li>
</ul>
<p>但是，通过以上几种方式触发BFC来清浮动都有各自的缺陷。例如：父容器float解决了其塌陷问题，那么父容器的父容器怎么办？<code>overflow</code>属性会影响滚动条和绝对定位的元素；<code>position</code>会改变元素的定位方式等等。</p>
<p>参考链接：</p>
<p><a href="http://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="external">http://www.jianshu.com/p/09bd5873bed4</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS实现两栏、三栏布局]]></title>
      <url>https://fantasticzhang.github.io/2017/05/04/CSS%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E3%80%81%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p>以下是利用CSS实现两栏、三栏布局的一些方法。</p>
<h1 id="两栏布局——左栏固定、右栏自适应"><a href="#两栏布局——左栏固定、右栏自适应" class="headerlink" title="两栏布局——左栏固定、右栏自适应"></a>两栏布局——左栏固定、右栏自适应</h1><p><img src="/images/2017-05-04/两栏布局-左栏固定右栏自适应.PNG" alt=""></p>
<h2 id="绝对定位法"><a href="#绝对定位法" class="headerlink" title="绝对定位法"></a>绝对定位法</h2><p>缺点：如果左右两栏高度不一样，且左右两栏之后还有其他元素，则后续元素不能正常定位。</p>
<pre><code>//css
#left{
       background-color: #42e2b9;
       width: 200px;
       height: 600px;
       position: absolute;
   }
 #right{
     background-color: #e28cc8;
     margin-left: 200px;
     height:600px;
 }
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，自适应&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h2 id="自身浮动法"><a href="#自身浮动法" class="headerlink" title="自身浮动法"></a>自身浮动法</h2><pre><code>//css
body{
    margin: 0;
}
#left{
    float: left;
    background-color: #42e2b9;
    width: 200px;
    height: 600px;

}
#right{
    background-color: #e28cc8;
    margin-left: 200px;
    height:600px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，自适应&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;    
</code></pre><h2 id="利用display的table属性"><a href="#利用display的table属性" class="headerlink" title="利用display的table属性"></a>利用display的table属性</h2><p>缺点：IE7及以下版本不支持该方法。</p>
<pre><code>//css
body{
    margin: 0;
}
#main{
    display: table;
    width: 100%;
}
#left{
    display: table-cell;
    background-color: #42e2b9;
    width: 200px;
    height: 600px;

}
#right{
    display: table-cell;
    background-color: #e28cc8;
    height:600px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，自适应&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h1 id="两栏布局——右栏固定、左栏自适应"><a href="#两栏布局——右栏固定、左栏自适应" class="headerlink" title="两栏布局——右栏固定、左栏自适应"></a>两栏布局——右栏固定、左栏自适应</h1><p><img src="/images/2017-05-04/两栏布局-右栏固定左栏自适应.PNG" alt=""></p>
<h2 id="绝对定位法-1"><a href="#绝对定位法-1" class="headerlink" title="绝对定位法"></a>绝对定位法</h2><p>缺点：如果左右两栏高度不一样，且左右两栏之后还有其他元素，则后续元素不能正常定位。</p>
<pre><code>//css
body{
    margin: 0;
}
#left{
    background-color: #e28cc8;
     height:600px;
    margin-right: 200px;
}
#right{
    position: absolute;
    background-color: #42e2b9;
    width: 200px;
    height: 600px;
    right: 0;
    top:0;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，自适应&lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h2 id="margin负值法"><a href="#margin负值法" class="headerlink" title="margin负值法"></a>margin负值法</h2><p>缺点：html中left外面要额外多一层div。</p>
<pre><code>//css
body{
    margin: 0;
}
#left-outer{
    float: left;
    width:100%;
    margin-left: -200px;
}
#left{
     background-color: #e28cc8;
     height:600px;
    margin-left: 200px;
}
#right{
    float: right;
    background-color: #42e2b9;
    width: 200px;
    height: 600px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left-outer&quot;&gt;&lt;div id=&quot;left&quot;&gt;我是左栏，自适应&lt;/div&gt;&lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h2 id="自身浮动法-1"><a href="#自身浮动法-1" class="headerlink" title="自身浮动法"></a>自身浮动法</h2><p>缺点：html中<strong>right</strong>必须在<strong>left</strong>之前。</p>
<pre><code>//css
body{
    margin: 0;
}
#left{
    background-color: #e28cc8;
     height:600px;
    margin-right: 200px;
}
#right{
    float: right;
    background-color: #42e2b9;
    width: 200px;
    height: 600px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
  &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
  &lt;div id=&quot;left&quot;&gt;我是左栏，自适应&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h2 id="利用display的table属性-1"><a href="#利用display的table属性-1" class="headerlink" title="利用display的table属性"></a>利用display的table属性</h2><p>缺点：IE7及以下版本不支持该方法。</p>
<pre><code>//css
body{
    margin: 0;
}
#main{
    display: table;
    width: 100%;
}
#left{
    display: table-cell;
    background-color: #e28cc8;
    height:600px;

}
#right{
    display: table-cell;
    background-color: #42e2b9;
    width: 200px;
    height: 600px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，自适应&lt;/div&gt;
     &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h1 id="三栏布局——左右两栏固定、中间自适应"><a href="#三栏布局——左右两栏固定、中间自适应" class="headerlink" title="三栏布局——左右两栏固定、中间自适应"></a>三栏布局——左右两栏固定、中间自适应</h1><p><img src="/images/2017-05-04/三栏布局-左右两栏固定中栏自适应.PNG" alt=""></p>
<h2 id="绝对定位法-2"><a href="#绝对定位法-2" class="headerlink" title="绝对定位法"></a>绝对定位法</h2><p>缺点：如果三栏高度不一样，且三栏之后还有其他元素，则后续元素不能正常定位。</p>
<pre><code>//css
body{
    margin: 0;;
}
#left{
    position: absolute;
    width:200px;
    height: 600px;
    background-color: lightblue;
}
#right{
    position: absolute;
    top:0;
    right: 0;
    width: 200px;
    height: 600px;
    background-color: chartreuse;
}
#middle{
    background-color: #e28cc8;
    height: 600px;
    margin: 0 200px 0 200px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;middle&quot;&gt;
        我是中栏，宽度自适应
    &lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;    
</code></pre><h2 id="自身浮动法-2"><a href="#自身浮动法-2" class="headerlink" title="自身浮动法"></a>自身浮动法</h2><p>缺点：html中<strong>right</strong>必须在<strong>middle</strong>之前。</p>
<pre><code>//css
body{
    margin: 0;;
}
#left{
   float: left;
    width:200px;
    height: 600px;
    background-color: lightblue;
}
#right{
   float: right;
    width: 200px;
    height: 600px;
    background-color: chartreuse;
}
#middle{
    background-color: #e28cc8;
    height: 600px;
    margin: 0 200px 0 200px;
}
//html    
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
     &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;middle&quot;&gt;
        我是中栏，宽度自适应
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><h2 id="margin负值法-1"><a href="#margin负值法-1" class="headerlink" title="margin负值法"></a>margin负值法</h2><p>缺点：html中middle外面要额外多一层div。</p>
<pre><code>//css
body{
    margin: 0;;
}
#left{
    float: left;
    width:200px;
    height: 600px;
    background-color: lightblue;
}
#right{
    float: right;
    width: 200px;
    height: 600px;
    background-color: chartreuse;
}
#middle-outer{
    float: left;
    width: 100%;
    margin-right: -200px;
    margin-left: -200px;

}
#middle{
     height: 600px;
    background-color: #e28cc8;
    margin-left: 200px;
    margin-right: 200px;
}
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;middle-outer&quot;&gt;
        &lt;div id=&quot;middle&quot;&gt;我是中栏，宽度自适应&lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><h2 id="利用display的table属性-2"><a href="#利用display的table属性-2" class="headerlink" title="利用display的table属性"></a>利用display的table属性</h2><p>缺点：IE7及以下版本不支持该方法。</p>
<pre><code>//css
&lt;style&gt;
    body{
        margin: 0;;
    }
    #main{
        display: table;
        width: 100%;
    }
    #left{
        display: table-cell;
        width:200px;
        height: 600px;
        background-color: lightblue;
    }
    #right{
        display: table-cell;
        width: 200px;
        height: 600px;
        background-color: chartreuse;
    }
    #middle{
         display: table-cell;
        background-color: #e28cc8;
        height: 600px;
    }
//html
&lt;body&gt;
&lt;div id=&quot;main&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;我是左栏，固定宽度&lt;/div&gt;
    &lt;div id=&quot;middle&quot;&gt;
        我是中栏，宽度自适应
    &lt;/div&gt;
    &lt;div id=&quot;right&quot;&gt;我是右栏，固定宽度&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>补充：使用<code>position:absolute</code>和<code>float</code>都会使元素脱离文档流。但是，使用 <code>float</code>使元素脱离文档流时，其他元素会无视这个元素，但其他元素内的文本依然会为这个元素让出位置，环绕在周围；使用<code>position:absolute</code>使元素脱离文档流时，其他元素与元素内的文本都会无视这个元素，所以可能会出现覆盖的情况。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript之Ajax总结]]></title>
      <url>https://fantasticzhang.github.io/2017/04/19/JavaScript%E4%B9%8BAjax%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>Ajax是对<code>Asynchronous JavaScript + XML</code>的简写。这一技术能够向服务器请求额外的数据而无需卸载页面，这样能够提高用户体验。JavaScript中实现Ajax技术的核心是XMLHttpRequest对象。</p>
<h1 id="Ajax运作的核心——XMLHttpRequest对象"><a href="#Ajax运作的核心——XMLHttpRequest对象" class="headerlink" title="Ajax运作的核心——XMLHttpRequest对象"></a>Ajax运作的核心——XMLHttpRequest对象</h1><p>XMLHttpRequest对象（以下简称XHR）由微软最早在IE5中引入，之后Firefox、Safari、Chrome和Opera都实现了相同的特性，使XHR成为了Web的一个事实标准。</p>
<p>IE7+、Firefox、Opera、Chrome和Safari都支持原生的XHR对象，在这些浏览器中创建XHR对象的方法：</p>
<pre><code>var xhr = new XMLHttpRequest();
</code></pre><p>IE5-IE7的版本中的XHR对象时通过MSXML库中的一个ActiveX对象来实现的，下面是一个兼容的实现方式：</p>
<pre><code>function createXHR(){
     if (typeof XMLHttpRequest != &quot;undefined&quot;){
         return new XMLHttpRequest();
     } else if (typeof ActiveXObject != &quot;undefined&quot;){   //IE7之前的版本
         if (typeof arguments.callee.activeXString != &quot;string&quot;){
           //会根据IE中可用的MSXML库的情况创建最新版本的XHR对象
             var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,
                             &quot;MSXML2.XMLHttp&quot;],
                 i, len;

             for (i=0,len=versions.length; i &lt; len; i++){
                 try {
                     new ActiveXObject(versions[i]);
                     arguments.callee.activeXString = versions[i];
                     break;
                 } catch (ex){
                     //跳过
                 }
             }
         }

         return new ActiveXObject(arguments.callee.activeXString);
     } else {
         throw new Error(&quot;No XHR object available.&quot;);
     }
 }
</code></pre><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre><code>var xhr = createXHR();        
xhr.open(&quot;get&quot;, &quot;example.txt&quot;, false);
xhr.send(null);
</code></pre><p>在创建XHR对象后，要调用的第一个方法是<code>open(type,url,async)</code>，该方法的作用是启动一个相应的请求。该方法接收三个参数，其中<code>type</code>用来指定发送请求的类型（’get’、’post’等），<code>url</code>请求的URL（相对于执行代码的当前页面，当然也可以使用绝对路径），<code>async</code>是一个布尔值，用来指定是否异步发送请求。注：调用<code>open()</code>方法并不会真正发送请求，只是启动了一个请求以备发送。</p>
<p><code>send(data)</code>方法的作用是发送指定的请求。该方法接收一个参数<code>data</code>，即要作为请求主体发送的数据。如果不发送数据也要传入<code>null</code>，因为这个参数对某些浏览器是必需的。</p>
<h2 id="相关属性、事件和方法"><a href="#相关属性、事件和方法" class="headerlink" title="相关属性、事件和方法"></a>相关属性、事件和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>responseText：作为响应主体被返回的文本；</li>
<li>responseXML：如果响应的内容类型为”text/xml”或”application/xml”，则这个属性中保存着包含响应数据的XML DOM文档。</li>
<li>status：响应的HTTP状态。</li>
<li>statusText：响应的HTTP状态的说明。</li>
<li>readyState：表示请求/响应过程的当前活动阶段，在异步请求中常用到。取值如下：<ul>
<li>0：未初始化，即尚未调用<code>open()</code>方法。</li>
<li>1：启动，即已调用<code>open()</code>方法，但尚未调用<code>send()</code>方法。</li>
<li>2：发送，即已经调用<code>send()</code>方法，但尚未接收到响应。</li>
<li>3：接收，已接收到部分响应数据。</li>
<li>4：完成，即接收到全部响应数据，且已经在客户端可以用了。</li>
</ul>
</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>readystatechange：只要<code>readyState</code>属性的值由一个值变为了另一个，就会触发一次<code>readystatechange</code>事件。注：为了保证跨浏览器兼容性，需要在调用<code>open()</code>之前指定<code>readystatechange</code>事件的处理程序。下面是一个例子：</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>open(type,url,async)：启动一个相应的请求。</li>
<li>send(data)：发送指定的请求。</li>
<li>abort()：取消当前正在执行的请求。调用该方法后XHR对象会停止触发事件，而且也不允许访问任何与响应有关的对象属性。</li>
<li>setRequestHeader(name,value)：设置自定义的请求头部。<code>name</code>为头部字段的名称，<code>value</code>为头部字段的值。该方法必须在<code>open()</code>之后<code>send()</code>之前调用。</li>
<li>getResponseHeader(name)：取得响应头部指定字段的值，其中<code>name</code>为想要取得的头部字段的名称。</li>
<li><p>getAllResponseHeaders()：取得一个包含所有头部信息的长字符串，下面是一个例子：</p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(event){
    if (xhr.readyState == 4){
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
            console.log(xhr.getAllResponseHeaders());
        } else {
            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);
        }
    }
};
xhr.open(&quot;get&quot;, &quot;/simulationplatform/router/reset&quot;, true);
xhr.setRequestHeader(&quot;zjl&quot;, &quot;zjl&quot;);
xhr.send(null);
</code></pre><p>  Request Headers如下：</p>
<p>  <img src="/images/2017-04-20/setRequestHeader.jpg" alt=""></p>
<p>  输出如下：</p>
<p>  <img src="/images/2017-04-20/responseHeaders.png" alt=""></p>
</li>
</ul>
<p>既然涉及到了HTTP的头部信息，那么我在这里也简单地讲一下。下面是一条XHR请求的Headers截图：</p>
<p><img src="/images/2017-04-20/headers.jpg" alt=""></p>
<p>在发送XHR请求的同时，基本上所有浏览器都会发送下列头部信息：</p>
<ul>
<li>Accept：浏览器能够处理的内容类型；</li>
<li>Accept-Charset：浏览器能够显示的字符集；</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码类型；</li>
<li>Connection：浏览器与服务器之间的连接类型；</li>
<li>Cookie：当前页面设置的任何cookie；</li>
<li>Host：发出请求的页面所在的域；</li>
<li>Referer：发出请求的页面的URI；</li>
<li>User-Agent：浏览器的用户代理字符串。</li>
</ul>
<p>关于Headers的详解，参见我的另一篇博客：</p>
<h2 id="XMLHttpRequest2"><a href="#XMLHttpRequest2" class="headerlink" title="XMLHttpRequest2"></a>XMLHttpRequest2</h2><p>XMLHttpRequest2进一步发展了XHR，但是目前并非所有浏览器都完整地实现了XMLHttpRequest2级规范，但所有浏览器都实现了它规定的部分内容。相对于XMLHttpRequest1，2的改进有：</p>
<ul>
<li>新增了FormData对象来管理表单数据；</li>
<li>可以设置HTTP请求的时间限制；</li>
<li>增加了一些进度事件，能够获得数据传输的进度信息；</li>
<li>能够上传文件，并能够获取服务端的二进制数据；</li>
<li>可以发送跨域请求。</li>
</ul>
<h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><p>表单数据的序列化是当前Web应用中使用最频繁的的功能之一，在XMLHttpRequest2之前，我们通常使用如下方法序列化表单数据：</p>
<pre><code>//自定义的序列化表单数据函数
function serialize(form){        
    var parts = new Array();
    var field = null;

    for (var i=0, len=form.elements.length; i &lt; len; i++){
        field = form.elements[i];

        switch(field.type){
            case &quot;select-one&quot;:
            case &quot;select-multiple&quot;:
                for (var j=0, optLen = field.options.length; j &lt; optLen; j++){
                    var option = field.options[j];
                    if (option.selected){
                        var optValue = &quot;&quot;;
                        if (option.hasAttribute){
                            optValue = (option.hasAttribute(&quot;value&quot;) ?
                                        option.value : option.text);
                        } else {
                            optValue = (option.attributes[&quot;value&quot;].specified ?
                                        option.value : option.text);
                        }
                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; +
                                   encodeURIComponent(optValue));
                    }
                }
                break;

            case undefined:     //&lt;fieldset&gt;元素
            case &quot;file&quot;:        //文件输入
            case &quot;submit&quot;:      //提交按钮
            case &quot;reset&quot;:       //重置按钮
            case &quot;button&quot;:      //自定义按钮
                break;

            case &quot;radio&quot;:       //单选按钮
            case &quot;checkbox&quot;:    //复选框
                if (!field.checked){
                    break;
                }
            //执行默认操作
            default:
            //每个参数的名和值必须使用encodeURIComponent()进行编码，才能放到URL的末尾
                parts.push(encodeURIComponent(field.name) + &quot;=&quot; +
                    encodeURIComponent(field.value));
        }
    }        
    return parts.join(&quot;&amp;&quot;);
}

function submitData(){
    var xhr = createXHR();        
    xhr.onreadystatechange = function(event){
        if (xhr.readyState == 4){
            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
                alert(xhr.responseText);
            } else {
                alert(&quot;Request was unsuccessful: &quot; + xhr.status);
            }
        }
    };
    xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);

    // 必须将Content-Type头部信息设置为application/x-www-form-urlencoded
    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
    var form = document.getElementById(&quot;user-info&quot;);            
    xhr.send(serialize(form));
}
</code></pre><p>XMLHttpRequest2级定义了FormData类型，该类型为序列化表单数据以及创建与表单相同格式的数据提供了便利。</p>
<p>基本的使用方法如下：</p>
<pre><code>var data = new FormData();     //创建一个FormData对象
data.append(&quot;name&quot;,&quot;value&quot;);  //向其中添加数据
</code></pre><p>其中,<code>append(key,value)</code>接收两个参数：<code>key</code>对应表单字段的名字，<code>value</code>对应表单字段的值。此外，也可直接向FormData的构造函数中传入表单元素，这样就用表单元素的数据预先向其中填入键值对儿。此时，我们可以使用如下方法序列化表单数据：</p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(event){
   if (xhr.readyState == 4){
       if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
           alert(xhr.responseText);
       } else {
           alert(&quot;Request was unsuccessful: &quot; + xhr.status);
       }
   }
};

xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);
var form = document.getElementById(&quot;user-info&quot;);            
xhr.send(new FormData(form));
</code></pre><p>由于XHR对象能够识别传入的数据类型是FormData实例，并配置适当的头部信息，所以此时不用明确设置请求头部了。</p>
<p>支持FormData的浏览器：FireFox 4+、Safari 5+、Chrome和Android 3+版的Webkit。</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>timeout属性用来设置请求在等待响应多少毫秒后就终止。与该属性对应的事件为timeout，如果浏览器在规定的时间内没有接收到响应，那么就会触发timeout事件，并调用相应的事件处理程序。例：</p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(event){
   try {
       if (xhr.readyState == 4){
           if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
               alert(xhr.responseText);
           } else {
               alert(&quot;Request was unsuccessful: &quot; + xhr.status);
           }
       }
   } catch (ex){
       //assume handled by ontimeout
   }
};

xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);
xhr.timeout = 1000;
xhr.ontimeout = function(){
   alert(&quot;Request did not return in a second.&quot;);
};        
xhr.send(null);
</code></pre><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><ul>
<li>loadstart：在接收到响应数据的第一个字节时触发；</li>
<li>progress：在接收响应期间不断触发；</li>
<li>error：请求发生错误时触发；</li>
<li>abort：调用abort()方法请求被终止时触发；</li>
<li>load：在接收到完整的响应时触发；</li>
<li>loaded：通信完成或触发error、abort、load事件后触发。</li>
</ul>
<h4 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h4><p>用来代替readystatechange事件，响应接收完毕后就会触发load事件，因此也就没必要检查readyState属性的值了。</p>
<h4 id="progress事件"><a href="#progress事件" class="headerlink" title="progress事件"></a>progress事件</h4><p>实例：</p>
<pre><code>var xhr = createXHR();        
xhr.onload = function(event){
    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) ||
            xhr.status == 304){
        console.log(xhr.responseText);
    } else {
        console.log(&quot;Request was unsuccessful: &quot; + xhr.status);
    }
};
xhr.onprogress = function(event){
    if (event.lengthComputable){
      console.log(&quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;);
    }
};
xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);
xhr.send(null);
</code></pre><p>该事件会在浏览器接收新数据期间周期性地触发。<code>onprogress</code>事件处理程序会接收到一个<code>event</code>对象，该对象包含3个额外属性：<code>lengthComputable</code>表示进度信息是否可用，布尔值；<code>position</code>表示已经接收的字节数；<code>totalSize</code>表示根据<code>Content-Length</code>响应头部确定的预期字节数。通过该事件可在文件下载期间实现进度指示器。</p>
<p>文件上传也有progress事件，但上传的progress事件属于XMLHttpRequest.upload对象。</p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>实例：</p>
<pre><code>//html
&lt;input type=&quot;file&quot; id=&quot;myFile&quot; multiple=&quot;multiple&quot;&gt;
//js
var xhr = createXHR();                
var files = document.getElementById(&quot;myFile&quot;).files;
var data = new FormData();
for(var i = 0;i &lt; files.length;i++){
    data.append(&apos;files[]&apos;,files[i]);
   console.log(files[i]);
}
xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);
xhr.send(data);
</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>XMLHttpRequest2级还提供了<code>overrideMimeType()</code>方法，用于重写XHR响应的MIME类型。</p>
<h1 id="跨域资源共享CORS（Cross-Origin-Resource-Sharing）"><a href="#跨域资源共享CORS（Cross-Origin-Resource-Sharing）" class="headerlink" title="跨域资源共享CORS（Cross-Origin Resource Sharing）"></a>跨域资源共享CORS（Cross-Origin Resource Sharing）</h1><p>CORS的基本思想是：在访问跨源资源时，浏览器和服务器通过使用自定义的HTTP头部进行沟通，以决定请求或响应是否被允许。</p>
<p>发送请求方必须附加一个额外的<code>Origin</code>头部，其中包含请求页面的源信息（协议、域名、端口），服务器根据这个头部信息来决定是否给予响应。例：</p>
<pre><code>Origin: http://simulation.gtensor.com
</code></pre><p>如果服务器认为该请求可以接受，就在<code>Access-Control-Allow-Origin</code>头部中回发相同的源信息。如果回发的是<code>*</code>，表示是公共资源。例如：</p>
<pre><code>Access-Control-Allow-Origin: http://simulation.gtensor.com
</code></pre><p>如果没有这个头部信息，或者有这个头部信息但源信息不匹配，浏览器就会驳回请求。请求和响应都不包含cookie信息。</p>
<h2 id="CORS的实现"><a href="#CORS的实现" class="headerlink" title="CORS的实现"></a>CORS的实现</h2><h3 id="IE中实现CORS"><a href="#IE中实现CORS" class="headerlink" title="IE中实现CORS"></a>IE中实现CORS</h3><p>IE8中引入了XDomainRequest（简称XDR）对象来实现跨域通信。XDR的使用和XHR基本相似，但XDR的对象方法只接受两个参数：请求的类型和URL，这是因为所有XDR请求都是异步执行的，不能用它来创建同步请求。例：</p>
<pre><code>var xdr = new XDomainRequest();
xdr.onload = function(){
   alert(xdr.responseText);
};
xdr.onerror = function(){
   alert(&quot;Error!&quot;);
};

//you&apos;ll need to replace this URL with something that works
xdr.open(&quot;get&quot;, &quot;http://www.baidu.com&quot;);
xdr.send(null);    
</code></pre><h3 id="其他浏览器中实现CORS"><a href="#其他浏览器中实现CORS" class="headerlink" title="其他浏览器中实现CORS"></a>其他浏览器中实现CORS</h3><p>其他浏览器（Firefox、Safari、Chrome等）都通过XMR对象实现了对原生CORS的支持，只需在<code>open()</code>方法中传入<strong>绝对URL</strong>即可进行跨域请求。</p>
<h3 id="XDR和XHR的异同"><a href="#XDR和XHR的异同" class="headerlink" title="XDR和XHR的异同"></a>XDR和XHR的异同</h3><p>为了能实现安全可靠的CORS，XDR对象和跨域XHR对象都有一些限制，以下是它们限制的异同。</p>
<p>相同之处：</p>
<ul>
<li>不能发送和接收cookie；</li>
<li>不能设置自定义头部；</li>
<li>不能访问响应头部信息。</li>
</ul>
<p>不同之处：</p>
<ul>
<li>XDR只支持get和post请求；</li>
<li>XDR只支持异步请求，而跨域XHR支持异步请求和同步请求；</li>
<li>跨域XHR对象可以访问<code>status</code>和<code>statusText</code>属性。</li>
</ul>
<p>两个对象的共同属性、方法和时间：responseText属性；open()、send()、abort()方法；onerror、onload事件。</p>
<h3 id="跨浏览器CORS的实现"><a href="#跨浏览器CORS的实现" class="headerlink" title="跨浏览器CORS的实现"></a>跨浏览器CORS的实现</h3><p>XHR对象有一个<code>withCredentials</code>属性用来指定某个请求是否发送凭据（<code>true</code>表示发送，<code>false</code>表示不发送）。默认情况下跨源请求是不发送凭据的。如果服务器接受带凭据的请求那么会用如下HTTP头部来响应：<code>Access-Control-Allow-Credentials:true</code>。如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript。此时，  <code>responseText</code>是空串，<code>status</code>是0，此外还会调用<code>onerror()</code>事件处理程序。</p>
<p>检测XHR是否支持CORS的一个简单方法是：检查XHR是否存在<code>withCredentials</code>属性，之后在结合检测XDR对象是否存在，就能实现一个跨浏览器的CORS了。下面是代码：</p>
<pre><code>function createCORSRequest(method,url){
  var xhr = new XMLHttpRequest();
  if(&quot;withCredentials&quot; in xhr){
    xhr.open(method,url,true);
  }else if(typeof &apos;XDomainRequest&apos; != &quot;undefined&quot;){
    xhr = new XDomainRequest();
    xhr.open(method,url);
  }else{
    xhr = null;
  }
  return xhr;
}
</code></pre><p>以下是使用XHR进行的一个跨域请求的截图：</p>
<p><img src="/images/2017-04-21/CORS-XHR.jpg" alt=""></p>
<h2 id="其他跨越技术"><a href="#其他跨越技术" class="headerlink" title="其他跨越技术"></a>其他跨越技术</h2><h3 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h3><p>实现原理：一个网页可以从任何网页中加载图像，而不用担心跨域问题。因此可以通过动态创建图像来实现跨域请求，并通过所创建图像的<code>onload</code>和 <code>onerror</code>事件处理程序来确定是否接收到了响应。例：</p>
<pre><code>var img = new Image();
img.onload = img.onerror = function(){
  alert(&quot;Done!&quot;);
}
img.src = &quot;http://www.example.com/test?name=fantasticZhang&quot;;
</code></pre><p>图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据通过查询字符串形式发送，响应可以是任意的内容。使用图像Ping时浏览器得不到任何具体的数据，但可以通过侦听<code>load</code>和<code>error</code>事件来知道响应是什么时候接收到的。</p>
<p>缺点：只能发送GET请求；无法访问服务器的响应文本。 用途：跟踪用户点击页面次数、跟踪动态广告曝光次数等。</p>
<h3 id="JSONP（JSON-with-padding）"><a href="#JSONP（JSON-with-padding）" class="headerlink" title="JSONP（JSON with padding）"></a>JSONP（JSON with padding）</h3><p>实现原理：动态创建<code>&lt;script&gt;</code>元素，并为<code>src</code>属性指定一个跨域URL。例：</p>
<pre><code>function handleResponse(response){
  alert(response.name);
}

var script = document.createElement(&apos;script&apos;);
script.src = &quot;http://www.example.com/test?callback=handleResponse&quot;;
document.body.insertBefore(script,document.body.firstChild);
</code></pre><p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，回调函数的名字在请求中指定，例如上面例子中的<code>handleResponse</code>;数据就是传入回调函数中的JSON数据。</p>
<p>与图像Ping相比它的优点：支持双向通信，能够直接访问响应文本。</p>
<p>缺点：JSONP是从其他域中加载代码执行的，因此如果其他域不安全，响应中可能会夹杂恶意代码；很难确定JSONP请求是否失败。</p>
<h1 id="Ajax的进一步扩展——Comet"><a href="#Ajax的进一步扩展——Comet" class="headerlink" title="Ajax的进一步扩展——Comet"></a>Ajax的进一步扩展——Comet</h1><p>Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。使服务器几乎能够实时地向客户端推送数据。实现Comet的手段主要有两个：<strong>长轮询</strong>和<strong>流</strong>。</p>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>首先说一下传统轮询，即短轮询。短轮询是浏览器定时向服务器发送请求，看有没有更新的数据，服务器在接收到请求后立即响应，无论数据是否有效。时间线如下图所示：</p>
<p><img src="/images/2017-04-21/短轮询.PNG" alt=""></p>
<p>而长轮询则是对短轮询的改进。页面发起一个请求，之后服务器一直保持连接打开，直到有数据可以发送。浏览器在接收完数据后关闭连接，并随即又发起一个到服务器的新请求。时间线如下：</p>
<p><img src="/images/2017-04-21/长轮询.PNG" alt=""></p>
<p>下面是使用XHR实现长轮询的一个例子：</p>
<pre><code>//html
&lt;input type=&quot;button&quot; value=&quot;点我发起长轮询&quot; id=&quot;btn&quot; onclick=&quot;long()&quot;&gt;
//js
function long(){
   var xhr = new XMLHttpRequest();
   xhr.onload = function(){
       if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300) || xhr.status==304){
           console.log(xhr.responseText);
           var btn = document.getElementById(&quot;btn&quot;);
           btn.click();
       }else{
           console.log(&quot;error:&quot;+xhr.status);
       }

   }
   xhr.open(&quot;get&quot;,&quot;http://www.example.com&quot;,true);
   xhr.send(null);
}
</code></pre><h2 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h2><p>HTTP流是在页面的整个生命周期内只使用一个HTTP连接。即浏览器向服务器发送一个请求，服务器保持连接打开，然后周期性地向浏览器发送数据。</p>
<p>使用XHR对象实现流的代码如下所示：</p>
<pre><code>function createStreamingClient(url, progress, finished){        

    var xhr = new XMLHttpRequest(),
    received = 0;
    xhr.onreadystatechange = function(){
        var result;

        if (xhr.readyState == 3){

            //只取得最新数据并调整计数器
            result = xhr.responseText.substring(received);
            received += result.length;

            //调用回调函数处理最新数据
            progress(result);

        } else if (xhr.readyState == 4){
            finished(xhr.responseText);
        }
    };
    xhr.open(&quot;get&quot;, url, true);
    xhr.send(null);
    return xhr;
}

var client = createStreamingClient(&quot;streaming.php&quot;, function(data){
                alert(&quot;Received: &quot; + data);
             }, function(data){
                alert(&quot;Done!&quot;);
             });
</code></pre><p>思路：随着从服务器不断接收数据，<code>readyState</code>的值会周期性的变为3，因此只需通过侦听<code>readystatechange</code>事件并检测<code>readyState</code>的值是否为3即可。当<code>readyState</code>值变为3时，<code>responseText</code>属性中保存着接收到的所有数据，因此需要比较此前接收到的数据并决定从什么位置开始取得最新的数据。</p>
<h2 id="SSE（Server-Sent-Event-服务器发送事件）"><a href="#SSE（Server-Sent-Event-服务器发送事件）" class="headerlink" title="SSE（Server-Sent Event,服务器发送事件）"></a>SSE（Server-Sent Event,服务器发送事件）</h2><p>SSE是一种实现Comet交互的浏览器API，通过<code>EventSource</code>对象实现。支持短轮询、长轮询和HTTP流，能在断开连接时自动确定何时重新连接。</p>
<p>SSE API可创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的<strong>MIME</strong>类型<strong>必须</strong>是<code>text/event-stream</code>，而且是浏览器中的JavaScript API能解析格式输出。例：</p>
<pre><code>var source = new EventSource(&quot;myEvent.php&quot;);
source.onmessage = function(event){
  var data = event.data;
  //处理数据
}
</code></pre><ul>
<li>在创建EventSource对象时传入的URL必须与创建对象的页面<strong>同源</strong>；</li>
<li><code>EventSource</code>的实例有一个<code>readyState</code>属性：值<code>0</code>表示正在连接到服务器，值<code>1</code>表示打开了连接，值<code>2</code>表示关闭了连接；</li>
<li>三个事件。<code>open</code>事件：在建立连接时触发，<code>message</code>事件：在从服务器接收到新事件时触发，<code>error</code>事件：在无法建立连接时触发；</li>
<li>服务器发回的数据以字符串的形式保存在<code>event.data</code>中；</li>
<li>可通过调用<code>close()</code>方法来强制立即断开连接并不再重新连接。</li>
</ul>
<h2 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h2><p>Web Sockets是一种与服务器进行全双工、双向通信的信道。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到服务器以发起连接。在取得服务器的响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。因此，只有支持这种协议的专门服务器才能正常工作。使用Web Socket时，未加密的连接变为<code>ws://</code>，加密的连接变为<code>wss://</code>。</p>
<p>优点：能够在服务器和客户端之间发生非常少量的数据，而不必担心HTTP那样字节集的开销。<br>缺点：制定协议的时间比制定JavaScript API的时间还要长。</p>
<p>例：</p>
<pre><code>var socket = new WebSocket(&quot;ws://www.example.com/test&quot;);
socket.send(&quot;hello&quot;);
socket.onopen = function(){
  alert(&quot;Connection established.&quot;)
};
socket.onerror = function(){
  alert(&quot;Connection error.&quot;)
};
socket.onmessage = function(event){
  var data = event.data;
  //处理数据
}
socket.onclose = function(event){  
  alert(&quot;was clean? &quot; + event.wasClean + &quot; Code=&quot; +event.code+&quot; Reason=&quot;+event.reason);
}
</code></pre><ul>
<li>在创建WebSocket对象时传入的URL必须是<strong>绝对URL</strong>；</li>
<li><code>readyState</code>属性：值<code>WebSocket.OPENING</code>表示正在建立连接，值<code>WebSocket.OPEN</code>表示已经建立了连接，值<code>WebSocket.CLOSING</code>表示正在关闭连接，值<code>WebSocket.CLOSE</code>表示已经关闭连接；</li>
<li>四个事件。<code>open</code>事件：在成功建立连接时触发，<code>message</code>事件：在从服务器接收到新消息时触发，<code>error</code>事件：在发生错误时触发，连接不能持续，<code>close</code>事件：连接关闭时触发。</li>
<li>只能通过WebSocket连接发送<strong>纯文本</strong>数据；</li>
<li>使用<code>send()</code>方法向服务器发送数据；</li>
<li>使用<code>close()</code>方法关闭连接。</li>
<li><code>close</code>事件的<code>event</code>对象有单个额外的属性:<code>wasClean</code>表示连接是否已明确关闭；<code>code</code>是服务器返回的数值状态码；<code>reason</code>是服务器发回的消息。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5简介]]></title>
      <url>https://fantasticzhang.github.io/2017/03/20/HTML5%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>HTML5的新特性有很多，在这里主要阐述其中一些最有趣且最重要的特性。</p>
<h2 id="结构和内容元素"><a href="#结构和内容元素" class="headerlink" title="结构和内容元素"></a>结构和内容元素</h2><h3 id="HTML5结构元素"><a href="#HTML5结构元素" class="headerlink" title="HTML5结构元素"></a>HTML5结构元素</h3><p>HTML5中新的结构元素提供了许多用于描述各种网页组成部分的方法。在这之前我们只能使用大量的<code>div</code>元素和<code>span</code>元素来设计文档结构，但现在我们能够使用更多的元素了，如<code>section</code>、<code>header</code>、<code>hgroup</code>、<code>footer</code>、<code>nav</code>、<code>article</code>、<code>aside</code>。每一种元素都有独特的用途，能够帮助我们把现代网页上最常见的区域一一区分开。</p>
<ul>
<li><p>section元素</p>
<p>用来定义网站中特定的可区别的区域，按主题对内容进行分组，即将内容分组到一些具有独特主题或关注点的区域中。</p>
</li>
<li><p>header元素</p>
<p>一个网页的页眉部分，其中可以包含标题、Logo、导航及其他与页眉相关的内容。</p>
</li>
<li><p>hgroup元素</p>
<p>将标题进行分组的元素。可用于包含多个标题元素(h1~h6)，常见用法是显示带有标题和小标题的内容。</p>
</li>
<li><p>footer元素</p>
<p>一个网页的页脚部分，其中可以包含版权声明和网站制作中信息等其他与页脚相关的内容。此外，<code>footer</code>还可以包含一些相关内容的链接，也就是说它们很适合在<code>section</code>和<code>article</code>中使用。</p>
</li>
<li><p>nav元素</p>
<p>显示指向页面某一部分或网站其他页面的导航链接。最常见的用途是包含网站的主导航菜单。</p>
</li>
<li><p>article元素</p>
<p>任何独立成文且可以以其他格式重用（例如：通过RSS分发）的内容都应该置于一个<code>article</code>元素中。如：博客文章、评论、论坛帖子、新闻文章等。关于<code>article</code>元素的使用，一条很好的经验法则就是：判断其内容在RSS阅读器中是否可以作为一个整体独立存在。</p>
</li>
<li><p>aside元素</p>
<p>包含内容周围的相关内容。典型应用是引文和旁注。</p>
</li>
</ul>
<h3 id="HTML5内容元素"><a href="#HTML5内容元素" class="headerlink" title="HTML5内容元素"></a>HTML5内容元素</h3><ul>
<li><p>figure元素</p>
<p><code>figure</code>元素的一个典型用途是包含图像、代码和其他内容对主内容给出某方面的说明。<code>figure</code>元素中的内容应该可以从主内容中删除而不会破坏主内容。</p>
</li>
<li><p>figcaption元素</p>
<p>有一些注解内容需要使用一个简短的标题，通常这些内容是显示在原始内容的上下文之外的。要在<code>figure</code>元素中加入标题需要使用<code>figcaption</code>元素。</p>
</li>
<li><p>mark元素</p>
<p>那些突出显示以表示引用的内容应该包含在<code>mark</code>元素中。也就是说在一段引文中对原作者没有加以强调的一句话进行突出显示。另一个用途是突出显示与用户当前活动相关的内容，例如可以用<code>mark</code>元素来突出显示用户在搜索中使用的关键词。</p>
<p>注：<code>em</code>或<code>strong</code>表示原作者认为重要或需要强调的内容；<code>mark</code>表示某人在一个不同的上下文中引入原作者的话时认为重要的内容，或是用户活动的结果。</p>
</li>
<li><p>time元素</p>
<p>在内容中显示时间或日期时用该元素，所使用的任何时间都必须采用24小时格式。该元素还可以包含两个属性:<code>datetime</code>，表示在元素中指定的确切日期和时间；<code>pubtime</code>，表示文章或整个文档发布时<code>time</code>元素所指定的日期和时间。</p>
</li>
</ul>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="浏览器验证"><a href="#浏览器验证" class="headerlink" title="浏览器验证"></a>浏览器验证</h3><p>HTML5表单具有浏览器内置的验证机制。默认情况下，如果浏览器支持HTML5，则表单验证都是启用的，如果验证失败会显示一条友好的警告信息。可以在<code>form</code>元素中添加<code>novalidate</code>属性来关闭验证。</p>
<h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>HTML5增加了一些新的输入类型，使得我们现在能够定义电子邮件地址、电话号码和URL的输入框等。新增的输入类型有：</p>
<ul>
<li>color：定义拾色器；</li>
<li>date：定义日期字段（带有calendar控件）；</li>
<li>datetime：定义日期字段（带有calendar和time控件）；</li>
<li>datetime-local：定义日期字段（带有calendar和time控件）；</li>
<li>month：定义日期字段的月（带有calendar控件）；</li>
<li>week：定义日期字段的周（带有calendar控件）；</li>
<li>time：定义日期字段的时分秒（带有time控件）；</li>
<li>email：定义用于e-mail地址的文本字段；</li>
<li>number：定义带有spinner控件的数字字段；</li>
<li>range：定义带有slider控件的数字字段；</li>
<li>search：定义用于搜索的文本字段；</li>
<li>tel：定义用于电话号码的文本字段；</li>
<li>url：定义用于URL的文本字段。</li>
</ul>
<h3 id="输入属性"><a href="#输入属性" class="headerlink" title="输入属性"></a>输入属性</h3><p>除了输入类型，HTML5中还为<code>input</code>元素增加了许多其他的属性：autocomplele、autofocus、form、formaction、formenctype、formmethod、formnovalidate、formtarget、height、width、list、max、min、multiple、pattern、placeholder、required、step。</p>
<h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p>HTML5出现之前，如果我们想在浏览器中播放媒体需要借助外部插件和应用程序，浏览器本身不支持图形处理。而HTML5的一个核心目标是改进媒体支持，引入了新的媒体元素（如<code>audio</code>、<code>video</code>），使得浏览器不需要使用外部插件就能够直接播放媒体。而<code>canvas</code>元素使浏览器能够直接创建和处理图像和图形。由于<code>canvas</code>在之前的博客中已经单独介绍过，因此下面简单介绍一下<code>audio</code>和<code>video</code>。</p>
<h3 id="audio元素"><a href="#audio元素" class="headerlink" title="audio元素"></a>audio元素</h3><p>音频播放器，属性有：<code>src</code>、<code>controls</code>、<code>autoplay</code>、<code>loop</code>、<code>preload</code>。可使用这些属性对<code>audio</code>元素进行细粒度的控制。</p>
<p>目前，主流浏览器对<code>audio</code>元素的支持各不相同，有多种音频编码器，其中最常用的的格式是MP3和OGG。可以使用如下方式实现跨浏览器HTML5音频支持。</p>
<pre><code>&lt;audio  controls &gt;
    &lt;source src=&quot;sound.ogg&quot;&gt;
    &lt;source src=&quot;sound.mp3&quot;&gt;
&lt;/audio&gt;
</code></pre><h3 id="video元素"><a href="#video元素" class="headerlink" title="video元素"></a>video元素</h3><p>视频播放器，除具有<code>audio</code>元素的所有属性外，还有属性：<code>height</code>、<code>width</code>、<code>muted</code>、<code>poster</code>。</p>
<p>可以采用与<code>audio</code>元素同样的方式来实现跨浏览器HTML5视频支持，即使用<code>source</code>元素。</p>
<h2 id="HTML5页面的结构"><a href="#HTML5页面的结构" class="headerlink" title="HTML5页面的结构"></a>HTML5页面的结构</h2><p>前面几节简单介绍了HTML5的一些新特性，下面是一个简单的HTML5页面。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;A basic HTML5 blog homepage&lt;/title&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;!-- CSS and JavaScript to go here --&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;header&gt;
            &lt;!-- Website name and navigation --&gt;
            &lt;h1&gt;My amazing blog&lt;/h1&gt;

            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href=&quot;/archive/&quot;&gt;Archive&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href=&quot;/contact/&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;section&gt;
            &lt;!-- Blog articles - repeat as many times as required --&gt;
            &lt;article&gt;
                &lt;header&gt;
                    &lt;hgroup&gt;
                        &lt;h1&gt;&lt;a href=&quot;/blog/first-post-link/&quot;&gt;Main heading of the first blog post&lt;/a&gt;&lt;/h1&gt;
                        &lt;h2&gt;Sub-heading of the first blog post&lt;/h2&gt;
                    &lt;/hgroup&gt;
                    &lt;p&gt;Posted on the &lt;time pubdate datetime=&quot;2010-10-30T13:08&quot;&gt;30 October 2010 at 1:08 PM&lt;/time&gt;&lt;/p&gt;
                &lt;/header&gt;

                &lt;p&gt;Summary of the first blog post.&lt;/p&gt;
            &lt;/article&gt;

            &lt;article&gt;
                &lt;header&gt;
                    &lt;hgroup&gt;
                        &lt;h1&gt;&lt;a href=&quot;/blog/second-post-link/&quot;&gt;Main heading of the second blog post&lt;/a&gt;&lt;/h1&gt;
                        &lt;h2&gt;Sub-heading of the second blog post&lt;/h2&gt;
                    &lt;/hgroup&gt;
                    &lt;p&gt;Posted on the &lt;time pubdate datetime=&quot;2010-10-26T09:36&quot;&gt;26 October 2010 at 9:36 AM&lt;/time&gt;&lt;/p&gt;
                &lt;/header&gt;

                &lt;p&gt;Summary of the second blog post.&lt;/p&gt;
            &lt;/article&gt;

            &lt;article&gt;
                &lt;header&gt;
                    &lt;hgroup&gt;
                        &lt;h1&gt;&lt;a href=&quot;/blog/third-post-link/&quot;&gt;Main heading of the third blog post&lt;/a&gt;&lt;/h1&gt;
                        &lt;h2&gt;Sub-heading of the third blog post&lt;/h2&gt;
                    &lt;/hgroup&gt;
                    &lt;p&gt;Posted on the &lt;time pubdate datetime=&quot;2010-10-21T17:13&quot;&gt;21 October 2010 at 5:13 PM&lt;/time&gt;&lt;/p&gt;
                &lt;/header&gt;

                &lt;p&gt;Summary of the third blog post.&lt;/p&gt;
            &lt;/article&gt;

            &lt;!-- Blog sidebar --&gt;
            &lt;aside&gt;
                &lt;h2&gt;Subscribe to the RSS feed&lt;/h2&gt;
                &lt;p&gt;Make sure you don&apos;t miss a blog post by &lt;a href=&quot;/rss&quot;&gt;subscribing to the RSS feed&lt;/a&gt;.&lt;/p&gt;
            &lt;/aside&gt;        
        &lt;/section&gt;

        &lt;footer&gt;
            &lt;!-- Copyright and other stuff --&gt;
            &lt;p&gt;My amazing blog &amp;copy; 2010&lt;/p&gt;
        &lt;/footer&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="对HTML5的误解"><a href="#对HTML5的误解" class="headerlink" title="对HTML5的误解"></a>对HTML5的误解</h2><p>下面的一些技术或特性并不属于HTML5，一定要注意。</p>
<ul>
<li>CSS3：应用样式的技术，与内容或结构无关。</li>
<li>Web Fonts：自定义字体，属于CSS3。</li>
<li>Geolocation：了解用户位置，一种JavaScript API，是由想要支持它的浏览器实现的。</li>
<li>SVG：一种允许使用XML创建2D矢量图的语言。是一种使用XML来描述图形的完全独立的技术。</li>
<li>Web Storage：新存储方法，一种JavaScript API，是由想要支持它的浏览器实现的。</li>
<li>Web Workers：可在后台执行一些繁重的计算及其他高强度的任务，从而不会导致网页显示减慢或影响用户体验。一种JavaScript API，是由想要支持它的浏览器实现的。</li>
<li>WebSocket：可实现双向通信。一种JavaScript API，是由想要支持它的浏览器实现的。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenVPN的安装及使用]]></title>
      <url>https://fantasticzhang.github.io/2017/03/13/OpenVPN%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h2><ul>
<li>开发语言：C/C++</li>
<li>操作系统：跨平台，支持Linux、Windows、MacOS X等</li>
<li><a href="https://github.com/OpenVPN/openvpn" target="_blank" rel="external">github</a></li>
</ul>
<h2 id="编译、运行、安装过程"><a href="#编译、运行、安装过程" class="headerlink" title="编译、运行、安装过程"></a>编译、运行、安装过程</h2><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p> 源码安装</p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><ul>
<li><p>安装c编译器及OpenVPN所需的插件</p>
<p>gcc、g++、openssl、pam、lzo</p>
<p>安装命令为：</p>
<ul>
<li>sudo apt-get install gcc</li>
<li>sudo apt-get install g++</li>
<li>sudo apt-get install openssl</li>
<li>sudo apt-get install libssl-dev</li>
<li>sudo apt-get install libpam0g-dev  </li>
<li>sudo apt-get install liblzo2-dev  </li>
</ul>
</li>
<li><p>从<a href="https://openvpn.net/index.php/download/community-downloads.html" target="_blank" rel="external">官网</a>下载源码</p>
</li>
<li><p>编译、安装</p>
<ul>
<li>tar -zxf openvpn-2.3.14.tar.gz</li>
<li>cd openvpn-openvpn-2.3.14</li>
<li>./configure</li>
<li>make</li>
<li>make install</li>
</ul>
</li>
</ul>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ul>
<li><p>搭建CA，并为OpenVPN server端和client端产生证书和密钥</p>
<p>使用<a href="https://github.com/OpenVPN/easy-rsa" target="_blank" rel="external">easy-rsa</a>来搭建CA。命令如下：</p>
<ul>
<li>CA：<ul>
<li>./easyrsa init-pki</li>
<li>./easyrsa build-ca</li>
</ul>
</li>
<li>server:<ul>
<li>./easyrsa gen-req server</li>
<li>./easyrsa sign-req server server</li>
</ul>
</li>
<li>client:<ul>
<li>./easyrsa gen-req client1</li>
<li>./easyrsa sign-req client client1</li>
</ul>
</li>
<li>DH params:<ul>
<li>./easyrsa gen-dh</li>
</ul>
</li>
</ul>
</li>
<li><p>OpenVPN server端配置</p>
<p>在上一步中产生了所需要的文件，其中server端需要用到的有ca.crt、ca.key、dh.pem、server.crt、server.key</p>
<p>在OpenVPN server端建立config文件夹，将以上文件拷贝到该文件夹下，此外 server端还需要配置文件server.conf，OpenVPN已经在安装包的sample/sample-config-files子目录中为我们提供了相关的示例文件server.conf，并且配置文件中的每个配置选项均有详细的英文说明。将server.conf文件拷贝到config目录中，然后再对其进行修改。</p>
<p>server.conf文件中指定了监听的本机IP、端口号、CA证书的文件路径、server端的证书文件路径及私钥文件路径等，我们只需按照实际情况进行修改。</p>
<p>OpenVPN自身的配置到此结束，但在使用前还必须开启Linux系统的路由转发功能：</p>
<ul>
<li>vi /etc/sysctl.conf</li>
</ul>
<p>找到 “#net.ipv4.ip_forward=1” 这一行，删除那个 “#” 号，然后保存退出。接下来使转发生效：</p>
<ul>
<li>sysctl -p  </li>
</ul>
<p>如果一切正常，你将只会看到以下结果：</p>
<ul>
<li>net.ipv4.ip_forward=1</li>
</ul>
<p>然后设置iptables规则，通过配置NAT将VPN网段IP转发到eth0网卡：</p>
<ul>
<li>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j SNAT –to 10.108.112.6 （适用于固定IP的VPS）  </li>
</ul>
<p>或者:</p>
<ul>
<li>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE （通用方法，自动获取eth0网卡的IP地址）  </li>
</ul>
<p>设置OpenVPN端口通过：</p>
<ul>
<li>iptables -A INPUT -p TCP –dport 1194 -j ACCEPT  </li>
<li>iptables -A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT  </li>
</ul>
<p>最后，在服务端启动OpenVPN：</p>
<ul>
<li>openvpn 配置文件（server.conf）路径</li>
</ul>
</li>
<li><p>OpenVPN client端配置</p>
<p>client端可以有多个，在本次实验中只有一个client端：client1。客户端client1需要用到的文件有：ca.crt、client1.crt、client1.key。</p>
<p>在OpenVPN client端建立config文件夹，将以上文件拷贝到该文件夹下，此外 client端还需要配置文件client.conf，OpenVPN已经在安装包的sample/sample-config-files子目录中为我们提供了相关的示例文件client.conf，并且配置文件中的每个配置选项均有详细的英文说明。将client.conf文件拷贝到config目录中，然后再对其进行修改。</p>
<p>client.conf文件中指定了连接的远程服务器的实际IP地址和端口号、CA证书的文件路径、当前客户端的证书文件路径和私钥文件路径等，我们只需按照实际情况进行修改。</p>
<p>在客户端启动OpenVPN：</p>
<ul>
<li>openvpn 配置文件（client.conf）路径</li>
</ul>
<p>接下来，在client端ping服务端的虚拟地址：</p>
<ul>
<li>ping 10.8.0.1</li>
</ul>
<p>如果能ping通，则说明客户端已经和OpenVPN服务端连接成功。</p>
</li>
</ul>
<h3 id="证书导入接口"><a href="#证书导入接口" class="headerlink" title="证书导入接口"></a>证书导入接口</h3><p>  由上一节的实际操作过程可知，server端的证书导入接口在配置文件 server.conf 中；client端的证书导入接口在配置文件 client.conf 中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实例demo之FidoBowling小游戏]]></title>
      <url>https://fantasticzhang.github.io/2017/03/12/%E5%AE%9E%E4%BE%8Bdemo%E4%B9%8BFidoBowling%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<link type="text/css" href="/css/FidoBowling.css" rel="stylesheet">

<div id="info">
    <h2>Fido Bowling</h2>
    <p>基于Canvas开发的一个小游戏——太空保龄球。</p>

    <h2>游戏规则</h2>
    <p>太空保龄球游戏在窗口的上部包含一个圆形平台，一群静止的小行星分布在圆形平台上，另一个稍大些的小行星放在离圆形平台较远的位置，作为玩家投掷时使用的圆球。</p>
    <ul>
      <li>用鼠标向下拖动玩家小行星将其弹向圆形平台，使其尽可能多地撞开位于圆形平台上的小行星。</li>
      <li>当圆形平台上所有的小行星都被撞离平台时，你就获胜了！</li>
      <li>游戏的分数是根据你撞开所有小行星所用的撞击次数来计算的。好了，开始游戏吧！</li>
    </ul>
</div>

<div id="game">
    <div id="gameUI">
        <div id="gameIntro">
            <h1>太空保龄球</h1>
            <p>一个很有趣的小游戏</p>
            <p><a id="gamePlay" class="button" href="">开始游戏</a></p>
        </div>
        <div id="gameStats">
            <p>小行星数量：<span id="gameRemaining"></span></p>
            <p>撞击次数：<span class="gameScore"></span></p>
            <p><a class="gameReset" href="">重置</a></p>
        </div>
        <div id="gameComplete">
            <h1>你赢了！</h1>
            <p>恭喜你，你撞击了<span class="gameScore"></span>次就完成了游戏。</p>
            <p><a class="gameReset button" href="">再玩一次</a></p>
        </div>
    </div>
    <canvas id="gameCanvas" width="350" height="600">
        <!--游戏界面-->
    </canvas>
</div>

<script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="/js/FidoBowling.js"></script>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[坐标旋转公式]]></title>
      <url>https://fantasticzhang.github.io/2017/03/10/%E5%9D%90%E6%A0%87%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>该公式用于计算某个点绕另外一个点旋转一定角度后的坐标，推到过程如下。</p>
<p><img src="/images/2017-03-10/坐标旋转示意图.jpg" alt=""></p>
<p>A<code>(x，y)</code>绕B<code>(a，b)</code>旋转<code>β</code>度后的位置为C<code>(c，d)</code>，则<code>x</code>，<code>y</code>，<code>a</code>，<code>b</code>，<code>β</code>，<code>c</code>，d有如下关系式：</p>
<ul>
<li><p>设A点旋转前的角度为<code>δ</code>，则旋转(逆时针)到C点后角度为<code>δ+β</code></p>
</li>
<li><p>求A，B两点的距离：<code>dist1=|AB|=y/sin(δ)=x/cos(δ)</code></p>
</li>
<li><p>求C，B两点的距离：<code>dist2=|CB|=d/sin(δ+β)=c/cos(δ+β)</code></p>
</li>
<li><p>显然dist1=dist2，设dist1=r所以：</p>
</li>
</ul>
<p>　　<code>r=x/cos(δ)=y/sin(δ)=d/sin(δ+β)=c/cos(δ+β)</code></p>
<ul>
<li><p>由三角函数两角和差公式知：</p>
<pre><code>sin(δ+β)=sin(δ)cos(β)+cos(δ)sin(β)
cos(δ+β)=cos(δ)cos(β)-sin(δ)sin(β)
</code></pre><p>  所以得出：</p>
<pre><code>c=r*cos(δ+β)=r*cos(δ)cos(β)-r*sin(δ)sin(β)=xcos(β)-ysin(β)
d=r*sin(δ+β)=r*sin(δ)cos(β)+r*cos(δ)sin(β)=ycos(β)+xsin(β)
</code></pre></li>
</ul>
<p>即旋转后的坐标<code>(c,d)</code>只与旋转前的坐标<code>(x,y)</code>及旋转的角度β有关</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实例demo之Canvas小动画]]></title>
      <url>https://fantasticzhang.github.io/2017/03/10/%E5%AE%9E%E4%BE%8Bdemo%E4%B9%8BCanvas%E5%B0%8F%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>使用Canvas实现的一个动画效果：一个简单的太空场景，在太空深处有一个动态的小行星群，这里每个小行星的颜色是随机的。点击<code>Start</code>按钮，行星开始运动，点击<code>Stop</code>按钮，行星将会静止。</p>
<link type="text/css" href="/css/asteroids.css" rel="stylesheet">

<canvas id="myCanvas" height="500" width="850">

<p></p></canvas><p></p>
<div id="myButtons"><br>    <button id="start">Start</button><br>    <button id="stop">Stop</button><br></div>

<script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script type="text/javascript" src="/js/asteroids.js"></script>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Canvas学习（三）]]></title>
      <url>https://fantasticzhang.github.io/2017/03/09/Canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>接下来是Canvas学习的最后部分——动画。</p>
<h2 id="动画循环"><a href="#动画循环" class="headerlink" title="动画循环"></a>动画循环</h2><p>动画循环是创建动画效果的基础，动画循环的三要素：更新需要绘制的对象（如移动对象的位置）、清除画布、在画布上重新绘制对象。如下图所示：</p>
<p><img src="/images/2017-03-09/画布中的典型循环.PNG" alt=""></p>
<h3 id="创建循环"><a href="#创建循环" class="headerlink" title="创建循环"></a>创建循环</h3><p>下面是一段简单的循环代码：</p>
<pre><code>//HTML
&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:1px solid #000000; display: block; &quot;&gt;

&lt;/canvas&gt;
&lt;button id=&quot;start&quot;&gt;Start&lt;/button&gt;
&lt;button id=&quot;stop&quot;&gt;Stop&lt;/button&gt;

//js
var canvas = $(&quot;#myCanvas&quot;);
var cxt = canvas.get(0).getContext(&quot;2d&quot;);
var canvasWidth = canvas.width();
var canvasHeight = canvas.height();

var startButton = $(&quot;#start&quot;);
var stopButton = $(&quot;#stop&quot;);
var ifPlay = true;

startButton.hide();
startButton.click(function(){
    $(this).hide();
    stopButton.show();
    ifPlay = true;
    animate();
});
stopButton.click(function(){
    $(this).hide();
    startButton.show();
    ifPlay = false;
});

function animate(){

    if(ifPlay){
        setTimeout(animate,33);
    }
}
animate();
</code></pre><p>以上代码中最重要的是<code>animate</code>函数，该函数使用<code>setTimeout</code>方法设置了一个定时器，每隔33毫秒调用一次<code>animate</code>函数，这样就创建了一个无限循环，可用来实现动画效果。<code>Start</code>、<code>Stop</code>按钮用来控制动画的启动和停止。</p>
<p>使用33毫秒作为动画循环时间间隔的原因：动画在每秒钟需要的帧数通常介于25到30帧之间，1秒=1000毫秒，1000除以30得33毫秒。</p>
<p>现在我们已经建立了基本的动画循环，接下来就需要在动画循环里添加三要素，即更新、清除和绘制过程了。</p>
<h3 id="更新、清除、绘制"><a href="#更新、清除、绘制" class="headerlink" title="更新、清除、绘制"></a>更新、清除、绘制</h3><p>下面是一个简单的动画，使一个正方形每帧右移1像素。</p>
<pre><code>var x = 0;
function animate(){

   x++;                                              //更新
   cxt.clearRect(0,0,canvasWidth,canvasHeight);     //清除
   cxt.fillRect(x,250,20,20);                      //绘制

   if(ifPlay){
       setTimeout(animate,33);
   }
}
animate();
</code></pre><p>效果如下：</p>
<p><img src="/images/2017-03-09/简单动画.PNG" alt=""></p>
<h2 id="记忆要绘制的形状"><a href="#记忆要绘制的形状" class="headerlink" title="记忆要绘制的形状"></a>记忆要绘制的形状</h2><p>动画循环三要素中，清除和绘制都很简单，难点在更新，即：如何准确记忆要绘制的对象的内容及位置。</p>
<p>如果动画中的形状很少可以使用上一小节中的方法——简单变量来记忆，<br>但通常的动画中形状非常多，此时这种方法就非常笨拙了——需要复制大量代码，修改起来也非常复杂。其实需要解决的问题有两个：第一，不管形状的数量有多少，首先考虑如何存储每个形状的位置值；第二，在不复制代码的情况下如何绘制每个形状。针对这两个问题，可以考虑用对象和数组来实现。首先可以将每个形状视为一个对象，对象的属性即保存了形状的位置<code>(x,y)</code>、内容等信息；之后用数组来存储对象，就可通过循环来绘制每个形状。</p>
<p>示例代码：</p>
<pre><code>//用对象来定义形状
var Shape = function (x,y,width,height) {
   this.x = x;
   this.y = y;
   this.width = width;
   this.height = height;
};
//用数组保存要绘制的所有形状
var shapes = new Array();
for(var i=0;i&lt;10;i++){
   var x = Math.random()*250;
   var y = Math.random()*250;
   var width = height = Math.random()*50;
   shapes.push(new Shape(x,y,width,height));
}

function animate(){
   cxt.clearRect(0,0,canvasWidth,canvasHeight);  //清除
   //循环每个形状
   var shapesLength = shapes.length;
   for (var i = 0; i &lt; shapesLength; i++) {
       var tmpShape = shapes[i];
       tmpShape.x++;   //更新
       cxt.fillRect(tmpShape.x, tmpShape.y, tmpShape.width, tmpShape.height);  //绘制
   };
   if(ifPlay){
       setTimeout(animate,33);
   }
}
animate();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-09/保存形状.PNG" alt=""></p>
<h2 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h2><p>有时候需要实现沿着圆周运动的动画效果，例如，沿着圆形轨道运行，如下图所示。</p>
<p><img src="/images/2017-03-09/圆形轨道运行.PNG" alt=""></p>
<p>其实原理很简单：将一个形状放在圆周的边缘处（即周长上），以圆周的任意位置作为起点，在每次动画循环中，只需增加位于圆周上的形状的角度，就可以使形状沿着圆周运动。为简单起见，假设形状的起点位置总是周长上角度为0弧度的位置。我们可以使用三角函数来解决该问题，示意图如下：</p>
<p><img src="/images/2017-03-09/三角函数.PNG" alt=""></p>
<p>假设圆点坐标为<code>(0,0)</code>，圆的半径为<code>r</code>，形状相对起点位置移动的角度为<code>a</code>。则，根据三角函数:<code>x=r*Math.cos(a)</code>，<code>y=r*Math.sin(a)</code>。这里的<code>a</code>是角度值，由于JavaScript中使用的单位是弧度，因此在实际计算时还需要进行转换。</p>
<p>综上，如果想要对一个形状实现圆周运动，就需要保存圆的半径<code>r</code>、形状当前运动位置的角度值。又圆周运动的圆的坐标不一定是<code>(0,0)</code>，因此还需要保存圆点坐标<code>(x,y)</code>。用对象描述如下：</p>
<pre><code>var Shape = function (x,y,width,height) {
   this.x = x;
   this.y = y;
   this.width = width;
   this.height = height;

   this.radius = Math.random()*30;
   this.angle = 0;
};
</code></pre><p>其中，<code>(x,y)</code>表示的是形状做圆周运动时圆心的坐标，而不是形状的当前位置；<code>radius</code>表示半径；<code>angle</code>表示形状当前的角度值。</p>
<p>代码：</p>
<pre><code>//用对象来定义形状
var Shape = function (x,y,width,height) {
   this.x = x;
   this.y = y;
   this.width = width;
   this.height = height;

   this.radius = Math.random()*30;
   this.angle = 0;
};
//用数组保存要绘制的所有形状
var shapes = new Array();
for(var i=0;i&lt;10;i++){
   var x = Math.random()*250;
   var y = Math.random()*250;
   var width = height = Math.random()*50;
   shapes.push(new Shape(x,y,width,height));
}

function animate(){
   cxt.clearRect(0,0,canvasWidth,canvasHeight);  //清除
   //循环每个形状
   var shapesLength = shapes.length;
   for (var i = 0; i &lt; shapesLength; i++) {
       var tmpShape = shapes[i];
       //更新
       var x = tmpShape.x+(tmpShape.radius*Math.cos(tmpShape.angle*(Math.PI/180)));
       var y = tmpShape.y+(tmpShape.radius*Math.sin(tmpShape.angle*(Math.PI/180)));
       tmpShape.angle += 5;
       cxt.fillRect(x, y, tmpShape.width, tmpShape.height);  //绘制
   };
   if(ifPlay){
       setTimeout(animate,33);
   }
}
animate();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-09/圆周运动.PNG" alt=""></p>
<h2 id="反弹"><a href="#反弹" class="headerlink" title="反弹"></a>反弹</h2><p>在之前的实现中，都没有考虑画布边界的问题，因此如果形状位置超出了画布边界，就会消失在视野中。我们理想的情景是：当形状位置达到边界时，会反弹回来，即向反方向运动，这样形状就会在画布中来回运动了。实现起来也很简单，只需在每次更新形状时检查形状是否超过了画布的边界，如果已经到达边界处，则反向改变形状运动的方向，这样它就会反弹回来。</p>
<p>代码：</p>
<pre><code>//反弹
var Shape = function (x,y,width,height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;

    this.reverseX = true;
    this.reverseY = false;
};
//用数组保存要绘制的所有形状
var shapes = new Array();
for(var i=0;i&lt;10;i++){
    var x = Math.random()*250;
    var y = Math.random()*250;
    var width = height = Math.random()*50;
    shapes.push(new Shape(x,y,width,height));
}

function animate(){
    cxt.clearRect(0,0,canvasWidth,canvasHeight);
    //循环每个形状
    var shapesLength = shapes.length;
    for (var i = 0; i &lt; shapesLength; i++) {
        var tmpShape = shapes[i];
        //更新
        //检查
        if(!tmpShape.reverseX){
            tmpShape.x += 2;
        }else{
            tmpShape.x -= 2;
        }
        if(!tmpShape.reverseY){
            tmpShape.y += 2;
        }else{
            tmpShape.y -= 2;
        }
        cxt.fillRect(tmpShape.x, tmpShape.y, tmpShape.width, tmpShape.height);  //绘制
        //检查是否超出边界
        if(tmpShape.x&lt;0){
            tmpShape.reverseX = false;
        }else if(tmpShape.x+tmpShape.width&gt;canvasWidth){
            tmpShape.reverseX = true;
        }
        if(tmpShape.y&lt;0){
            tmpShape.reverseY = false;
        }else if(tmpShape.y+tmpShape.height&gt;canvasWidth){
            tmpShape.reverseY = true;
        }
    };
    if(ifPlay){
        setTimeout(animate,33);
    }
}
animate();
</code></pre><p>对象中增加了两个属性<code>reverseX</code>、<code>reverseY</code>分别用来表示是否需要反弹，<code>true</code>表示需要，则在更新形状时让其向反方向运动；<code>false</code>表示不需要，则在更新形状时正方向运动即可。在每次绘制完后，还需要根据当前形状的位置来检查是否到达画布的边界，并更新<code>reverseX</code>、<code>reverseY</code>的值。这样就实现了一个简单的反弹动画效果。</p>
<h2 id="实现高级动画"><a href="#实现高级动画" class="headerlink" title="实现高级动画"></a>实现高级动画</h2><p>我们可以通过物理知识把动画效果进一步提高，创建更加逼真和具有动态效果的动画。无论是使用速度、加速度这些简单概念，还是构建一个包含不同方向作用力的完善系统，通过学习物理学，我们才能真实而全面地展现动画效果。下面先介绍一些基本的物理概念。</p>
<ul>
<li>力： 力是作用于物体的推力或拉力，它是改变物体运动状态的原因。力是矢量，单位是牛顿（N）。</li>
<li>矢量：矢量是具有大小和方向的量。</li>
<li>质量：质量是一种阻碍物体在力的作用下加速的物理量，也用来衡量惯性。当力作用于物体时，质量将直接影响加速度的大小。质量的单位是千克。</li>
<li>重力：物体的质量受另一个物体引力的作用而产生的力称为重力。重力是物体存在重量的原因。</li>
<li>摩擦力：摩擦力是一种阻止一个物体沿着另一个物体表面运动的力。</li>
<li>速度：速度是指物体运动的方向和速率。它是一个矢量。</li>
<li>速率：指物体运动速度的大小，表示物体在一段时间内通过的距离。标量。</li>
<li>加速度：加速度是指物体的速度随时间变化的比值，矢量。</li>
</ul>
<p>当我们创建自然流畅的动画时，了解力对物体运动状态的影响非常有用，因此还需要了解一下牛顿运动定律。</p>
<ul>
<li>牛顿第一定律：任何一个物体在不受外力或受平衡力的作用时，总是保持静止状态或匀速直线运动状态，直到有作用在它上面的外力迫使它改变这种状态为止。</li>
<li>牛顿第二定律：物体的加速度跟物体所受的合外力成正比，跟物体的质量成反比，加速度的方向跟合外力的方向相同。<code>F=ma</code></li>
<li>牛顿第三定律：两个物体之间的作用力和反作用力，在同一直线上，大小相等，方向相反。</li>
</ul>
<p>以上就是一些基本的物理知识，下面将利用这些物理知识实现一个简单的动画效果：一个简单的太空场景，在太空深处有一个动态的小行星群，这里每个小行星的颜色是随机的。点击<code>Start</code>按钮，行星开始运动，点击<code>Stop</code>按钮，行星将会静止。</p>
<p>demo地址：<a href="/2017/03/10/实例demo之Canvas小动画/" title="实例demo之Canvas小动画">实例demo之Canvas小动画</a></p>
<p>关键代码：</p>
<pre><code>//定义形状
var Asteroid = function(x, y,radius,mass,vX,vY,aX,aY,red,green,blue){
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.mass = mass;

    this.vX = vX;
    this.vY = vY;
    this.aX = aX;
    this.aY = aY;

    //每个小球都有自己的颜色
    this.red = red;
    this.green = green;
    this.blue = blue;
};

//保存所有形状
var asteroids = new Array();
for(var i = 0;i&lt;20;i++){
    //圆点坐标
   var x = 20+(Math.random()*(canvasWidth-40));
   var y = 20+(Math.random()*(canvasHeight-40));
    var radius = 5+Math.random()*10; //半径
    var mass = radius/2;   //质量
   //速度
    var vX = Math.random()*4-2;
    var vY = Math.random()*4-2;
    var aX = 0;
    var aY = 0;
    //颜色
    var red = Math.floor(Math.random()*255);
    var green = Math.floor(Math.random()*255);
    var blue = Math.floor(Math.random()*255);
    asteroids.push(new Asteroid(x,y,radius,mass,vX,vY,aX,aY,red,green,blue));
}

function animate(){
    //清除
    cxt.clearRect(0,0,canvasWidth,canvasHeight);
    var red = Math.floor(Math.random()*255);
    //cxt.fillStyle = &quot;rgb(255,255,255)&quot;;
    //更新
    var asteroidsLength = asteroids.length;
    for(var i = 0; i &lt; asteroidsLength; i++){
        var tmpAsteroid = asteroids[i];
        cxt.fillStyle = &quot;rgb(&quot;+tmpAsteroid.red+&quot;,&quot;+tmpAsteroid.green+&quot;,&quot;+tmpAsteroid.blue+&quot;)&quot;;
       //检测是否和其他形状碰撞
        for(var j = i+1; j &lt; asteroidsLength; j++){
            var tmpAsteroidB = asteroids[j];
            var dX = tmpAsteroidB.x - tmpAsteroid.x;
            var dY = tmpAsteroidB.y - tmpAsteroid.y;
            var distance = Math.sqrt((dX*dX)+(dY*dY));
            if(distance &lt; tmpAsteroid.radius + tmpAsteroidB.radius){
                //将小球的碰撞转换为理想碰撞，并利用坐标旋转公式计算转换后的坐标和速度
                var angle = Math.atan2(dY, dX);    //旋转角度
                var sine = Math.sin(angle);
                var cosine = Math.cos(angle);
                var x = 0;
                var y = 0;
                var vX = tmpAsteroid.vX * cosine + tmpAsteroid.vY * sine;
                var vY = tmpAsteroid.vY * cosine - tmpAsteroid.vX * sine;

                var xB = dX * cosine + dY * sine;
                var yB = dY * cosine - dX * sine;
                var vXb = tmpAsteroidB.vX * cosine + tmpAsteroidB.vY * sine;
                var vYb = tmpAsteroidB.vY * cosine - tmpAsteroidB.vX * sine;

                //理想碰撞后改变速度和坐标
                //vX *= -1;
                //vXb *= -1;
                //能量守恒和动量守恒定律求解碰撞后的速度
                var vTotal = vX - vXb;
                vX = ((tmpAsteroid.mass - tmpAsteroidB.mass) * vX + 2 * tmpAsteroidB.mass * vXb) / (tmpAsteroid.mass + tmpAsteroidB.mass);
                vXb = vTotal + vX;
                xB = x + (tmpAsteroid.radius + tmpAsteroidB.radius);

                //在旋转回之前的位置
                tmpAsteroid.x = tmpAsteroid.x + (x * cosine - y * sine);
                tmpAsteroid.y = tmpAsteroid.y + (y * cosine + x * sine);
                tmpAsteroid.vX = vX * cosine - vY * sine;
                tmpAsteroid.vY = vY * cosine + vX * sine;

                tmpAsteroidB.x = tmpAsteroid.x + (xB * cosine - yB * sine);
                tmpAsteroidB.y = tmpAsteroid.y + (yB * cosine + xB * sine);
                tmpAsteroidB.vX = vXb * cosine - vYb * sine;
                tmpAsteroidB.vY = vYb * cosine + vXb * sine;
            }
        }
        //更新位置
        tmpAsteroid.x += tmpAsteroid.vX;
        tmpAsteroid.y += tmpAsteroid.vY;
        //根据加速度更新速度
        if (Math.abs(tmpAsteroid.vX) &lt; 10) {
          tmpAsteroid.vX += tmpAsteroid.aX;
        }
        if (Math.abs(tmpAsteroid.vY) &lt; 10) {
          tmpAsteroid.vY += tmpAsteroid.aY;
        }

        //检查是否到边界
       if (tmpAsteroid.x-tmpAsteroid.radius &lt; 0) {
          tmpAsteroid.x = tmpAsteroid.radius; // Move away from the edge
          tmpAsteroid.vX *= -1;
          tmpAsteroid.aX *= -1;
      } else if (tmpAsteroid.x+tmpAsteroid.radius &gt; canvasWidth) {
        tmpAsteroid.x = canvasWidth-tmpAsteroid.radius; // Move away from the edge
        tmpAsteroid.vX *= -1;
        tmpAsteroid.aX *= -1;
      };

      if (tmpAsteroid.y-tmpAsteroid.radius &lt; 0) {
        tmpAsteroid.y = tmpAsteroid.radius; // Move away from the edge
        tmpAsteroid.vY *= -1;
        tmpAsteroid.aY *= -1;
      } else if (tmpAsteroid.y+tmpAsteroid.radius &gt; canvasHeight) {
        tmpAsteroid.y = canvasHeight-tmpAsteroid.radius; // Move away from the edge
        tmpAsteroid.vY *= -1;
        tmpAsteroid.aY *= -1;
      };
        //绘制
        cxt.beginPath();
        cxt.arc(tmpAsteroid.x, tmpAsteroid.y, tmpAsteroid.radius, 0, Math.PI*2);
        cxt.closePath();
        cxt.fill();
    }

    if(ifPlay){
        setTimeout(animate,33);
    }
}
animate();
</code></pre><p><code>Asteroid</code>对象有11个属性：<code>(x,y)</code>是小行星的位置，<code>radius</code>是半径，<code>mass</code>是质量，<code>(vX,vY)</code>是速度，<code>(aX,aY)</code>是加速度，<code>(red,green,blue)</code>是颜色。在创建一个小行星时，这些参数的值是随机的，因此每个小行星都在不同的位置，有不同的大小、颜色、质量和速度。</p>
<p>其实该动画效果的难点在于小行星之间的碰撞检测。碰撞检测的两个关键步骤：第一，计算两颗小行星是否发生重叠；第二，在发生重叠时（即碰撞）以什么方式相互分离才显得更加逼真。检测重叠的方法很简单：检查两个圆心之间的距离是否小于这两个圆的半径之和。因此，难点在于怎样分离，即怎样弹开物体。</p>
<p>理想碰撞：两个圆发生碰撞时正好完全位于一条直线上，并且它们的中心点之间没有任何角度，此时只要反向改变速度的方向即可。如下图所示：</p>
<p><img src="/images/2017-03-10/正面碰撞.PNG" alt=""></p>
<p>但通常情况下，两个圆都会以一定角度发生碰撞，此时仅仅反向改变速度是行不通的，两个圆应该以正确的角度互相弹开。如下图所示：</p>
<p><img src="/images/2017-03-10/实际碰撞.PNG" alt=""></p>
<p>此时需要计算出两个圆之间的角度，并依次把每个圆的速度进行旋转，这样它们发生的碰撞就类似与上面提到的理想碰撞了，速度的状态转变如下图所示，这样圆的碰撞问题就转化成了一种简单的反向改变速度的问题。</p>
<p><img src="/images/2017-03-10/两圆角度.PNG" alt=""><br><img src="/images/2017-03-10/旋转两个圆.PNG" alt=""></p>
<p>对应的代码如下：</p>
<pre><code>var angle = Math.atan2(dY, dX);    //旋转角度
var sine = Math.sin(angle);
var cosine = Math.cos(angle);
var x = 0;
var y = 0;
var vX = tmpAsteroid.vX * cosine + tmpAsteroid.vY * sine;
var vY = tmpAsteroid.vY * cosine - tmpAsteroid.vX * sine;

var xB = dX * cosine + dY * sine;
var yB = dY * cosine - dX * sine;
var vXb = tmpAsteroidB.vX * cosine + tmpAsteroidB.vY * sine;
var vYb = tmpAsteroidB.vY * cosine - tmpAsteroidB.vX * sine;
</code></pre><p>这里用到了<a href="/2017/03/10/坐标旋转公式/" title="坐标旋转公式">坐标旋转公式</a></p>
<p>假设两个小行星发生的是完全弹性碰撞，则根据动量守恒和能量守恒公式可推导出碰撞后第一颗小行星的新速度为:</p>
<pre><code>vX = ((tmpAsteroid.mass - tmpAsteroidB.mass) * vX + 2 * tmpAsteroidB.mass * vXb) / (tmpAsteroid.mass + tmpAsteroidB.mass);
</code></pre><p>推到过程如下图所示：</p>
<p><img src="/images/2017-03-10/公式推导.PNG" alt=""></p>
<p>这样，碰撞后的速度和位置改变为：</p>
<pre><code>//能量守恒和动量守恒定律求解碰撞后的速度
var vTotal = vX - vXb;
vX = ((tmpAsteroid.mass - tmpAsteroidB.mass) * vX + 2 * tmpAsteroidB.mass * vXb) / (tmpAsteroid.mass + tmpAsteroidB.mass);
vXb = vTotal + vX;
xB = x + (tmpAsteroid.radius + tmpAsteroidB.radius);
</code></pre><p>最后需要把这些小行星旋转到它们原来所在的位置，并使用新的速度。代码与上面旋转小行星的代码基本相反：</p>
<pre><code>//在旋转回之前的位置
tmpAsteroid.x = tmpAsteroid.x + (x * cosine - y * sine);
tmpAsteroid.y = tmpAsteroid.y + (y * cosine + x * sine);
tmpAsteroid.vX = vX * cosine - vY * sine;
tmpAsteroid.vY = vY * cosine + vX * sine;

tmpAsteroidB.x = tmpAsteroid.x + (xB * cosine - yB * sine);
tmpAsteroidB.y = tmpAsteroid.y + (yB * cosine + xB * sine);
tmpAsteroidB.vX = vXb * cosine - vYb * sine;
tmpAsteroidB.vY = vYb * cosine + vXb * sine;
</code></pre><p>通过以上过程，解决了碰撞检测问题。这样，这个小动画就比较完美地实现了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Canvas学习（二）]]></title>
      <url>https://fantasticzhang.github.io/2017/03/08/Canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="处理图像"><a href="#处理图像" class="headerlink" title="处理图像"></a>处理图像</h2><h3 id="加载图像"><a href="#加载图像" class="headerlink" title="加载图像"></a>加载图像</h3><p><code>drawImage(image,x,y)</code>。参数<code>image</code>可以是HTML<code>img</code>元素、HTML5<code>canvas</code>元素或HTML5<code>video</code>元素。例：</p>
<pre><code>var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
  cxt.drawImage(img,0,0);
};
</code></pre><p>在使用以上方法图像到画布时，会将完整尺寸的图像绘制到画布上，但超过画布边界的部分会被裁减掉。</p>
<h3 id="调整和裁剪图像"><a href="#调整和裁剪图像" class="headerlink" title="调整和裁剪图像"></a>调整和裁剪图像</h3><p><code>drawImage</code>方法还有两种调用方式：第一种调用可以调整图像大小，第二种调用可以同时调整和裁剪图像。<code>drawImage</code>的所有调用方式的唯一区别是所使用参数的个数和类型不同。</p>
<h4 id="调整图像"><a href="#调整图像" class="headerlink" title="调整图像"></a>调整图像</h4><p><code>drawImage(image,x,y,width,height)</code>,其中<code>width</code>和<code>height</code>表示希望绘制的图像宽度和高度。我们可以根据画布的宽高来等比例计算图像的宽高。</p>
<h4 id="裁剪图像"><a href="#裁剪图像" class="headerlink" title="裁剪图像"></a>裁剪图像</h4><p><code>drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)</code>，共9个参数：源图像、源图像的裁剪区原点坐标<code>(x,y)</code>、源图像的裁剪区宽和高、在画布上绘制图像的原点坐标<code>(x,y)</code>、在画布上绘制图像的宽和高。示意图如下：</p>
<p><img src="/images/2017-03-08/裁剪图像.PNG" alt=""></p>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>代码：</p>
<pre><code>cxt.shadowBlur = 30;
cxt.shadowColor = &quot;rgb(0,0,0)&quot;;
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
     cxt.drawImage(img,100,100,375,500);
};
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/图像阴影.PNG" alt=""></p>
<h3 id="图像变形"><a href="#图像变形" class="headerlink" title="图像变形"></a>图像变形</h3><p>在画布中绘制图像后，就可以对它执行所有的2D渲染上下文方法。因此可以使用<code>translate</code>、<code>rotate</code>、<code>scale</code>等方法对图像进行旋转、平移、缩放与翻转等。注，如果<code>scale</code>方法使用负数缩放因子，就会使图像反转。</p>
<p>实例：</p>
<pre><code>cxt.shadowBlur = 30;
cxt.shadowColor = &quot;rgb(0,0,0)&quot;;
cxt.rotate(Math.PI/4);
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
    cxt.drawImage(img,100,100,375,500);
};
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/img-rotate.PNG" alt=""></p>
<h3 id="访问像素值"><a href="#访问像素值" class="headerlink" title="访问像素值"></a>访问像素值</h3><p><code>getImageData(x,y,width,height)</code>方法，该方法有4个参数：要访问的像素区域原点坐标<code>(x,y)</code>、像素区域的宽度和高度。调用该方法会返回一个2D渲染上下文<code>ImageData</code>对象，该对象包含3个属性：<code>width</code>表示所访问像素区域的宽度、<code>height</code>表示像素区域的高度、<code>data</code>是一个包含所访问区域中全部像素信息的<code>CanvasPixelArray</code>。</p>
<p><code>data</code>属性存储的是一个<code>CanvasPixelArray</code>，它是一个JavaScript一维数组。每一个像素用4个整数值表示，范围从0至255，分别表示红(r)、绿(g)、蓝(b)和阿尔法值(a)。因此，，数组的前4项（0~3）是第一个像素的颜色值，接下来4项(4~7)是第二个像素的颜色值，以此类推。因此，该数组的长度是所访问区域的像素个数乘以4。<code>CanvasPixelArray</code>中的像素排列顺序：左上角像素位于数组开头，右下角像素位于数组末尾。即在所访问的区域中，每一行像素时从左到右访问的，直至行尾，然后再同样从左到右访问下一行。</p>
<p>访问<code>(x,y)</code>坐标位置为<code>(2,2)</code>的中心像素：</p>
<pre><code>var imgData = cxt.getImageData(0, 0, 3, 3); // 3x3 grid
var width = imgData.width;
var pixelRed = (y-1)*(width*4)+((x-1)*4);
var pixelGreen = pixelRed+1;
var pixelBlue = pixelRed+2;
var pixelAlpha= pixelRed+3;
</code></pre><p>使用如上公式可准确地计算出你需要从<code>CanvasPixelArray</code>中访问的像素。</p>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>代码：</p>
<pre><code>var imageData = cxt.createImageData(width,height)(创建一个200,200);
var pixels = imageData.data;
var numPixels = imageData.width * imageData.height;
for(var i = 0; i&lt; numPixels; i++){
    pixels[i*4] = 0;   //红
    pixels[i*4+1] = 0; //绿
    pixels[i*4+2] = 255; //蓝
    pixels[i*4+3] = 255;//透明度
}
cxt.putImageData(imageData,0,0);
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/创建和绘制像素.PNG" alt=""></p>
<p>其中，<code>createImageData(width,height)</code>方法返回一个包含所有常规属性的<code>ImageData</code>对象；<code>putImageData</code>方法可将<code>ImageData</code>对象画到画布上，该方法可接受3个或7个参数：<code>ImageData</code>对象、绘制像素数据的原点坐标<code>(x,y)</code>、脏矩阵的原点坐标<code>(x,y)</code>、脏矩阵的宽和高。</p>
<h4 id="随机绘制像素"><a href="#随机绘制像素" class="headerlink" title="随机绘制像素"></a>随机绘制像素</h4><p>代码片段：</p>
<pre><code>pixels[i*4] = Math.floor(Math.random()*255);   //红
pixels[i*4+1] = Math.floor(Math.random()*255); ; //绿
pixels[i*4+2] = Math.floor(Math.random()*255); ; //蓝
pixels[i*4+3] = 255;//透明度
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/随机像素.PNG" alt=""></p>
<h4 id="创建马赛克效果"><a href="#创建马赛克效果" class="headerlink" title="创建马赛克效果"></a>创建马赛克效果</h4><p>原理：将像素区域分割到一个栅格中，并为栅格中的每个块儿（马赛克块）随机设置一种颜色。</p>
<p>代码：</p>
<pre><code>//马赛克
var imageData = cxt.createImageData(canvas.width(),canvas.height());
var pixels = imageData.data;
//马赛克块的个数
var numTileRows = 20;
var numTileCols = 20;
//每个块的尺寸
var tileWidth = imageData.width/numTileCols;
var tileHeight = imageData.height/numTileRows;
for(var r = 0; r&lt; numTileRows; r++){
    for(var c = 0;c&lt;numTileCols;c++){
        var red = Math.floor(Math.random()*255);   //红
        var green = Math.floor(Math.random()*255); //绿
        var blue = Math.floor(Math.random()*255);  //蓝
        for(var tr = 0;tr&lt;tileWidth;tr++){
            for(var tc = 0;tc&lt;tileHeight;tc++){
                var trueX = (c*tileWidth)+tc;
                var trueY = (r*tileHeight)+tr;
                var pos = (trueY*(imageData.width*4))+(trueX*4);
                pixels[pos] = red; //绿
                pixels[pos+1] = green; //绿
                pixels[pos+2] = blue; //蓝
                pixels[pos+3] = 255;//透明度
            }
        }
   }
}
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/马赛克.PNG" alt=""></p>
<h3 id="基本图像效果"><a href="#基本图像效果" class="headerlink" title="基本图像效果"></a>基本图像效果</h3><h4 id="反转图像"><a href="#反转图像" class="headerlink" title="反转图像"></a>反转图像</h4><p>即用255减去像素现在的颜色值。</p>
<p>代码：</p>
<pre><code>//反转颜色
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
   cxt.drawImage(img,0,0,1080,1440,0,0,canvas.width(),canvas.height());
   var imgData = cxt.getImageData(0,0,canvas.width(),canvas.height());
   var pixels = imgData.data;
   var numPixels = imgData.width * imgData.height;
   cxt.clearRect(0,0,canvas.width(),canvas.height());
   for(var i = 0; i&lt; numPixels; i++){
       pixels[i*4] = 255 - pixels[i*4];   //红
       pixels[i*4+1] = 255 - pixels[i*4+1]; //绿
       pixels[i*4+2] = 255 - pixels[i*4+2]; //蓝
   }
   cxt.putImageData(imgData,0,0);
};
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/反转颜色.PNG" alt=""></p>
<h4 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h4><p>方法：计算每个像素现有颜色值的平均值，并将该平均颜色作为相应像素三种颜色（红、绿和蓝）的值。</p>
<p>代码：</p>
<pre><code>for(var i = 0; i&lt; numPixels; i++){
    var avg = (pixels[i*4]+pixels[i*4+1]+pixels[i*4+2])/3;
    pixels[i*4] = avg;   //红
    pixels[i*4+1] = avg; //绿
    pixels[i*4+2] = avg; //蓝
}
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/灰度.PNG" alt=""></p>
<h4 id="像素化"><a href="#像素化" class="headerlink" title="像素化"></a>像素化</h4><p>和上面马赛克的励志类似，就是将图像按栅格分割，或者对每块儿的颜色取平均值，或者选取每块儿的颜色。</p>
<p>例：</p>
<pre><code>//像素
var img = new Image();
img.src = &quot;wen.jpg&quot;;
img.onload = function(){
    cxt.drawImage(img,0,0,1080,1440,0,0,500,500);
    var imgData = cxt.getImageData(0,0,canvas.width(),canvas.height());
    var pixels = imgData.data;
    cxt.clearRect(0,0,canvas.width(),canvas.height());
    //马赛克块数
    var numTileRows = 50;
    var numTileCols = 50;
    //每个块的尺寸
    var tileWidth = imgData.width/numTileCols;
    var tileHeight = imgData.height/numTileRows;
    for(var r = 0; r&lt; numTileRows; r++){
        for(var c = 0;c&lt;numTileCols;c++){
            //每块中心点
            var x = (c*tileWidth)+(tileWidth/2);
            var y = (r*tileHeight)+(tileHeight/2);
            var pos = (Math.floor(y)*(imgData.width*4))+(Math.floor(x)*4);
            var red = pixels[pos];   //红
            var green = pixels[pos+1]; //绿
            var blue = pixels[pos+2];  //蓝
            cxt.fillStyle = &quot;rgb(&quot;+red+&quot;, &quot;+green+&quot;, &quot;+blue+&quot;)&quot;;
            cxt.fillRect(x-(tileWidth/2),y-(tileHeight/2),tileWidth,tileHeight);
        }

    }
    };
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/像素化.PNG" alt=""></p>
<p>圆形马赛克：</p>
<pre><code>cxt.beginPath();
cxt.arc(x,y,tileWidth/2,0,Math.PI*2,false);
cxt.closePath();
cxt.fill();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/像素化2.PNG" alt=""></p>
<h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><p><code>drawImage</code>方法可以接受一个HTML5<code>video</code>元素作为输入，在画布中的视频处理与图像处理几乎完全一样。</p>
<p>实例：</p>
<pre><code>//html代码
&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;281&quot;&gt;
    &lt;video id=&quot;myVideo&quot; src=&quot;Crooked.mp4&quot; controls  width=&quot;500&quot; height=&quot;281&quot;&gt;&lt;/video&gt;
&lt;/canvas&gt;
&lt;div&gt;
    &lt;button id=&quot;play&quot;&gt;Play&lt;/button&gt;
    &lt;button id=&quot;stop&quot;&gt;Stop&lt;/button&gt;
&lt;/div&gt;

//js代码：
var canvas = $(&quot;#myCanvas&quot;);
var cxt = canvas.get(0).getContext(&quot;2d&quot;);
var video = $(&quot;#myVideo&quot;);
// Trigger for video play button
$(&quot;#play&quot;).click(function() {
 video.get(0).play();
});

// Trigger for video stop button
$(&quot;#stop&quot;).click(function() {
 video.get(0).pause();
});

video.bind(&apos;play&apos;, function () {
 dravCanvas();
});

function  dravCanvas(){
  if(video.get(0).paused || video.get(0).ended) return;
  cxt.drawImage(video.get(0),0,0,500,281);
  var imgData = cxt.getImageData(0,0,canvas.width(),canvas.height());
    var pixels = imgData.data;
    cxt.clearRect(0,0,canvas.width(),canvas.height());
    //马赛克块数
    var numTileRows = 36;
    var numTileCols = 64;
    //每个块的尺寸
    var tileWidth = imgData.width/numTileCols;
    var tileHeight = imgData.height/numTileRows;
    for(var r = 0; r&lt; numTileRows; r++){
        for(var c = 0;c&lt;numTileCols;c++){
            //每块中心点
            var x = (c*tileWidth)+(tileWidth/2);
            var y = (r*tileHeight)+(tileHeight/2);
            var pos = (Math.floor(y)*(imgData.width*4))+(Math.floor(x)*4);
            var red = pixels[pos];   //红
            var green = pixels[pos+1]; //绿
            var blue = pixels[pos+2];  //蓝
            cxt.fillStyle = &quot;rgb(&quot;+red+&quot;, &quot;+green+&quot;, &quot;+blue+&quot;)&quot;;
            cxt.fillRect(x-(tileWidth/2),y-(tileHeight/2),tileWidth,tileHeight);
        }
    }
 setTimeout(dravCanvas,30);
}
</code></pre><p>效果截图：</p>
<p><img src="/images/2017-03-08/像素化video.PNG" alt=""></p>
<p>其中，<code>play</code>和<code>pause</code>方法都属于<code>video</code>DOM对象，用于开始和停止视频。</p>
<p>我们通过<code>bind</code>方法创建了一个回调函数，通过监听<code>play</code>事件实现在视频开始播放时运行回调函数，回调函数将调用自定义函数<code>dravCanvas</code>，该函数包含所有创建像素化效果和绘制画布内容的功能。通过在<code>dravCanvas</code>函数末尾添加一个<code>setTimeout</code>调用，与视频的帧播放速度同步重复调用这个方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Canvas学习（一）]]></title>
      <url>https://fantasticzhang.github.io/2017/03/08/Canvas%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>HTML5 <code>&lt;canvas&gt;</code>元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成。<code>&lt;canvas&gt;</code>标签只是图形容器，必须使用脚本来绘制图形。</p>
<h3 id="创建一个画布（canvas）"><a href="#创建一个画布（canvas）" class="headerlink" title="创建一个画布（canvas）"></a>创建一个画布（canvas）</h3><p>一个画布在网页中是一个矩形框，通过 <code>&lt;canvas&gt;</code> 元素来绘制。</p>
<pre><code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;
style=&quot;border:1px solid #000000;&quot;&gt;
&lt;/canvas&gt;
</code></pre><p>  如果不设置canvas元素的尺寸，那么2D渲染上下文会被设置为使用默认宽度和高度，分别是300和150像素。</p>
<h3 id="使用JavaScript来绘制图像"><a href="#使用JavaScript来绘制图像" class="headerlink" title="使用JavaScript来绘制图像"></a>使用JavaScript来绘制图像</h3><p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：</p>
<pre><code>&lt;script&gt;
    var canvas = document.getElementById(&apos;myCanvas&apos;);
    if(canvas &amp;&amp; canvas.getContext){
        var cxt = canvas.getContext(&apos;2d&apos;);
      //线性渐变
        var grd = cxt.createLinearGradient(0,0,200,0);
        grd.addColorStop(0,&quot;blue&quot;);
        grd.addColorStop(1,&quot;pink&quot;);
        //矩形
         cxt.fillStyle = grd;
        cxt.fillRect(0,0,150,75);

    }
&lt;/script&gt;
</code></pre><p><code>getContext(&quot;2d&quot;)</code>返回的对象是浏览器内建的<code>CanvasRenderingContext2D</code>对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。绘图功能是通过该对象实现的。</p>
<p>因此，canvas元素并非Canvas中最强大的部分，真正的关键部分是2D渲染上下文，这是我们真正绘制图形的地方。canvas元素的用途只是作为2D渲染上下文的包装器，它包含绘图和图形操作所需要的全部方法和丰富功能。坐标系统的1个单位通常相当于屏幕的1个像素。</p>
<h3 id="Canvas坐标"><a href="#Canvas坐标" class="headerlink" title="Canvas坐标"></a>Canvas坐标</h3><p>canvas元素是一张画布，这张画布的原点在元素的左上角，水平的是x轴，竖直的是y轴。沿原点向右、向下是正值，向左、向上是负值。</p>
<h3 id="绘制基本图形和线条"><a href="#绘制基本图形和线条" class="headerlink" title="绘制基本图形和线条"></a>绘制基本图形和线条</h3><h4 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h4><pre><code>var canvas = document.getElementById(&apos;myCanvas&apos;);
var cxt = canvas.getContext(&apos;2d&apos;);
cxt.beginPath(); //开始路径
cxt.moveTo(40.40); //设置路径原点
cxt.lineTo(340,40); //设置路径终点
cxt.closePath(); //结束路径
cxt.stroke(); //绘出路径轮廓
</code></pre><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><pre><code>//fillRect(x, y, width, height)
cxt.fillStyle = &quot;#FF0000&quot;; //设置颜色
cxt.fillRect(40, 40, 100, 100); // 绘制一个矩形并给它填充颜色
cxt.strokeRect(200, 300, 200, 100); // 绘制一个矩形并给它绘制边框
</code></pre><p><code>fillRect(x, y, width, height)</code>中，<code>x</code>、<code>y</code>用来指定矩形左上角顶点的坐标；<code>width</code>指定矩形的宽；<code>height</code>指定矩形的高。</p>
<h4 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h4><pre><code>context.beginPath(); // 开始路径
context.arc(230, 90, 50, 0, Math.PI*2, false); // 绘制一个圆形
context.closePath(); // 结束路径
context.fill(); // 填充路径
</code></pre><p><code>arc(x, y, r, startAngle, endAngle, anticlockwise)</code>中，<code>x</code>、<code>y</code>指定圆点坐标；<code>r</code>指定半径；<code>startAngle</code>、 <code>endAngle</code>指定开始角度和结束角度；<code>anticlockwise</code>指定弧线的绘制方向，该参数可选，但是如果不传入这个参数Firefox会抛出一个错误，因此最好保留这个参数。</p>
<p>在Canvas中，一条弧线是由一条曲线定义的，它从与原点<code>(x,y)</code>距离为一个半径且角度为开始角度的位置开始，这条路径最后停在离原点<code>(x,y)</code>一个半径且角度为结束角度的位置上。此外，Canvas中的角度是以弧度而不是角度为单位的。简单地说，360度（一个完整的圆）是2π（<code>PI</code>的2倍）弧度。</p>
<p><img src="/images/2017-03-08/绘制圆弧.PNG" alt=""></p>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><pre><code>cxt.fillStyle = &quot;#FF0000&quot;; //指定填充颜色
cxt.strokeStyle = &quot;rgb(255, 0, 0)&quot;; //指定描边颜色
cxt.lineWidth = 5; // 指定线宽
</code></pre><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><pre><code>var text = &quot;Hello, World!&quot;; // 要绘制的文字
cxt.font = &quot;italic 30px serif&quot;;// 修改字号和字体 并设置为斜体
cxt.fillText(text, 40, 40); // 绘制文字
cxt.strokeText(text, 80, 80); // 绘制描边文字
</code></pre><p><code>strokeText(text, x, y)</code>中，<code>text</code>是准备绘制的文字，<code>(x,y)</code>是文本原点（左下角）的坐标值。</p>
<p>由于Canvas中的文本是以图形形式绘制的，因此它无法像HTML文档中的普通文字那样用鼠标指针选取——它实际上不是文本，只是像文本而已。</p>
<h3 id="擦除Canvas"><a href="#擦除Canvas" class="headerlink" title="擦除Canvas"></a>擦除Canvas</h3><h4 id="clearReact方法"><a href="#clearReact方法" class="headerlink" title="clearReact方法"></a>clearReact方法</h4><p><code>clearReact(x,y,width,height)</code>中<code>x</code>、<code>y</code>用来指定矩形左上角顶点的坐标；<code>width</code>指定矩形的宽；<code>height</code>指定矩形的高。该矩形区域就是要擦除的区域。使用该方法只会清除指定区域，并不会完全重置Canvas上的所有内容（例如：样式、颜色等会保留）。</p>
<h4 id="宽度-高度技巧"><a href="#宽度-高度技巧" class="headerlink" title="宽度/高度技巧"></a>宽度/高度技巧</h4><p>每当重新设置一个canvas元素的width和height属性时，Canvas都会自动清除内容并返回其原始状态。</p>
<pre><code>var canvas = $(&quot;#myCanvas&quot;);
var context = canvas.get(0).getContext(&quot;2d&quot;);
context.fillStyle = &quot;rgb(255, 0, 0)&quot;;
context.fillRect(40, 40, 100, 100);

context.beginPath();
context.arc(230, 90, 50, 0, Math.PI*2, false);
context.closePath();
context.fill();

canvas.attr(&quot;width&quot;, canvas.width());
canvas.attr(&quot;height&quot;, canvas.height());

context.fillRect(40, 40, 100, 100);
</code></pre><p>该技巧的缺点是，它会完全重置Canvas上的所有内容，包括样式和颜色。所以，只有准备完全重置Canvas时才能使用该方法。</p>
<h3 id="使Canvas填满浏览器窗口"><a href="#使Canvas填满浏览器窗口" class="headerlink" title="使Canvas填满浏览器窗口"></a>使Canvas填满浏览器窗口</h3><p>代码如下：</p>
<pre><code>//HTML
&lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;
    &lt;!-- Insert fallback content here --&gt;
&lt;/canvas&gt;

//js
$(document).ready(function() {
    var canvas = $(&quot;#myCanvas&quot;);
    var context = canvas.get(0).getContext(&quot;2d&quot;);

    $(window).resize(resizeCanvas);

    function resizeCanvas() {
        canvas.attr(&quot;width&quot;, $(window).get(0).innerWidth);
        canvas.attr(&quot;height&quot;, $(window).get(0).innerHeight);
        context.fillRect(0, 0, canvas.width(), canvas.height());
    };

    resizeCanvas();
});

//css
* { margin: 0; padding: 0; }
html, body { height: 100%; width: 100%; }
canvas { display: block; }
</code></pre><h2 id="Canvas高级功能"><a href="#Canvas高级功能" class="headerlink" title="Canvas高级功能"></a>Canvas高级功能</h2><h3 id="保存和恢复画布状态"><a href="#保存和恢复画布状态" class="headerlink" title="保存和恢复画布状态"></a>保存和恢复画布状态</h3><p>在画布中，绘图状态指的是描述某一时刻2D渲染上下文外观的整套属性。用于描述画布绘图状态的全部属性为：变换矩阵、裁剪区域（cliping region）、globalAlpha、globalCompositeOperation、strokeStyle、fillStyle、lineWidth、lineCap、lineJoin、miterLimit、shadowOffsetX、shadowOffsetY、shadowBlur、shadowColor、font、textAlign、textBaseline。</p>
<p>注：画布上的当前路径和当前位图（正在显示的内容）并不属于状态。</p>
<p>保存绘图状态：<code>save</code>方法。</p>
<pre><code>var cxt = canvas.getContext(&apos;2d&apos;);
cxt.fillRect(0,0,150,150);
cxt.save();
</code></pre><p>恢复绘图状态：<code>restore</code>方法。</p>
<pre><code>var cxt = canvas.getContext(&apos;2d&apos;);
cxt.fillRect(0,0,150,150);
cxt.save();
cxt.fillStyle=&quot;blue&quot;;
cxt.fillRect(100,100,100,100);
cxt.restore();
cxt.fillRect(150,150,150,150);
</code></pre><p>2D渲染上下文会保存一个绘图状态栈，默认栈是空的。每调用一次<code>save</code>方法，就会有一个新状态添加到这个栈；每调用一次<code>restore</code>方法，就会取出最后添加到栈中的绘图状态，并将它应用于2D渲染上下文，用所保存的状态覆盖全部现有的样式。</p>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>即将2D渲染上下文的原点从一个位置移动到另一个位置。使用<code>translate</code>方法。<code>(x,y)</code>参数是移动后2D渲染上下文的坐标原点。</p>
<pre><code>cxt.translate(150.150);
</code></pre><p>注：该方法实际移动的是2D渲染上下文的坐标原点，而不是所绘制的对象，也不是<code>canvas</code>元素。移动后，再绘制新的对象时都会相对于新的2D渲染上下文的坐标原点，但移动之前所绘制的对象保持不变。</p>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>即调整2D渲染上下文的尺寸，使用<code>scale</code>方法。<code>(x,y)</code>参数是缩放倍数。</p>
<pre><code>cxt.scale(2,2);
</code></pre><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>使用<code>rotate</code>方法，参数为以弧度为单位的2D渲染上下文旋转角度值。</p>
<p>cxt.rotate(Math.PI/4); // 旋转45度</p>
<p><code>rotate</code>方法是把2D渲染上下文绕其原点进行旋转的。</p>
<h4 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h4><p>变换矩阵是一组数字。它们各自描述一个特定变形类型。矩阵分成多个列和行，在画布中使用的是一个3*3矩阵，如下图所示。</p>
<p><img src="/images/2017-03-08/2D渲染上下文的变化矩阵.PNG" alt=""></p>
<p>重要的是前两行，其中包含的数字值对应画布中使用的<code>a</code>至<code>f</code>。一个新的2D渲染上下文将包含一个全新的变换矩阵，即单位矩阵：</p>
<p><img src="/images/2017-03-08/单位矩阵.PNG" alt=""></p>
<p>操作变换矩阵的方法是<code>transform</code>和<code>setTransform</code>。<code>transform</code>方法有6个参数，分别对应变换矩阵中的每一个值，第一个表示<code>a</code>,最后一个表示<code>f</code>；<code>setTransform</code>方法的作用是将矩阵重置为单位矩阵。</p>
<pre><code>cxt.setTransform(1, 0, 0, 1, 0, 0); // Identity matrix
var xScale = Math.cos(0.7854);
var ySkew = -Math.sin(0.7854);
var xSkew = Math.sin(0.7854);
var yScale = Math.cos(0.7854);
var xTrans = 200;
var yTrans = 200;
cxt.transform(xScale, ySkew, xSkew, yScale, xTrans, yTrans);
cxt.fillRect(-50, -50, 100, 100);
</code></pre><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>在画布上绘制的所有东西是已经合成的，这意味着绘制的所有内容都会与已经绘制的现有元素合并在一起。这实际上都是基本合成，只是将一些内容叠加到另一些内容之上。下面是两个全局合成属性，因为是全局的，所以在修改这两个属性会影响到修改之后所绘制的全部内容。</p>
<h4 id="globalAlpha"><a href="#globalAlpha" class="headerlink" title="globalAlpha"></a>globalAlpha</h4><p>该属性的取值在<code>0.0</code>(全透明)与<code>1.0</code>(不透明)之间，默认值是1.0。即<code>globalAlpha</code>属性会影响到将要绘制的对象的透明度。</p>
<pre><code>cxt.fillStyle = &quot;rgb(63, 169, 245)&quot;;
cxt.fillRect(50, 50, 100, 100);
cxt.globalAlpha = 0.5;
cxt.fillStyle = &quot;rgb(255, 123, 172)&quot;;
cxt.fillRect(100, 100, 100, 100);
</code></pre><h4 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h4><p>该属性定义了对2D渲染上下文上所有绘制图形执行的合成类型，所谓合成，即一个图形叠加到另一个图形之上。<code>globalCompositeOperation</code>的默认值是<code>source-over</code>(源覆盖于目标之上)，源是绘制的新图形，而目标则是可能已经绘制了图形的2D渲染上下文。</p>
<p><code>globalCompositeOperation</code>支持11种选择：</p>
<ul>
<li><code>source-over</code>：源覆盖于目标之上</li>
<li><code>destination-over</code>：目标覆盖于源之上</li>
<li><code>source-atop</code>：源覆盖于目标之上，重叠区域二者都不透明，重叠区域之外的目标不透明，源透明</li>
<li><code>destination-atop</code>：目标覆盖于源之上，重叠区域二者都不透明，重叠区域之外的源不透明，目标透明</li>
<li><code>source-in</code>：在源与目标重叠的区域只绘制源，而不重叠的部分都变成透明的</li>
<li><code>destination-in</code>：在源与目标重叠的区域只绘制目标，而不重叠的部分都变成透明的</li>
<li><code>source-out</code>：在源与目标不重叠的区域只绘制源，其他部分都变成透明的</li>
<li><code>destination-out</code>：在源与目标不重叠的区域只绘制目标，其他部分都变成透明的</li>
<li><code>lighter</code>：源与目标的重叠区域两者的颜色值相加</li>
<li><code>copy</code>：只绘制源，覆盖掉目标</li>
<li><p><code>xor</code>：只绘制不重叠的源与目标区域，重叠的部分变成透明</p>
<p>  cxt.fillStyle = “rgb(63,169,245)”;<br>  cxt.fillRect(50,50,100,100);<br>  cxt.globalCompositeOperation = “xor”;<br>  cxt.fillStyle = “rgb(255,123,172)”;<br>  cxt.fillRect(100,100,100,100);</p>
</li>
</ul>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>通过4个全局属性进行控制：<code>shadowBlur</code>、<code>shadowColor</code>、<code>shadowOffsetX</code>、<code>shadowOffsetY</code></p>
<pre><code>cxt.shadowBlur = 0;
cxt.shadowOffsetX = 10;
cxt.shadowOffsetY = 10;
cxt.shadowColor = &quot;rgba(100,100,100,0.5)&quot;;
cxt.fillRect(50,50,100,100);
</code></pre><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p><code>fillStyle</code>和<code>strokeStyle</code>都可以接受以<code>CanvasGradient</code>对象表示的渐变颜色的值。画布支持两种类型的渐变：线性渐变(<code>createLinearGradient</code>)和放射渐变（<code>createRadialGradient</code>）。这两种方法都返回一个<code>CanvasGradient</code>对象，可以使用该对象本身的<code>addColorStop</code>方法对它进行进一步处理。</p>
<p>线性渐变：</p>
<pre><code>var gradient = cxt.createLinearGradient(0, 0, 0, canvas.height);
gradient.addColorStop(0, &quot;rgb(0, 0, 0)&quot;);
gradient.addColorStop(1, &quot;rgb(255, 255, 255)&quot;);
cxt.fillStyle = gradient;
cxt.fillRect(0, 0, canvas.width, canvas.height);
</code></pre><p><code>createRadialGradient</code>方法有4个参数：渐变起点的<code>(x,y)</code>坐标和渐变终点的<code>(x,y)</code>坐标。</p>
<p>放射渐变：</p>
<pre><code>var gradient = cxt.createRadialGradient(300,300,10,100,100,50);
gradient.addColorStop(0,&quot;rgb(0,0,0)&quot;);
gradient.addColorStop(1,&quot;rgb(150,150,150&quot;);
cxt.fillStyle = gradient;
cxt.fillRect(0,0,canvas.width,canvas.height);
</code></pre><p><code>createRadialGradient</code>方法有6个参数：前3个参数描述一个圆（开始圆），后3个参数描述另一个圆（结束圆）。这两个圆本身不仅描述了方向及渐变的起止位置，而且还描述了渐变的形状。实际的渐变效果是连接两个圆的椎体，其中开始圆之前的椎体部分显示偏移值为0的颜色，而结束圆之后的椎体部分则显示偏移值为1的颜色，如下图所示：</p>
<p><img src="/images/2017-03-08/放射渐变工作原理.PNG" alt=""></p>
<p>因此，如果将开始圆和结束圆放置在同一个位置，就可以得到我们想要的放射渐变效果。</p>
<h3 id="复杂路径"><a href="#复杂路径" class="headerlink" title="复杂路径"></a>复杂路径</h3><pre><code>cxt.beginPath();
cxt.moveTo(100, 50);
cxt.lineTo(150, 150);
cxt.lineTo(50, 150);
cxt.closePath();
cxt.stroke();
cxt.fill();
</code></pre><p>以上代码可以绘制一个三角形，效果如下：</p>
<p><img src="/images/2017-03-08/绘制三角形.PNG" alt=""></p>
<p>其中，<code>moveTo</code>方法会创建一条全新的子路径；<code>lineTo</code>方法只是沿着一条已有的子路径继续画线,每次调用都是从子路径的最后一个坐标开始画线；<code>closePath</code>方法会画一条线连接子路径的最后一个点和第一个点——封闭路径。</p>
<h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>两个方法：<code>quadraticCurveTo(cpx,cpy,x,y)</code>(二次贝塞尔曲线)和<code>bezierCurveTo(cpx1,cpy1,cpx2,cpy2,x,y)</code>(三次贝塞尔曲线)，构造如下：</p>
<p><img src="/images/2017-03-08/贝塞尔曲线.PNG" alt=""></p>
<p>实例1：</p>
<pre><code>cxt.lineWidth = 5;
cxt.beginPath();
cxt.moveTo(50,250);
cxt.quadraticCurveTo(250,100,450,250);
cxt.stroke();
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/quadraticCurveTo.PNG" alt=""></p>
<p>实例2：</p>
<pre><code>cxt.lineWidth = 5;
cxt.beginPath();
cxt.moveTo(50,250);
cxt.bezierCurveTo(150,50,350,450,450,250);
cxt.stroke();
cxt.bezierCurveTo(150,50,350,450,450,250);
</code></pre><p>效果：</p>
<p><img src="/images/2017-03-08/bezierCurveTo.PNG" alt=""></p>
<h3 id="将画布导出为图像"><a href="#将画布导出为图像" class="headerlink" title="将画布导出为图像"></a>将画布导出为图像</h3><p>画布有一个<code>toDataURL</code>方法，可以将画布绘图转换为一个数据URL，我们可以通过它在浏览器上显示一个图像。</p>
<pre><code>cxt.save();
cxt.fillRect(50,50,100,100);
cxt.fillStyle = &quot;rgb(255,0,0)&quot;;
cxt.fillRect(100,100,100,100);
cxt.restore();
cxt.fillRect(150,150,100,100);
var dataURL = canvas.toDataURL();
console.log(dataURL);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[纯CSS绘制各种角度的三角形]]></title>
      <url>https://fantasticzhang.github.io/2017/02/23/%E7%BA%AFCSS%E7%BB%98%E5%88%B6%E5%90%84%E7%A7%8D%E8%A7%92%E5%BA%A6%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      <content type="html"><![CDATA[<p>以下是纯CSS绘制各种角度的三角形的方法。</p>
<h2 id="Triangle-Up"><a href="#Triangle-Up" class="headerlink" title="Triangle Up"></a>Triangle Up</h2><p>代码：</p>
<pre><code>#triangle-up{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-left:40px solid transparent;
    border-right:40px solid transparent;
}

&lt;h3&gt;Triangle Up&lt;/h3&gt;
&lt;div id=&quot;triangle-up&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-up.PNG" alt=""></p>
<h2 id="Triangle-Down"><a href="#Triangle-Down" class="headerlink" title="Triangle Down"></a>Triangle Down</h2><p>代码：</p>
<pre><code>#triangle-bottom{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-left:40px solid transparent;
    border-right:40px solid transparent;
}

&lt;h3&gt;Triangle Down&lt;/h3&gt;
&lt;div id=&quot;triangle-bottom&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottom.PNG" alt=""></p>
<h2 id="Triangle-Left"><a href="#Triangle-Left" class="headerlink" title="Triangle Left"></a>Triangle Left</h2><p>代码：</p>
<pre><code>#triangle-left{
    width:0;
    height:0;
    border-right: 80px solid #00ffff;
    border-top:40px solid transparent;
    border-bottom:40px solid transparent;
}
&lt;h3&gt;Triangle Left&lt;/h3&gt;
&lt;div id=&quot;triangle-left&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-left.PNG" alt=""></p>
<h2 id="Triangle-Right"><a href="#Triangle-Right" class="headerlink" title="Triangle Right"></a>Triangle Right</h2><p>代码：</p>
<pre><code>#triangle-right{
    width:0;
    height:0;
    border-left: 80px solid #00ffff;
    border-top:40px solid transparent;
    border-bottom:40px solid transparent;
}
&lt;h3&gt;Triangle Right&lt;/h3&gt;
&lt;div id=&quot;triangle-right&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-right.PNG" alt=""></p>
<h2 id="Triangle-Top-Left"><a href="#Triangle-Top-Left" class="headerlink" title="Triangle Top Left"></a>Triangle Top Left</h2><p>代码：</p>
<pre><code>#triangle-topleft{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-right:80px solid transparent;
}
&lt;h3&gt;Triangle Top Left&lt;/h3&gt;
&lt;div id=&quot;triangle-topleft&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-topleft.PNG" alt=""></p>
<h2 id="Triangle-Top-Right"><a href="#Triangle-Top-Right" class="headerlink" title="Triangle Top Right"></a>Triangle Top Right</h2><p>代码：</p>
<pre><code>#triangle-topright{
    width:0;
    height:0;
    border-top: 80px solid #00ffff;
    border-left:80px solid transparent;
}
&lt;h3&gt;Triangle Top Right&lt;/h3&gt;
&lt;div id=&quot;triangle-topright&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-topright.PNG" alt=""></p>
<h2 id="Triangle-Bottom-Left"><a href="#Triangle-Bottom-Left" class="headerlink" title="Triangle Bottom Left"></a>Triangle Bottom Left</h2><p>代码：</p>
<pre><code>#triangle-bottomleft{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-right:80px solid transparent;
}
&lt;h3&gt;Triangle Bottom Left&lt;/h3&gt;
&lt;div id=&quot;triangle-bottomleft&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottomleft.PNG" alt=""></p>
<h2 id="Triangle-Bottom-Right"><a href="#Triangle-Bottom-Right" class="headerlink" title="Triangle Bottom Right"></a>Triangle Bottom Right</h2><p>代码：</p>
<pre><code>#triangle-bottomright{
    width:0;
    height:0;
    border-bottom: 80px solid #00ffff;
    border-left:80px solid transparent;
}
&lt;h3&gt;Triangle Bottom Right&lt;/h3&gt;
&lt;div id=&quot;triangle-bottomright&quot;&gt;
&lt;/div&gt;
</code></pre><p>效果：</p>
<p><img src="/images/2017-02-23/triangle-bottomright.PNG" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo主题中加入相册功能]]></title>
      <url>https://fantasticzhang.github.io/2017/02/21/hexo%E4%B8%BB%E9%A2%98%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>前段时间一个朋友问我：怎么给自己的博客加入相册功能？我还真被问住了，因为搭建博客的初衷是写一些文字性的东西，并没有考虑过“相册”这回事。但被朋友问到后，仔细想了想，给博客加入相册功能还是挺不错的，可以和大家分享一些自己喜欢的图片。于是参考了网上的相关资料，最终实现了一个简单的相册功能。现把实现过程记录下来，以供大家参考。</p>
<p>主要是参考了<a href="http://www.cnblogs.com/xljzlw/p/5137622.html" target="_blank" rel="external">这篇文章</a>,但这篇文章的作者使用的是<code>yilia</code>主题，该主题已实现了相册功能。而我使用的是<a href="https://github.com/hsihohuang/kiddochan" target="_blank" rel="external">kiddochan</a>主题，这个主题并没有实现相册功能。因此，我的实现过程和我参考的那篇文章也略有不同，但整体流程还是类似的。</p>
<h2 id="新建相册页面"><a href="#新建相册页面" class="headerlink" title="新建相册页面"></a>新建相册页面</h2><p><code>hexo new page “photos”</code></p>
<p>执行上面的命令，会在<code>source</code>文件夹中生成一个<code>photo</code>文件夹，打开<code>photo</code>文件夹中的<code>index.md</code>文件，修改内容如下：</p>
<pre><code>---
title: 相册
---

&lt;link type=&quot;text/css&quot; href=&quot;/css/photo.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;link type=&quot;text/css&quot; href=&quot;/fancybox/jquery.fancybox.css&quot; rel=&quot;stylesheet&quot;&gt;

&lt;div class=&quot;photos&quot;&gt;
  &lt;section class=&quot;archives album&quot;&gt;
    &lt;ul class=&quot;img-box-ul&quot;&gt;&lt;/ul&gt;
  &lt;/section&gt;
&lt;/div&gt;
</code></pre><p>其中，’photo.css’用来控制相册样式，由于我使用的主题并没有实现相册功能，因此需要另写一个样式来控制相册的展示。</p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>在主题的配置文件<code>_config.yml</code>的menu下添加一个相册的菜单：</p>
<pre><code>menu:
  主页: /
  归档: /archives
  关于: /about
  相册: /photos
</code></pre><h2 id="存放图片"><a href="#存放图片" class="headerlink" title="存放图片"></a>存放图片</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先图片不能放在<code>source</code>文件夹中，因为需要编译成静态文件，非常慢。那么该放到哪里好呢？</p>
<p>在使用hexo搭建博客时，我们都会在github上会建立一个名为<code>username.github.io</code>的仓库，而且仓库只存储了整个项目的一部分。所以，一般我们都会在github上另建一个仓库，用来存储整个博客项目的文件对博客进行备份，这样就能在不同的电脑上写博客了。因此，我们可以在根目录下新建一个<code>photos</code>文件夹用来存放相册需要展示的图片文件，这样图片的数量就不受限制了。</p>
<h3 id="存放图片-1"><a href="#存放图片-1" class="headerlink" title="存放图片"></a>存放图片</h3><p>在博客的根目录下新建一个<code>photos</code>的文件夹，里面存放你想要展示的图片文件。然后把整个博客项目部署到github上，才能访问到图片的线上地址。</p>
<h2 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h2><p>那么多图片的文件名该怎么获取呢？由于原生<code>js</code>不能很好的处理文件，因此不能直接在js文件中获取图片的文件名。但我们可以新建一个基于nodejs的js文件用来读取所有图片，并把所有的图片名称放在一个json文件中供相册页面的js文件使用。</p>
<p>在<code>source\photo</code>文件夹中新建一个<code>tool.js</code>文件，内容如下：</p>
<pre><code>&quot;use strict&quot;;
    const fs = require(&quot;fs&quot;);
    const path = &quot;../../photos&quot;;

    fs.readdir(path, function (err, files) {
        if (err) {
            return;
        }
        let arr = [];
        (function iterator(index) {
            if (index == files.length) {
                fs.writeFile(&quot;output.json&quot;, JSON.stringify(arr, null, &quot;\t&quot;));
                return;
            }

            fs.stat(path + &quot;/&quot; + files[index], function (err, stats) {
                if (err) {
                    return;
                }
                if (stats.isFile()) {
                    arr.push(files[index]);
                }
                iterator(index + 1);
            })
        }(0));
    });
</code></pre><p>通过<code>node tool.js</code>命令运行该文件，会在<code>source\photos</code>下生成一个<code>output.json</code>文件:</p>
<pre><code>[
    &quot;IMG_20161005_164625.jpg&quot;,
    &quot;IMG_20161005_165430.jpg&quot;,
    &quot;IMG_20161005_165817.jpg&quot;,
    &quot;IMG_20161005_172129.jpg&quot;,
    &quot;IMG_20161006_130939.jpg&quot;,
    &quot;IMG_20161006_132426.jpg&quot;,
    &quot;IMG_20161006_132836.jpg&quot;,
    &quot;IMG_20161116_141430.jpg&quot;,
    &quot;IMG_20161116_150715.jpg&quot;,
    &quot;IMG_20161116_155406.jpg&quot;,
    &quot;IMG_20161118_124950.jpg&quot;,
    &quot;mmexport1479264425744.jpg&quot;,
    &quot;mmexport1479264435676.jpg&quot;
]
</code></pre><p>之后每次添加了新的图片，都要运行<code>node tool.js</code>来更新<code>output.json</code>文件的内容。</p>
<h2 id="生成相册页的代码"><a href="#生成相册页的代码" class="headerlink" title="生成相册页的代码"></a>生成相册页的代码</h2><p>在<code>myBlog\themes\kiddochan\source\js</code>（myBlog为我的博客根目录，kiddochan为我使用的主题，替换成相应的即可）文件夹下新建一个photo.js，代码如下：</p>
<pre><code>//相册功能 2017-02-20 add
var page = 1;
var offset = 20;

function photoShow(page ,data){
  var begin = (page - 1) * offset;
  var end = page * offset;
  if (begin &gt;= data.length) return;
  var html, li = &quot;&quot;;
  for (var i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) {
      li += &apos;&lt;li&gt;&lt;div class=&quot;img-box&quot;&gt;&apos; +
          &apos;&lt;a class=&quot;img-bg&quot; rel=&quot;example_group&quot; href=&quot;https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&apos; + data[i] + &apos;?raw=true&quot;&gt;&lt;/a&gt;&apos; +
          &apos;&lt;img lazy-src=&quot;https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&apos; + data[i] + &apos;?raw=true&quot; /&gt;&apos; +
          &apos;&lt;/li&gt;&apos;;
  }

  $(&quot;.img-box-ul&quot;).append(li);
  $(&quot;.img-box-ul&quot;).lazyload();
  $(&quot;a[rel=example_group]&quot;).fancybox();
}

function photoScroll(data){
  $(window).scroll(function() {
      var windowPageYOffset = window.pageYOffset;
      var windowPageYOffsetAddHeight = windowPageYOffset + window.innerHeight;
    //  var sensitivity = 0;
      var offsetTop = $(&quot;.photos&quot;).offset().top + $(&quot;.photos&quot;).height();
      if (offsetTop &gt;= windowPageYOffset &amp;&amp; offsetTop &lt; windowPageYOffsetAddHeight) {
          photoShow(++page, data);
      }
  })
}

var photoInit = function() {
    $.getJSON(&quot;/photos/output.json&quot;, function (data) {
        photoShow(page, data);

        photoScroll(data);
    });
}
</code></pre><p>  其中，<code>https://raw.githubusercontent.com/fantasticZhang/blog-back-up/master/photos/&#39; + data[i] + &#39;?raw=true&quot;</code>是上传至github的图片链接。</p>
<p>  该文件读取json文件，将图片的线上url拼接起来渲染在相册页面上。</p>
<p>  在<code>myBlog\themes\layout\_patial\after_footer.ejs</code>文件中加入了如下代码：</p>
<pre><code>&lt;!--相冊功能--&gt;
&lt;script src=&quot;/js/jquery.lazyload.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/js/photo.js&quot;&gt;&lt;/script&gt;

$(document).ready(function(){
  //相册功能 2017-02-20 add
  if($(&quot;.photos&quot;).length) {
      photoInit();
   }
});
</code></pre><p>根据实际所使用的主题，添加到相应位置即可。</p>
<p>最后，运行<code>hexo g</code>、<code>hexo d</code>等相应命令，相册功能就实现了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grid布局]]></title>
      <url>https://fantasticzhang.github.io/2017/02/18/Grid%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Grid布局（又称网格布局）是指：以规则的网格阵列来指导和规范网页中的版面布局以及信息分布。</p>
<h1 id="CSS-Grid布局"><a href="#CSS-Grid布局" class="headerlink" title="CSS Grid布局"></a>CSS Grid布局</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSS Grid布局是一种二维网格布局系统，旨在彻底改变基于网格的用户界面的设计。目前，CSS Grid布局仅仅是一个W3C工作草案，因此还没有被任何浏览器默认支持。在Chrome中体验Grid布局的方法：打来浏览器并输入chrome://flags，找到”experimental web platform features”（实验性网络平台功能）,启用并重启浏览器。Opera和Firefox也支持CSS Grid布局，具体启用方法可参考相关网络资料。</p>
<h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><p>在整个Grid布局中常用到的术语如下：</p>
<ul>
<li>网格容器（Grid Container）：所有网格项的父元素；</li>
<li>网格项（Grid Item）：网格容器的直接子元素；</li>
<li>网格线（Grid Line）：组成网格的分界线；</li>
<li>网格轨道（Grid Track）：两个相邻的网格线之间为网格轨道，即网格的行或列；</li>
<li>网格单元（Grid Cell）：网格轨道相交的区域；</li>
<li>网格区域（Grid Area）：由任意数量的网格单元组成；</li>
<li>间距（Gutters）：两个网格轨道之间的区域。</li>
</ul>
<h2 id="设置在网格容器上的属性"><a href="#设置在网格容器上的属性" class="headerlink" title="设置在网格容器上的属性"></a>设置在网格容器上的属性</h2><ul>
<li>display：属性值有：grid、inline-grid、subgrid；</li>
<li>grid-template-columns：用一组值来设置列的大小；</li>
<li>grid-template-rows：用一组值来设置行的大小；</li>
<li>grid-template-areas：通过获取网格项中的grid-area属性值来定义网格模板，用’.’代表空网格单元；</li>
<li>grid-column-gap：网格单元列间距；</li>
<li>grid-row-gap：网格单元行间距；</li>
<li>grid-gap：网格单元间距，是grid-column-gap和grid-row-gap的简写；</li>
<li>justify-items：垂直于列网格线对齐，适用于网格容器中的所有网格项。属性值有：start、end、center、stretch；</li>
<li>align-items：垂直于行网格线对齐，适用于网格容器中的所有网格项。属性值同上；</li>
<li>justify-content：在总网格区域大小小于网格容器时，使用该属性设置网格的对齐方式（垂直于列网格线对齐）。属性值有：start、end、center、stretch、space-around、space-between、space-evenly；</li>
<li>align-content：在总网格区域大小小于网格容器时，使用该属性设置网格的对齐方式（垂直于行网格线对齐）。属性值同上；</li>
<li>grid-auto-columns：设置隐式网格轨道（列）的大小，当定位网格项超出网格容器范围时，将自动创建隐式网格轨道；</li>
<li>grid-auto-rows：设置隐式网格轨道（行）的大小；</li>
<li>grid-auto-flow：在没有设置网格项的位置时，这个属性控制网格项的排列方式。属性值有：row、column、dense；</li>
<li>grid：一种简写形式，设置网格容器所有属性。属性值有：none，(grid-template-rows) / (grid-template-columns)，(grid-auto-flow) [(grid-auto-rows) [ /(grid-auto-columns)]]。</li>
</ul>
<h2 id="设置在网格项上的属性"><a href="#设置在网格项上的属性" class="headerlink" title="设置在网格项上的属性"></a>设置在网格项上的属性</h2><ul>
<li>grid-column-start：通过网格线来定义网格项的列开始位置；</li>
<li>grid-column-end：通过网格线来定义网格项的列结束位置；</li>
<li>grid-row-start：通过网格线来定义网格项的行开始位置；</li>
<li>grid-row-end：通过网格线来定义网格项的行结束位置；</li>
<li>grid-column：是 grid-column-start、grid-column-end的简写；</li>
<li>grid-row：是 grid-row-start、grid-row-end 的简写；</li>
<li>grid-area：定义网格项名字，以便创建模块；</li>
<li>justify-self：定义单个网格项垂直于列网格线的对齐方式；</li>
<li>align-self：定义单个网格项垂直于行网格线的对齐方式；</li>
</ul>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>代码：</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .grid_1{
            display: grid;
            grid-template-columns: 150px 20px 150px 20px 150px;
            grid-template-rows: auto 20px auto 20px auto;
        }
        .item1{
            grid-column: 1;
            grid-row: 1;
            background: blueviolet;
        }
        .item2{
            grid-column: 3;
            grid-row: 1;
            background: chocolate;
        }
        .item3{
            grid-column: 5;
            grid-row: 1;
            background: #e2e242;
        }
        .item4{
            grid-column: 1;
            grid-row: 3;
            background: #42e2b9;
        }
        .item5{
            grid-column: 3;
            grid-row: 3;
            background: #e28cc8;
        }
        .item6{
            grid-column: 5;
            grid-row: 3;
            background: #2be24c;
        }
        .item7{
            grid-column: 1;
            grid-row: 5;
            background: #c2e2da;
        }
        .item8{
            grid-column: 3;
            grid-row: 5;
            background: blueviolet;
        }
        .item9{
            grid-column: 5;
            grid-row: 5;
            background: #e2203f;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;section class=&quot;grid_1&quot;&gt;
    &lt;div class=&quot;item1&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;item2&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;item3&quot;&gt;3&lt;/div&gt;
    &lt;div class=&quot;item4&quot;&gt;4&lt;/div&gt;
    &lt;div class=&quot;item5&quot;&gt;5&lt;/div&gt;
    &lt;div class=&quot;item6&quot;&gt;6&lt;/div&gt;
    &lt;div class=&quot;item7&quot;&gt;7&lt;/div&gt;
    &lt;div class=&quot;item8&quot;&gt;8&lt;/div&gt;
    &lt;div class=&quot;item9&quot;&gt;9&lt;/div&gt;
&lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>效果图：</p>
<p><img src="/images/2017-02-18/Grid.PNG" alt=""></p>
<p>以上只是对CSS Grid布局的简单介绍，比较详细的介绍可参考<a href="http://peale.cn/2016/12/08/2016_12_8_grid/#more" target="_blank" rel="external">这篇文章</a></p>
<h1 id="Bootstrap对Grid布局的实现"><a href="#Bootstrap对Grid布局的实现" class="headerlink" title="Bootstrap对Grid布局的实现"></a>Bootstrap对Grid布局的实现</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过定义容器大小，平分12份，再调整内外边距，最后再结合媒体查询，就制作出了强大的响应式的栅格系统。</p>
<p>Bootstrap为不同的屏幕尺寸提供了不同的栅格样式。Bootstrap3中通过媒体查询@media定义了四种屏幕类型：超小屏幕设备手机（<768px，xs）、小屏幕设备平板（>= 768px，sm）、中等屏幕设备桌面（&gt;=992px，md）、大屏幕设备桌面（&gt;=1200px，lg）。针对四种不同的屏幕大小分别对container样式固定了尺寸（自动、750px、970px、1170px），例如：</768px，xs）、小屏幕设备平板（></p>
<pre><code>@media (min-width:1200){
  .container{ width:1170px; }
}
</code></pre><h2 id="Bootstrap中栅格系统的主要工作原理"><a href="#Bootstrap中栅格系统的主要工作原理" class="headerlink" title="Bootstrap中栅格系统的主要工作原理"></a>Bootstrap中栅格系统的主要工作原理</h2><ul>
<li>一行数据（row）必须包含在.container中，以便为其赋予合适的对齐方式和内边距（padding）。</li>
<li>使用行（row）在水平方向创建一组列（column）。</li>
<li>具体内容应当放置于列（column）内，而且只有列（column）可以作为行（row）的直接子元素。</li>
<li>内置了许多样式，可以使用像.row和.col-xs-5这样的样式来快速创建栅格布局。</li>
<li>通过设置padding从而创建列之间的间隔。然后通过为第一列和最后一列设置负的margin从而抵消掉padding的影响。</li>
<li>栅格系统中的列是通过指定1到12的值来表示其跨越的范围的。</li>
</ul>
<h2 id="涉及的CSS特性"><a href="#涉及的CSS特性" class="headerlink" title="涉及的CSS特性"></a>涉及的CSS特性</h2><ul>
<li>列组合涉及两个CSS特性：左浮动和宽度百分比；</li>
<li>列偏移（offset）涉及一个CSS特性：margin-left；</li>
<li>列排序（pull、push）涉及三个CSS特性：左浮动、left、right。</li>
</ul>
<p>此外，可使用Bootstrap提供的clearfix样式来清除浮动。</p>
<p>例：</p>
<pre><code>&lt;div class=”row”&gt;
    &lt;div class=”col-xs-6 col-sm-3”&gt;div1：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div2：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”clearfix visible-xs”&gt; &lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div3：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;div class=”col-xs-6 col-sm-3”&gt;div4：.col-xs-6 .col-sm-3&lt;/div&gt;
&lt;/div&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js修改url中某个指定参数的值]]></title>
      <url>https://fantasticzhang.github.io/2017/01/16/js%E4%BF%AE%E6%94%B9url%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location对象很特别，因为它既是window对象的属性，也是document对象的属性；也就是说，window.location和document.location引用的是同一个对象。location对象将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下面是location对象的所有属性。</p>
<ul>
<li>hash：返回URL中的hash（#号后跟的零或多个字符），如果URL中不包含散列，则返回空字符串；例: “#contents”</li>
<li>host：返回服务器名称和端口号（如果有）；例：”www.baidu.com:80”</li>
<li>hostname：返回不带端口号的服务器名称；例：”www.baidu.com”</li>
<li>href：返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值；例：”<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>“</li>
<li>pathname：返回URL中的目录和（或）文件名；例：”/WilleyCDA/“</li>
<li>port：返回URL中指定的端口号。如果没有则返回空串。例：”8080”</li>
<li>portocol：返回页面使用的协议，通常是http:或https:  例：”http:”</li>
<li>search：返回URL的查询字符串。这个字符串以问好开头；例：”?q=javascript”</li>
</ul>
<h2 id="js修改url中某个指定参数的值"><a href="#js修改url中某个指定参数的值" class="headerlink" title="js修改url中某个指定参数的值"></a>js修改url中某个指定参数的值</h2><p>下面是一个利用javascript修改url中某个参数的值的办法，可以直接修改当前url中的某个参数的值而不会导致这个url中同一个参数存在多个值的情况。</p>
<pre><code>/*
* url 目标url
* arg 需要替换的参数名称
* arg_val 替换后的参数的值
* return url 参数替换后的url
*/
function changeURLArg(url,arg,arg_val){
    var pattern=arg+&apos;=([^&amp;]*)&apos;;
    var replaceText=arg+&apos;=&apos;+arg_val;
    if(url.match(pattern)){
        var tmp=&apos;/(&apos;+ arg+&apos;=)([^&amp;]*)/gi&apos;;
        tmp=url.replace(eval(tmp),replaceText);
        return tmp;
    }else{
        if(url.match(&apos;[\?]&apos;)){
            return url+&apos;&amp;&apos;+replaceText;
        }else{
            return url+&apos;?&apos;+replaceText;
        }
    }
    return url+&apos;\n&apos;+arg+&apos;\n&apos;+arg_val;
}
</code></pre><p>使用方法：</p>
<pre><code>changeURLArg(&apos;http://www.daimajiayuan.com/test.php?class_id=3&amp;id=2&apos;,&apos;class_id&apos;,4);
</code></pre><p>结果：<a href="http://www.daimajiayuan.com/test.php?class_id=4&amp;id=2" target="_blank" rel="external">http://www.daimajiayuan.com/test.php?class_id=4&amp;id=2</a></p>
<p><a href="http://www.daimajiayuan.com/sitejs-17226-1.html" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转载】2016年JavaScript回顾]]></title>
      <url>https://fantasticzhang.github.io/2016/12/30/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%912016%E5%B9%B4JavaScript%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<p>2016年是值得纪念、奇怪的、有点高兴也有点可怕的一年，这一切取决于你怎么看。跟其他事件相比仅仅专注于javascript可能看起来没什么大不了，但对于每个web开发人员来说javascript都是工作生活中非常大的一部分。</p>
<p><a href="http://www.modulecounts.com/" target="_blank" rel="external">JavaScript的流行继续激增</a>。不是每个人都喜欢这种语言，但是你很少听到十年前的嘲笑意见。就个人而言，我一直喜欢JavaScript，即使在早期，那些令人沮丧的年代。只要从C++、Java或PHP方向接近它的人首先都会感到困惑：JavaScript看起来很熟悉，但又不是。克服你的假设，你会喜欢它简单的优雅，实用性和灵活性。（比如：日期处理仍然是一个噩梦！)</p>
<p>JavaScript在5月份庆祝了它21岁的生日，让我们回顾下它成熟发展的这第一年…</p>
<h2 id="ECMAScript发展"><a href="#ECMAScript发展" class="headerlink" title="ECMAScript发展"></a>ECMAScript发展</h2><p>ES6/2015是语言自诞生以来最重要的更新。规范花了七年才完成，但浏览器和运行时终于开始支持箭头函数，let、const，这带来了更多的乐趣。<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external"> ES6兼容性表正在变成一个光辉的绿色</a>。</p>
<p>如果你需要支持旧的浏览器，全面切换到ES6也许会有一点早。对于旧的浏览器，一年多前发布的项目。您可以用ES6到ES5编译器（如Babel），但是开发非常复杂，需要引入额外的构建步骤。</p>
<p>ES7/2016是更多的革命。一个令人兴奋的新功能是async，它允许异步代码以同步方式写入，而没有回调或Promises（继续困惑我）的语法复杂性。</p>
<h2 id="渐进式Web应用程序"><a href="#渐进式Web应用程序" class="headerlink" title="渐进式Web应用程序"></a>渐进式Web应用程序</h2><p>我最喜欢的基于JavaScript的2016年技术授予Progressive Web Apps。 PWA是在谷歌的<a href="https://developers.google.com/web/shows/cds/2015/progressive-web-apps-chrome-dev-summit-2015" target="_blank" rel="external">2015年Chrome开发者峰会</a>上宣布，但稳定的技术和工具终于在7月到达Chrome 52。 PWA允许离线优先功能，并取代片状AppCache方法。 Web应用程序终于可以和native应用程序竞争，并提供以下优势：</p>
<ul>
<li>主屏幕图标</li>
<li>快速启动和自定义闪屏</li>
<li>快速执行</li>
<li>离线功能，无需互联网连接</li>
<li>网址，链接和书签</li>
<li>全屏或主题界面</li>
<li>沙盒执行</li>
<li>本地或基于云的存储</li>
<li>更少的设备空间和处理资源</li>
<li>更好的安全性（HTTPS是先决条件）</li>
<li>从任何搜索引擎轻松发现</li>
<li>请在安装前尝试</li>
<li>更简单的部署：它只是一个Web应用程序</li>
<li>没有AppStore废话：你的应用程序可以包含任何裸体画并且你绝对会渴望没有人能拿走你30％的利润！</li>
</ul>
<p>最重要的是：任何网站或者应用程序可以在几小时内转换为PWA。步骤：</p>
<ol>
<li>在服务器上启用HTTPS。</li>
<li>创建一个应用程序清单 - 应用程序根目录中的JSON文件，用于定义名称，颜色，图标和显示选项。</li>
<li>创建一个Service Worker - 根目录中的JavaScript文件用于拦截网络调用,并且可以根据需要返回缓存或实时数据。</li>
</ol>
<p>初期例子很少，但是PWA提供了一个不错的机会“动员”您的Web应用程序。虽然不能保证苹果将实施这项技术，但这并不重要，你的应用程序仍然可以在Safari中工作，只是它不会从离线执行中受益。我有一种感觉一旦Android上web体验有明显提升,苹果将鼓励支持PWA。</p>
<p>有关详细信息，请参阅 <a href="https://dev.opera.com/articles/pwa-resources/" target="_blank" rel="external">Dev.Opera’s Progressive Web Apps: The definitive collection of resources</a>和<a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="external">Google的PWA指南</a>。</p>
<h2 id="框架固定"><a href="#框架固定" class="headerlink" title="框架固定"></a>框架固定</h2><p>很难做出一个公正的判断，但是<a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>似乎在今年受到最多的关注。你也许不同意;因为这取决于你使用的是什么，你曾经浏览过的地方和你说过的话！</p>
<p><a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>已经普及，2.0版本于9月发布。</p>
<p><a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a>可能已经失去了它在2015年获得的一些势头，但这可能会随着9月发布Angular 2而改变。新版本是一个完全重写;它不是向后兼容v1.0。</p>
<p>虽然新的框架和库是令人兴奋的，但是十年前的jQuery仍然强大。版本3.0于6月9日发布，v3.1随后于7月7日出现。该库现在以严格模式运行，支持Promise，并实现了各种修复。 （查看完整修改列表的<a href="http://jquery.com/upgrade-guide/3.0/" target="_blank" rel="external">升级指南</a>。）</p>
<p>在使用JavaScript的96.4％的网站上用了jQuery。与之相比，Angular是最常用的现代框架 - 占0.5％。 jQuery 1.x是最流行的版本，占93.5％的使用率。版本2.x占6.0％、版本3.x占0.5％。</p>
<p>我一直批评开发人员上来就直接使用jQuery。当有一个其他更合适的选择或只要一小段JavaScript就能实现需求的时候，它就会被过度使用了。然而，它提供了更浅的学习曲线，比大多数框架更灵活。其他框架或库要取代它需要很多年的时间。</p>
<h2 id="API滥用"><a href="#API滥用" class="headerlink" title="API滥用"></a>API滥用</h2><p>比如电池状态API。在我2013年写JavaScript的时候，它似乎很有用;当你的应用程序检测到用户的手机即将关机的时候，到底怎样才能更好的最小化网络请求和处理呢?</p>
<p>不幸的是，Mozilla预估大约有6％的网站用了这个API​​，但大多数是广告客户用来检测电池状态，并跟踪用户浏览了哪些网站的域名。也有可能是某些服务商知道一个用户手机快关机绝望的时候，以此来提高某些服务的价格，</p>
<p>虽然这不是JavaScript或API的问题，出于隐私方面的原因，Mozilla采取了空前的手段把电池状态API从Firefox 53中删除。这不太可能出现在ios设备中,其他具有类似原因的API也包括传感器和蓝牙。这是一个不太光彩的事情：这些API都有实际的好处，我希望隐私问题可以在未来的版本得到解决。</p>
<h2 id="Node新版本"><a href="#Node新版本" class="headerlink" title="Node新版本"></a>Node新版本</h2><p>每年Node.JS会给我们带来两次发布进度，4月的6.0版本和10月的7.0版本。</p>
<p>目前该平台呈上升趋势，尽管W3Techs报告Node.js服务器使用率仅为0.2％，而PHP为82.3％。这些数字可能有点误导，因为Node.js即使安装了，也不一定能识别。</p>
<p>因为php已经开始很久了，并且现在依然是服务端最靠谱的选择。然而，Node.js正在书写自己的历史，并被所有语言信仰的开发者广泛使用。</p>
<h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>我非常喜欢npm，并且认为它是Node.js工具火爆的主要原因之一。在npm上我从来没有遇到过太多的问题，但我不是在Facebook这样大的项目上工作。</p>
<p>Facebook的工程师在10月份发布了Yarn。它是一个新的Node.js包管理器，旨在比npm更快更稳定。它依赖于npm注册表，因此可以和npm保持完全兼容。</p>
<p>Tim Severien的<a href="https://www.sitepoint.com/yarn-vs-npm/" target="_blank" rel="external">Yarn vs npm：你需要知道的一切</a>。我同意他的结论：</p>
<p>虽然Yarn不是一个复制品，但它改善了npm几个缺陷的地方。如果npm从Yarn身上学习，并要求Facebook、谷歌和其他Yarn贡献者一起来改进npm，这样是不是很爽呢？</p>
<h2 id="厌倦疲劳"><a href="#厌倦疲劳" class="headerlink" title="厌倦疲劳"></a>厌倦疲劳</h2><p>2016年的有篇文章叫I-can’t-take-this-any-more入选了Jose Aguinaga的<a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.e4rkosi1w" target="_blank" rel="external">2016年学习JavaScript的感觉</a>。亚军：dayssincelastjavascriptframework.com。</p>
<p>这可能是种幽默的方式以表明当前JavaScript的状态，但有一点要说明的就是，就是现在要跟上最新的趋势，框架和建议变得越来越难。当面对大量的技术方案评估时，开发人员会相互争执。</p>
<p>我的建议：不要试图跟上。因为这根本做不到。你今天重点关注的任何系统,明天都将被更好的东西取代。为您的项目选择一个好的方案，并坚持使用它，除非它让工作变得很糟糕。</p>
<p>有一个是可以确定的就是JavaScript本身。首先学习语言，并继续扩展你的知识。您的经验将帮助您了解每个框架的运作方式，以便您做出明智的选择，即便这种选择可能是完全放弃所有的框架。</p>
<p>新年快乐！</p>
<p>原文链接：<a href="http://cnedwan.com/2016/12/21/%E8%AF%91-2016%E5%B9%B4Javascript%E5%9B%9E%E9%A1%BE.html" target="_blank" rel="external">【译】2016年javascript回顾</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文字循环无缝滚动特效代码]]></title>
      <url>https://fantasticzhang.github.io/2016/12/29/%E6%96%87%E5%AD%97%E5%BE%AA%E7%8E%AF%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8%E7%89%B9%E6%95%88%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>今天突然被问到了这个问题，现把我的解决方案记下来以便日后查看。下面是一个简单的小例子：</p>
<pre><code>&lt;div  id=&quot;textScroll&quot; style=&quot;overflow:hidden;height:200px;width:300px;font-size:14px;line-height:22px;text-align:left;padding:10px&quot;&gt;
&lt;div id=&quot;textScroll1&quot;&gt;
  文字实循环无缝滚动
  &lt;/div&gt;
&lt;div id=&quot;textScroll2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

//原理：设置好固定的宽高，内容的实际高度比这个高得多。控制滚动条，在滚到一定位置后减小滚动条高度，重复此过程。

var textScroll = document.getElementById(&quot;textScroll&quot;);
var textScroll1 = document.getElementById(&quot;textScroll1&quot;);
var textScroll2 = document.getElementById(&quot;textScroll2&quot;);
var speed=50;    //滚动速度值，值越大速度越慢

//复制文本,使文本总高度大于父元素高度，这样才能无缝滚动
var nnn=200/textScroll1.offsetHeight;
for(i=0;i&lt;nnn;i++){textScroll1.innerHTML+=&quot;&lt;br /&gt;&quot;+ textScroll1.innerHTML}
textScroll2.innerHTML = textScroll1.innerHTML;

function Marquee(){
if(textScroll2.offsetTop-textScroll.scrollTop&lt;=0)    //当滚动至textScroll2时
{
    textScroll.scrollTop-=textScroll1.offsetHeight;    //textScroll跳到最顶端,从头开始滚动

}
else{
    textScroll.scrollTop++;     //持续滚动
}
}

var MyMar = setInterval(Marquee,speed);        //设置定时器
textScroll.onmouseover = function(){clearInterval(MyMar)}    //鼠标经过时清除定时器达到滚动停止的目的
textScroll.onmouseout = function(){MyMar = setInterval(Marquee,speed)};    //鼠标移开时重设定时器
&lt;/script&gt;
</code></pre><p>例子很简单，可根据实际情况进行修改以满足实际需要。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序开发（一）]]></title>
      <url>https://fantasticzhang.github.io/2016/12/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>前段时间，微信小程序突然火了，朋友圈被刷屏了。但由于某些原因，博主一直没有了解它，终于在昨天，抽了些时间了解了下小程序，主要是阅读了官方文档，之后博主觉得，小程序还是蛮有意思的，于是决定将自己的学习过程记录下来，也希望能够和同样对微信小程序感兴趣的朋友们多多交流。</p>
<p>以下内容主要来自于<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/index.html?t=1481249514" title="小程序官方文档" target="_blank" rel="external">官方文档</a>。</p>
<h1 id="微信小程序简介"><a href="#微信小程序简介" class="headerlink" title="微信小程序简介"></a>微信小程序简介</h1><p>下面是官方给出的关于微信小程序的介绍：</p>
<p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。小程序、订阅号、服务号、企业号是并行的体系。</p>
<p>由官方的表述来看，通俗一点的说，微信小程序其实就是微信提高了自身对HTML5特性的支持能力，开放了更多的系统调用。因此，微信里的HTML5产品将有更好的用户体验，更快的加载速度以及更多的功能。</p>
<h1 id="小程序注册"><a href="#小程序注册" class="headerlink" title="小程序注册"></a>小程序注册</h1><p>目前，微信小程序只开放了对企业、政府、媒体以及其他组织的注册，并没有开放对个人开发者的注册，那么个人如何注册小程序并进行学习呢？博主主要是参考了网上的一个方法，亲测可用。<a href="https://www.zhihu.com/question/52268924" target="_blank" rel="external">参考链接</a></p>
<h1 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h1><p>下面是官方文档给出的一个简易教程，这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。</p>
<p>注：以下教程默认注册账号、开发者、体验者都是使用管理员微信号。</p>
<h2 id="获取微信小程序的AppID"><a href="#获取微信小程序的AppID" class="headerlink" title="获取微信小程序的AppID"></a>获取微信小程序的AppID</h2><p>注册微信小程序并登录后，就可以在网站的“设置”-“开发者设置”中，查看到微信小程序的AppID了。</p>
<p><img src="/images/2016-12-9/1.png" alt=""></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们需要通过<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html?t=20161122" target="_blank" rel="external">开发者工具</a>，来完成小程序创建和代码编辑。</p>
<p>开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“firstProject”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。</p>
<p>为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。</p>
<p>项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。默认demo运行结果如下：</p>
<p><img src="/images/2016-12-9/2.PNG" alt=""></p>
<h2 id="项目结构简介"><a href="#项目结构简介" class="headerlink" title="项目结构简介"></a>项目结构简介</h2><p>点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。</p>
<p>下面简单介绍下这三个文件的功能。</p>
<ul>
<li><p>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
<pre><code>//app.js
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync(&apos;logs&apos;) || []
    logs.unshift(Date.now())
    wx.setStorageSync(&apos;logs&apos;, logs)
  },
  getUserInfo:function(cb){
    var that = this
    if(this.globalData.userInfo){
      typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo
              typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)
            }
          })
        }
      })
    }
  },
  globalData:{
    userInfo:null
  }
})
</code></pre></li>
<li><p>app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p>
<pre><code>{
  &quot;pages&quot;:[
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;:{
    &quot;backgroundTextStyle&quot;:&quot;light&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,
    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,
    &quot;navigationBarTextStyle&quot;:&quot;black&quot;
  },
  &quot;tabBar&quot;: {
    &quot;position&quot;: &quot;bottom&quot;,
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre></li>
<li><p>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p>
<pre><code>/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
} 
</code></pre></li>
</ul>
<p>在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。</p>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成：</p>
<ul>
<li><p>.js后缀的文件是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
</li>
<li><p>.json后缀的文件是页面的配置文件，它是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</p>
</li>
<li><p>.wxss后缀的是页面的样式表文件，它也是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
</li>
<li><p>.wxml后缀的文件是页面结构文件，用来搭建页面结构，绑定数据和交互处理函数。</p>
</li>
</ul>
<p>以上就是页面结构的简单介绍，在小程序开发框架一节中还会对这部分内容进行详细介绍。</p>
<h2 id="手机预览"><a href="#手机预览" class="headerlink" title="手机预览"></a>手机预览</h2><p>开发者工具左侧菜单栏选择”项目”，点击”预览”，扫码后即可在微信客户端中体验。</p>
<p><img src="/images/2016-12-9/3.PNG" alt=""></p>
<h1 id="小程序开发框架"><a href="#小程序开发框架" class="headerlink" title="小程序开发框架"></a>小程序开发框架</h1><p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p>
<p>框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p>
<p>下面将从目录结构、配置、逻辑层和视图层四个方面对小程序开发框架进行介绍。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。在上一节中我们已经对目录结构进行了简单的了解。</p>
<ul>
<li><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，分别是：app.js、app.json、app.wxss 。其中，app.js是小程序的脚本代码，用来控制小程序的逻辑，它是必要的；app.json是对整个小程序的全局配置，它也是必要的；app.wxss是整个小程序的公共样式表，它是非必要的。</p>
</li>
<li><p>一个小程序页面由四个文件组成，分别是：.js、.json、.wxss、.wxml四个文件。其中.js后缀的文件是页面脚本文件，用来控制页面逻辑；.json后缀的文件是页面配置文件；.wxss后缀的是页面样式表文件；.wxml后缀的文件是页面结构文件。.js文件和.wxml文件是必要的，另外两个文件是非必要的。</p>
</li>
</ul>
<p>注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p>app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>
<p>以下是一个包含了所有配置选项的简单配置app.json ：</p>
<pre><code>{
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/index&quot;
  ],
  &quot;window&quot;: {
    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
  },
  &quot;tabBar&quot;: {
    &quot;list&quot;: [{
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,
      &quot;text&quot;: &quot;首页&quot;
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
  },
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  &quot;debug&quot;: true
}
</code></pre><p>app.json 配置项列表</p>
<p><img src="/images/2016-12-9/4.PNG" alt=""></p>
<p>下面对这些配置项进行简单介绍。</p>
<h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h4><p>接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。</p>
<p>文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。</p>
<h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<p><img src="/images/2016-12-9/5.PNG" alt=""></p>
<h4 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h4><p>如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p>tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。</p>
<p>属性如下：</p>
<p><img src="/images/2016-12-9/6.PNG" alt=""></p>
<p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p>
<p><img src="/images/2016-12-9/7.PNG" alt=""></p>
<h4 id="networkTimeout"><a href="#networkTimeout" class="headerlink" title="networkTimeout"></a>networkTimeout</h4><p>可以设置各种网络请求的超时时间。</p>
<p>属性值如下：</p>
<p><img src="/images/2016-12-9/8.PNG" alt=""></p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发。可以帮助开发者快速定位一些常见的问题。</p>
<h3 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a>page.json</h3><p>每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。由于页面的配置只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，下面是一个简单的例子：</p>
<pre><code>{
  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,
  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,
  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,
  &quot;backgroundTextStyle&quot;: &quot;light&quot;
}
</code></pre><h2 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h2><p>小程序开发框架的逻辑层是由JavaScript编写，为了方便地开发小程序，在JavaScript的基础上做了一些修改，主要如下：</p>
<ul>
<li>增加App和Page方法，进行程序和页面注册；</li>
<li>增加getApp和getCurrentPages方法，分别用来获取App实例和当前页面栈；</li>
<li>由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等;</li>
<li>每个页面有独立的作用域，并提供模块化能力;</li>
<li>提供丰富的 API;</li>
<li>开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</li>
</ul>
<h3 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h3><p>App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/9.PNG" alt=""></p>
<p>注： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p>
<h3 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h3><p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<p>object参数说明：</p>
<p><img src="/images/2016-12-9/10.PNG" alt=""></p>
<h4 id="Page-prototype-setData"><a href="#Page-prototype-setData" class="headerlink" title="Page.prototype.setData()"></a>Page.prototype.setData()</h4><p>setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。</p>
<p>注意：</p>
<ol>
<li>直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。</li>
<li>单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</li>
</ol>
<p>setData 函数接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。</p>
<p>其中 key 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。</p>
<p>例子：</p>
<pre><code>&lt;!--index.wxml--&gt;
&lt;view&gt;{{text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt;
&lt;view&gt;{{array[0].text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInArray&quot;&gt; Change Array data &lt;/button&gt;
&lt;view&gt;{{object.text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInObject&quot;&gt; Change Object data &lt;/button&gt;
&lt;view&gt;{{newField.text}}&lt;/view&gt;
&lt;button bindtap=&quot;addNewField&quot;&gt; Add new data &lt;/button&gt;
//index.js
Page({
  data: {
    text: &apos;init data&apos;,
    array: [{text: &apos;init data&apos;}],
    object: {
      text: &apos;init data&apos;
    }
  },
  changeText: function() {
    // this.data.text = &apos;changed data&apos;  // bad, it can not work
    this.setData({
      text: &apos;changed data&apos;
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      &apos;array[0].text&apos;:&apos;changed data&apos;
    })
  },
  changeItemInObject: function(){
    this.setData({
      &apos;object.text&apos;: &apos;changed data&apos;
    });
  },
  addNewField: function() {
    this.setData({
      &apos;newField.text&apos;: &apos;new data&apos;
    })
  }
})
</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置。</p>
<p>我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。</p>
<p>注：</p>
<ul>
<li>exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐使用 module.exports；</li>
<li>小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候可以拷贝出相关的代码到小程序的目录中。</li>
</ul>
<p>例子：</p>
<pre><code>// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
</code></pre><p>​在需要使用这些模块的文件中，使用 require(path) 将公共代码引入:</p>
<pre><code>var common = require(&apos;common.js&apos;)
Page({
  helloMINA: function() {
    common.sayHello(&apos;MINA&apos;)
  },
  goodbyeMINA: function() {
    common.sayGoodbye(&apos;MINA&apos;)
  }
})
</code></pre><h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。其中，WXML(WeiXin Markup language)用于描述页面的结构；WXSS(WeiXin Style Sheet)用于描述页面的样式；组件(Component)是视图的基本组成单元。</p>
<h3 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h3><p>WXML具有数据绑定、列表渲染、条件渲染、模板、事件和引用的功能。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>WXML 中的动态数据均来自对应 Page 的 data。</p>
<p>数据绑定使用Mustache语法（双大括号）将变量包起来，可以作用于：内容、组件属性、控制属性和关键字，其中后三者需要在双引号之内。</p>
<p>作用于关键字的例子：</p>
<pre><code>&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;    
</code></pre><ul>
<li><p>true：boolean 类型的 true，代表真值。</p>
</li>
<li><p>false： boolean 类型的 false，代表假值。</p>
</li>
</ul>
<p>注：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<p>还可在双大括号内进行简单的运算，支持的运算有：三元运算、算数运算、逻辑判断、字符串运算、数据路径运算等。</p>
<p>也可在双大括号内直接进行组合，构成新的对象或者数组。</p>
<p>具体的使用方法可参考官方文档给出的例子。</p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>在框架中，我们用<code>wx:if</code>来判断是否需要渲染该代码块：</p>
<pre><code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;
</code></pre><p>也可以用<code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p>
<pre><code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre><p>因为<code>wx:if</code>是一个控制属性，需要将它添加到一个标签上。但是如果我们想一次性判断多个组件标签，我们可以使用一个<code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<pre><code>&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>注意：<code>&lt;block/&gt;</code>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>在组件上使用<code>wx:for</code>控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，使用<code>wx:for-index</code> 可以指定数组当前下标的变量名。</p>
<p>例子：</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}}: {{itemName.message}}
&lt;/view&gt;
</code></pre><p>类似block wx:if，也可以将wx:for用在<block>标签上，以渲染一个包含多节点的结构块。</block></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如<code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<p><code>wx:key</code> 的值以两种形式提供：</p>
<ul>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li>
</ul>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>如不提供 <code>wx:key</code>，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p>
<p>示例代码：</p>
<pre><code>&lt;switch wx:for=&quot;{{objectArray}}&quot; wx:key=&quot;unique&quot; style=&quot;display: block;&quot;&gt; {{item.id}} &lt;/switch&gt;
&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;
&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;

&lt;switch wx:for=&quot;{{numberArray}}&quot; wx:key=&quot;*this&quot; style=&quot;display: block;&quot;&gt; {{item}} &lt;/switch&gt;
&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add to the front &lt;/button&gt;

Page({
  data: {
    objectArray: [
      {id: 5, unique: &apos;unique_5&apos;},
      {id: 4, unique: &apos;unique_4&apos;},
      {id: 3, unique: &apos;unique_3&apos;},
      {id: 2, unique: &apos;unique_2&apos;},
      {id: 1, unique: &apos;unique_1&apos;},
      {id: 0, unique: &apos;unique_0&apos;},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i &lt; length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: &apos;unique_&apos; + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
</code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。模板拥有自己的作用域，只能使用data传入的数据。</p>
<p>例子：</p>
<pre><code>//定义模板
&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;

//使用模板
&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt;
</code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h5><p>事件分为冒泡事件和非冒泡事件：</p>
<ul>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ul>
<p>冒泡事件包括：</p>
<ul>
<li>touchstart：手指触摸动作开始；</li>
<li>touchmove：手指触摸后移动；</li>
<li>touchcancel：手指触摸动作被打断，如来电提醒，弹窗；</li>
<li>touchend：手指触摸动作结束；</li>
<li>tap：手指触摸后马上离开；</li>
<li>longtap：手指触摸后，超过350ms再离开。</li>
</ul>
<p>除以上之外的其他组件自定义事件如无特殊申明都是非冒泡事件。</p>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p>
<ul>
<li>key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart；</li>
<li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li>
</ul>
<p>bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h5><p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p>
<p><img src="/images/2016-12-9/11.PNG" alt=""></p>
<ul>
<li>type：事件的类型；</li>
<li>timeStamp：页面打开到触发事件所经过的毫秒数；</li>
<li><p>target：触发事件的源组件，包括：</p>
<ul>
<li>id：String，事件源组件的id；</li>
<li>tagName：String，当前组件的类型；</li>
<li>dataset：Object，事件源组件上由data-开头的自定义属性组成的集合。</li>
</ul>
</li>
<li><p>currentTarget：事件绑定的当前组件，属性同target；</p>
</li>
<li><p>touches：是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p>
<ul>
<li><p>Touch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>pageX, pageY：Number，距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴；</li>
<li>clientX, clientY：Number，距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
<li><p>CanvasTouch 对象的属性：</p>
<ul>
<li>identifier：Number，触摸点的标识符；</li>
<li>x, y：Number，距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴。</li>
</ul>
</li>
</ul>
</li>
<li><p>changedTouches：数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p>
</li>
<li><p>detail：自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息等，具体参见官方文档。</p>
</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>WXML 提供两种文件引用方式import和include。</p>
<ul>
<li>import：可以在该文件中使用目标文件定义的template。import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</li>
<li>include：include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置。</li>
</ul>
<h3 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h3><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。与 CSS 相比，WXSS扩展的特性有：尺寸单位，样式导入。</p>
<h4 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h4><ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</li>
<li>rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。</li>
</ul>
<h4 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h4><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用;表示语句结束。</p>
<p>例子：</p>
<pre><code>/** common.wxss **/
.small-p {
  padding:5px;
}
/** app.wxss **/
@import &quot;common.wxss&quot;;
.middle-p {
  padding:15px;
}
</code></pre><p>WXSS目前支持的选择器有：<code>.class</code>、<code>#id</code>、<code>element</code>、<code>element, element</code>、<code>::after</code>、<code>::before</code>。</p>
<h2 id="组件和API"><a href="#组件和API" class="headerlink" title="组件和API"></a>组件和API</h2><p>框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<p>关于组件和API的详细内容参见<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/component/?t=20161122" target="_blank" rel="external">官方文档</a>.</p>
<p>官方文档阅读完后，就可以进行实际的开发了。对于一个新手来说，自己开发一个微信小程序可能有些难，不过网上有很多微信小程序的开发案例，可以在照着开发案例开发完一个微信小程序后，自己再独立的开发一个属性自己的微信小程序。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[同一台电脑关联两个或多个Github账号]]></title>
      <url>https://fantasticzhang.github.io/2016/12/07/%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%85%B3%E8%81%94%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAGithub%E8%B4%A6%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>今天遇到了一个问题，我自己有一个github账号，项目组有一个github账号，然后我需要在我的电脑上同时管理这两个github账号的仓库，这时候该怎么办呢？在查阅了一些资料后，成功解决了这个问题，现将解决方案记录下来，以便日后查看。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>管理两个SSH key。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h3><p><code>ssh-keygen -t rsa -C &quot;注册邮箱&quot;</code></p>
<p>使用上面的命令在本地生成SSH key。由于需要管理两个github账号，因此在保存所生成的SSH key时需要注意两个key的文件名要有区别，比如我第一个账号生成的文件名为<code>id_rsa</code>，第二个账号生成的文件名为<code>id_rsa.gtensor</code>，这样就可以加以区分。</p>
<h3 id="将SSH-key添加到github"><a href="#将SSH-key添加到github" class="headerlink" title="将SSH key添加到github"></a>将SSH key添加到github</h3><p>将上一步所生成的两个SSH key分别添加到对应的github账户中。</p>
<h3 id="创建config文件"><a href="#创建config文件" class="headerlink" title="创建config文件"></a>创建config文件</h3><p><code>$touch config</code></p>
<p>在.ssh目录下，使用以上命令新建一个config文件，并在文件中添加如下内容：</p>
<pre><code>#default github
Host github.com
  HostName github.com
  IdentityFile ~/.ssh/id_rsa    
#gtensor github
Host github_gtensor
  HostName github.com  
  IdentityFile ~/.ssh/id_rsa.gtensor
</code></pre><p>其中，Host后面就是github账号的别名，这里就是为第二个github账号新增了一个别名<code>github_gtensor</code>，这样就将不同的账号区分开了。config文件的内容，需要根据自己的实际情况进行相应修改。</p>
<h3 id="将SSH-key添加到ssh-agent上"><a href="#将SSH-key添加到ssh-agent上" class="headerlink" title="将SSH key添加到ssh-agent上"></a>将SSH key添加到ssh-agent上</h3><p><code>$ ssh-add ~/.ssh/id_rsa.gtensor</code></p>
<p>在.ssh目录下，使用上面的命令将第二个账号的key添加到agent上。在执行以上命令时可能会出现错误提示： <code>Could not open a connection to your authentication agent</code>，此时需要执行以下命令开启ssh-agent服务：</p>
<p><code>$ eval $(ssh-agent)</code></p>
<h3 id="测试github连接是否成功"><a href="#测试github连接是否成功" class="headerlink" title="测试github连接是否成功"></a>测试github连接是否成功</h3><p><code>$ ssh –T git@github_gtensor</code></p>
<p>使用以上命令测试是否能连接github账户，其中<code>github_gtensor</code>即为我所设置的第二个github账号的别名，需要根据实际情况进行修改。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过以上配置，我们就可以通过使用github.com的别名github_gtensor来明确说明我们要使用id_rsa.gtensor的SSH key来连接github，即使用项目组的github账号进行操作。</p>
<p>例如，要克隆第二个github账号的远程仓库到本地，则原来的写法：</p>
<pre><code>$ git clone git@github.com: 第二个github账号的用户名/***.git
</code></pre><p>则现在的写法改为：</p>
<pre><code>$ git clone git@github_gtensor: 第二个github账号的用户名/***.git
</code></pre><p>我的环境是：win10 + git bash，测试成功，如有任何疑问，可给我留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Node的子进程调用脚本和系统命令]]></title>
      <url>https://fantasticzhang.github.io/2016/12/04/%E5%88%A9%E7%94%A8Node%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>child_process模块使得Node可以随意创建子进程。它提供了4个方法用于创建子进程。</p>
<ul>
<li>spawn(): 启动一个子进程来执行命令。</li>
<li>exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile(): 启动一个子进程来执行可执行文件。</li>
<li>fork(): 与spawn()类似，不同点在于它创建Node的子进程只需要指定要执行的JavaScript文件模块即可。</li>
</ul>
<h2 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h2><h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn()"></a>spawn()</h3><p><code>child_process.spawn(command[, args][, options])</code></p>
<p>spawn方法返回一个对象流，适合于输出大量数据然后需要读取的应用场合。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
free = shellProcess.spawn(&apos;free&apos;, [&apos;-m&apos;]);

// 捕获标准输出并将其打印到控制台
free.stdout.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard output:\n&apos; + data);
});

// 捕获标准错误输出并将其打印到控制台
free.stderr.on(&apos;data&apos;, function (data) {
    console.log(&apos;standard error output:\n&apos; + data);
});

// 注册子进程关闭事件
free.on(&apos;exit&apos;, function (code) {
    console.log(&apos;child process exit ,exit:&apos; + code);
});
</code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p><code>child_process.exec(command[, options][, callback])</code></p>
<p>exec方法会启动一个子进程来执行系统命令，并缓冲产生的数据，当子进程完成后回调函数就会被调用，可带有：</p>
<ul>
<li>当命令成功执行，缓冲的数据；</li>
<li>当命令执行失败，错误信息。</li>
</ul>
<p>exec方法并没有args参数选项，这是因为它允许我们执行多个命令，当使用exec方法时，如果需要传输参数到命令行，则参数应该作为整个命令字符串的一部分。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;chmod -R a+rwx start.sh&apos;, function(err,stdout,stderr){  //设置start.sh脚本的权限
       if(err) {
          return console.log(&apos;error:&apos;+stderr);
        }
   });
</code></pre><h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile()"></a>execFile()</h3><p><code>child_process.execFile(file[, args][, options][, callback])</code></p>
<p>当外部可执行文件存在时，该可执行文件将携带参数args被执行，当可执行文件退出时，回调函数被调用，回调函数带有子进程的标准输入输出，来自外部可执行文件的标准输出将被内部缓冲保存。</p>
<p>使用案例：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.execFile(&apos;./stop.sh&apos;, function(err, stdout, stderr){
     if(err) return console.error(err);
     console.log(&apos;stdout: &apos;+stdout);
});
</code></pre><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><code>fork(modulePath[,args][,options])</code></p>
<p>其中modulePath是一个字符串，用来指定JavaScript文件路径。</p>
<p>由于该方法还没有实际使用过，所以目前对它还不太了解，在日后充分了解后再进行补充。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>spawn()与exec()、execFile()的区别：</p>
<ul>
<li>exec()、execFile()都有一个回调函数获知子进程的状况；</li>
<li>exec()、execFile()创建时可指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</li>
</ul>
</li>
<li><p>exec()与execFile()的区别：exec()适合执行已有的命令，execFile()适合执行文件。</p>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="使用exec-方法执行sudo命令"><a href="#使用exec-方法执行sudo命令" class="headerlink" title="使用exec()方法执行sudo命令"></a>使用exec()方法执行sudo命令</h3><p>由于sudo命令需要输入密码，所以执行sudo命令与执行普通命令有所区别，下面是两种比较简单的解决方法：</p>
<h5 id="方法一：-S选项"><a href="#方法一：-S选项" class="headerlink" title="方法一： -S选项"></a>方法一： -S选项</h5><p>sudo命令有个-S选项，用于在需要输入密码的时候，读取密码。</p>
<p>假设密码为password，且假设要使用sudo命令执行脚本文件 tee_to_monitor.sh ，并向其传递参数 status ，那么，完整命令如下</p>
<p><code>echo &quot;password&quot; | sudo -S ./tee_to_monitor.sh status</code></p>
<p>相应的，node代码可以这样</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;echo &quot;zjl&quot; | sudo -S ./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>该方法比较简单，只需要使用<code>sudo npm start</code>启动应用即可，假设同样是上面的例子，此时node代码如下：</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
shellProcess.exec(&apos;./tee_to_monitor.sh status&apos;,function(err, stdout, stderr){
    if(err) console.log(&apos;error: &apos;+stderr);
    console.log(stdout);
});
</code></pre><p>也就是说，如果使用sudo命令启动应用，则该应用中就不需要再用sudo了。</p>
<h3 id="使用exec-方法实时获取输出"><a href="#使用exec-方法实时获取输出" class="headerlink" title="使用exec()方法实时获取输出"></a>使用exec()方法实时获取输出</h3><p>如果按照前面例子中的方法使用exec()，则子进程完成后回调函数才会被调用，如果想要实时获取输出，则可按照下面的例子使用exec()。</p>
<pre><code>var shellProcess = require(&apos;child_process&apos;);
var child = shellProcess.exec(&apos;./start.sh&apos;);
// 捕获标准输出并使用socket通信传递数据
child.stdout.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 捕获标准错误输出并使用socket通信传递数据
child.stderr.on(&apos;data&apos;,function(data){
  app.io.sockets.emit(&apos;news&apos;, data);
});
// 注册子进程关闭事件
child.on(&apos;close&apos;,function(code){
  console.log(&apos;closing code: &apos;+code);
});
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的overflow属性和white-space属性]]></title>
      <url>https://fantasticzhang.github.io/2016/11/22/CSS%E7%9A%84overflow%E5%B1%9E%E6%80%A7%E5%92%8Cwhite-space%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>今天在写网页的时候用到了这两个属性，对于它们分别可能的取值及其含义一开始不是很确定，在查阅了网上的一些资料以及自己动手测试后，对它们每个可能取值的含义现已明确，因此记录下来方便之后查阅。</p>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p>overflow属性规定当内容溢出元素框时发生的事情。</p>
<h4 id="可能的取值"><a href="#可能的取值" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>visible：默认值。内容不会被修剪，会呈现在元素框之外。</li>
<li>hidden：内容会被修剪，并且其余内容是不可见的。</li>
<li>scroll：内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</li>
<li>auto：如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</li>
<li>inherit：从父元素继承overflow属性的值。</li>
</ul>
<h4 id="scroll和auto的区别"><a href="#scroll和auto的区别" class="headerlink" title="scroll和auto的区别"></a>scroll和auto的区别</h4><ul>
<li>scroll：内容自动撑开容器的宽度不包括滚动条，相当于滚动条是一个和内容并列显示的组件。</li>
<li><p>auto：内容撑开容器的宽度包括滚动条。即 使用<code>white-space:nowrape;</code>撑开容器至正好显示所有内容时，如果有滚动条，则滚动条会覆盖在内容上方，导致内容宽度被再次缩小，然后出现省略号。由此推断渲染顺序：</p>
<p>  自适应宽度-&gt;根据高度显示滚动条-&gt;重新计算内部元素宽度。 </p>
</li>
</ul>
<p>综上，如果宽度是由内容自适应撑开的，则<code>overflow:auto;</code>带来的滚动条会占用内容的一部分宽度，导致内容显示不全。</p>
<h3 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h3><p>该属性声明建立布局过程中如何处理元素中的空白符。</p>
<h4 id="可能的取值-1"><a href="#可能的取值-1" class="headerlink" title="可能的取值"></a>可能的取值</h4><ul>
<li>normal：默认值。连续的空白符会被合并，换行符会被当做空白符来处理。填充line盒子时，必要的话会换行。</li>
<li>pre: 连续的空白符会被保留。在遇到换行符或者\<br\>元素时才会换行。</br\></li>
<li>nowrap: 连续的空白符会被合并，文本不会换行，会在同一行上继续，直到遇到\<br\>标签为止。</br\></li>
<li>pre-wrap：连续的空白符会被保留，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>pre-line：连续的空白符会被合并，在遇到换行符或者\<br\>元素或者需要为了填充line盒子时才会换行。</br\></li>
<li>inherit：从父元素继承white-space属性的值。</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="external">参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的定位技术]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>CSS使用top、left、right、bottom设置元素的二维（x轴和y轴）偏移量。使用z-index设置元素垂直于屏幕的方向，也就是“z轴”的偏移量。</p>
<p>CSS使用position选项来定义元素的定位属性，该选项有五个可选值：static、relative、absolute、fixed、inherit，默认值是static。inherit属性表示继承父元素的定位属性，因此只需掌握static、relative、absolute、fixed这四种定位属性的特性即可。</p>
<h3 id="相对定位技术"><a href="#相对定位技术" class="headerlink" title="相对定位技术"></a>相对定位技术</h3><p>相对定位即相对于文档流中的其他已定义的元素位置进行定位。relative和static都是相对于文档其他元素进行定位，都属于相对定位的范畴，区别在于一个可以控制位移，一个不能。</p>
<h4 id="static（默认值）"><a href="#static（默认值）" class="headerlink" title="static（默认值）"></a>static（默认值）</h4><p>如果使用默认值，在CSS中为元素定义top、left、right、 bottom、z-index都不会生效。也就是说，如果想设置元素的偏移量和z-index，必须为元素定义position属性（static除外）。</p>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p>relative的表现和默认值一样，只不过可以通过设置偏移量和z-index来控制相对于其正常位置进行的偏移。</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位的元素有以下几个特点：</p>
<ul>
<li>块级元素的宽度在未定义时不再为100%，而是根据内容自动调整。</li>
<li>在不定义z-index的情况下，absolute元素会覆盖在其他元素之上。</li>
<li>它会脱离正常的文档流，不再占据空间，类似于浮动后的效果。</li>
</ul>
<p>absolute和fixed都属于绝对定位的范畴，都遵循以上3个特点。</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p>absolute是相对上一个不为static的父元素进行绝对定位。也就是说，如果不指定父元素的position，absolute将相对于整个html文档进行绝对定位。</p>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>fixed是相对于浏览器窗口进行定位。也就是说，不论网页如何滚动，该元素始终停留在屏幕的某个位置上。例如：我们希望侧边控制栏始终对用户可见，就可以使用<code>position:fixed</code>来进行定位。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS的优先级]]></title>
      <url>https://fantasticzhang.github.io/2016/11/21/CSS%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>如何确定CSS的优先级？首先要引入一个机制，分别用4个数字（a, b, c, d）表示优先级组合，它们的意思分别是：    </p>
<ul>
<li>第一个数字（a）表示style属性，优先级最高。由于一般都是class样式，所以该值一般都是0。  </li>
<li>第二个数字（b）是该CSS选择器上的id数量的总和，一般都是1个。</li>
<li>第三个数字（c）是用在该CSS选择器上的其他属性CSS选择器以及伪类的总和。这里包括class（比如 .btn）和属性选择器（比如 li[id=red]）。</li>
<li>第四个数字（d）计算元素（比如 table、p、div等）和伪元素（比如 first-child）。</li>
</ul>
<p>注：</p>
<ul>
<li>通用CSS选择器（*）是0优先级。</li>
<li>如果两个CSS选择器有同样的优先级，则在样式表中后面的那个起作用。</li>
</ul>
<p>几个例子：</p>
<ul>
<li>选择器：<code>#menu h2</code>， 优先级：0,1,0,1。   </li>
<li>选择器： <code>#leftbar li:first-child</code>，优先级： 0,1,0,2。 </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[又长大一岁啦]]></title>
      <url>https://fantasticzhang.github.io/2016/11/14/%E5%8F%88%E9%95%BF%E5%A4%A7%E4%B8%80%E5%B2%81%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>今天我又长大一岁啦~一大早就收到了爸爸妈妈的祝福和红包，以及好朋友的祝福，真的好开心~因此，想要简单记录一下这开心的一天。但由于博主经验不足图片格式还不太会调，可能看起来不太美观，以后会改正。</p>
<h3 id="美好的一天"><a href="#美好的一天" class="headerlink" title="美好的一天"></a>美好的一天</h3><p><img src="/images/2016-11-14/1.jpg" alt=""></p>
<p>闺蜜送的生日礼物，真的好喜欢，每一年的生日都给我好大的惊喜，也希望之后的每个生日都有你的陪伴。</p>
<p><img src="/images/2016-11-14/2.jpg" alt=""></p>
<p>早晨来到实验室就收到了学弟送的书，真的好感动~而且特意为我选了悬疑推理类的书，很符合我的口味，嘿嘿。真的很开心今年能认识你啦~</p>
<p><img src="/images/2016-11-14/3.jpg" alt=""></p>
<p>有个姐姐就是好，带我来吃海底捞啦，哈哈。一直听说海底捞的服务特别好，今天算是见识到了，店员知道今天我过生日，特意为我唱了生日快乐歌，而且还送了我礼物，真的好棒！对了，还可以免费做美甲，所以吃完饭后就做了一个，好开心。</p>
<p><img src="/images/2016-11-14/4.jpg" alt=""></p>
<p>店员知道今天我过生日，特意为我做了长寿面~</p>
<p><img src="/images/2016-11-14/5.jpg" alt=""></p>
<p>店家送给我的生日礼物，服务真的好周到。</p>
<p><img src="/images/2016-11-14/6.jpg" alt=""></p>
<p>最后，许下一个生日愿望，希望能实现~</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>今天一路上还收到了好多陌生人的祝福，真的好开心。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>https://fantasticzhang.github.io/2016/11/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>终于有自己的博客啦~</p>
<p>其实一直想要建一个属于自己的博客，用来记录自己日常生活中的点点滴滴、学习过程中整理的笔记以及一些技术感悟，记录自己读过的一些论文等，但由于自己的拖延症，一直没有弄:-P。终于，今天我也有了属于自己的博客啦，也希望自己之后能克服懒惰，经常更新。日积月累，总会有收获的。</p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>https://fantasticzhang.github.io/about/index.html</url>
      <content type="html"><![CDATA[<p>目前在北京读研，平时的工作主要是前端相关的。对前端技术也很感兴趣，处于边学边实践的阶段。欢迎志同道合的朋友与我多多交流，也期待大神的指点~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[学习过程中实现的实例demo]]></title>
      <url>https://fantasticzhang.github.io/demo/index.html</url>
      <content type="html"><![CDATA[<p>做前端和后台不太一样，总觉得只有自己动手做出来一些能看得见的东西，才会有一些成就感~</p>
<a id="more"></a>
<h2 id="实例一：Canvas小动画"><a href="#实例一：Canvas小动画" class="headerlink" title="实例一：Canvas小动画"></a>实例一：Canvas小动画</h2><p>使用html5的Canvas实现的一个小动画：模拟太空中一个行星群的运动。</p>
<ul>
<li>demo：<a href="/2017/03/10/实例demo之Canvas小动画/" title="实例demo之Canvas小动画">实例demo之Canvas小动画</a></li>
<li>源码：<a href="https://github.com/fantasticZhang/Asteroids" target="_blank" rel="external">View on GitHub</a></li>
</ul>
<h2 id="实例二：Fido-Bowling游戏"><a href="#实例二：Fido-Bowling游戏" class="headerlink" title="实例二：Fido Bowling游戏"></a>实例二：Fido Bowling游戏</h2><p>基于Canvas开发的一个小游戏——太空保龄球。将源码下载下来即可运行，无需安装任何插件。</p>
<ul>
<li>demo：<a href="/2017/03/12/实例demo之FidoBowling小游戏/" title="实例demo之FidoBowling小游戏">实例demo之FidoBowling小游戏</a></li>
<li>源码：<a href="https://github.com/fantasticZhang/FidoBowling" target="_blank" rel="external">View on GitHub</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[相册]]></title>
      <url>https://fantasticzhang.github.io/photos/index.html</url>
      <content type="html"><![CDATA[<p><link type="text/css" href="/css/photo.css" rel="stylesheet"></p>
<link type="text/css" href="/fancybox/jquery.fancybox.css" rel="stylesheet">

<div class="photos"><br>  <section class="archives album"><br>    <ul class="img-box-ul"></ul><br>  </section><br></div>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://fantasticzhang.github.io/photos/output.json</url>
      <content type="html"><![CDATA[["IMG_20161005_164625.jpg","IMG_20161005_165430.jpg","IMG_20161005_165817.jpg","IMG_20161005_172129.jpg","IMG_20161006_130939.jpg","IMG_20161006_132426.jpg","IMG_20161006_132836.jpg","IMG_20161116_141430.jpg","IMG_20161116_150715.jpg","IMG_20161116_155406.jpg","IMG_20161118_124950.jpg","mmexport1479264425744.jpg","mmexport1479264435676.jpg","wen.jpg"]]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>https://fantasticzhang.github.io/photos/tool.js</url>
      <content type="html"><![CDATA["use strict";
    const fs = require("fs");
    const path = "../../photos";

    fs.readdir(path, function (err, files) {
        if (err) {
            return;
        }
        let arr = [];
        (function iterator(index) {
            if (index == files.length) {
                fs.writeFile("output.json", JSON.stringify(arr, null, "\t"));
                return;
            }

            fs.stat(path + "/" + files[index], function (err, stats) {
                if (err) {
                    return;
                }
                if (stats.isFile()) {
                    arr.push(files[index]);
                }
                iterator(index + 1);
            })
        }(0));
    });
]]></content>
    </entry>
    
  
</search>
